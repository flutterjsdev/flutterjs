# Implementation Plan - FlutterJS Package Builder

[Goal Description]
Implement a custom "Package Builder" within `pubjs` that transpiles Dart packages to clean, modular JavaScript.
This approach replaces manual package mapping and avoids the "garbage code" associated with full `dart2js` compilation by producing ES6 modules that directly import the existing FlutterJS runtime (`@flutterjs/core`, `@flutterjs/material`).
The builder leverages `package:analyzer` to parse Dart AST and emit JavaScript that integrates seamlessly with the FlutterJS ecosystem.

## User Review Required
> [!IMPORTANT]
> **Custom Transpiler Scope**: This plan involves building a *source-to-source transpiler* (Dart -> JS).
> Initially, it will support:
> 1.  **Classes & Methods**: Converting Dart classes to JS classes.
> 2.  **Basic Types**: Converting [String](file:///c:/Jay/_Plugin/flutterjs/packages/flutterjs_engine/src/dependency_resolver.js#42-45), [int](file:///c:/Jay/_Plugin/flutterjs/packages/flutterjs_engine/src/code_transformer.js#628-680), `List`, [Map](file:///c:/Jay/_Plugin/flutterjs/packages/flutterjs_engine/src/build_integration_generator.js#279-297) to JS equivalents.
> 3.  **Imports**: Rewriting `package:flutter/material.dart` -> `@flutterjs/material`.
> 4.  **Exports**: Generating [index.js](file:///c:/Jay/_Plugin/flutterjs/packages/flutterjs_engine/src/index.js) (formerly [exports.json](file:///c:/Jay/_Plugin/flutterjs/packages/flutterjs_material/flutterjs_material/exports.json)) automatically.
>
> **Limitations**: Complex Dart features like `Isolates`, `Mirrors`, or complex generics may have limited support initially. Logic-heavy packages (like crypto) might still need `dart2js` fallback in the future.

## Proposed Changes

### `packages/pubjs`

#### [NEW] `lib/src/builder/transpiler.dart`
- Core logic for converting Dart AST to JavaScript.
- Uses `package:analyzer` to visit nodes.
- Handling `ClassDeclaration`: Emits ES6 `class`.
- Handling `MethodDeclaration`: Emits JS methods.
- Handling `ImportDirective`: Rewrites imports based on a mapping registry.

#### [NEW] `lib/src/builder/compiler_context.dart`
- Tracks scope, imports, and symbol mapping during transpilation.
- Manages the "Import Registry" (e.g., mapping `StatelessWidget` -> `import { StatelessWidget } from '@flutterjs/widgets'`).

#### [MODIFY] `lib/src/package_builder.dart`
- Update `buildPackage` to use the new `Transpiler`.
- Remove reliance on `build.js` scripts inside packages.
- Instead of checking for `build.js`, it will:
    1.  Parse `pubspec.yaml`.
    2.  Scan `lib/` for Dart files.
    3.  Transpile each file to `.js` in `dist/`.
    4.  Generate imports mapping.

#### [MODIFY] `pubspec.yaml`
- Add `analyzer` dependency.
- Add `code_builder` (optional, for cleaner output generation).

## Verification Plan

### Automated Tests
- Create unit tests in `packages/pubjs/test/transpiler_test.dart`:
    - Test Class compilation: `class Foo {}` -> `class Foo {}`.
    - Test Widget compilation: `class MyWidget extends StatelessWidget {}` -> `class MyWidget extends StatelessWidget {}`.
    - Test Import rewriting: `import 'package:flutter/material.dart'` -> `import ... from '@flutterjs/material'`.

### Manual Verification
1.  **Test with a Simple Package**:
    - Create a dummy Dart package `my_ui_package` with a simple `Container` widget.
    - Run `pubjs build-package my_ui_package`.
    - Verify the output `dist/my_ui_package.js` contains valid ES6 code and imports `@flutterjs/material`.
2.  **Integration Test**:
    - Link the built package into a FlutterJS app.
    - Verify the widget renders correctly in the browser.
