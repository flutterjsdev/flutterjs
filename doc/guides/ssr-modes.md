# Rendering Modes: CSR, SSR, and Hybrid

FlutterJS supports multiple rendering modes to optimize for different use cases.

---

## Overview

| Mode | Full Name | When to Use |
|------|-----------|-------------|
| **CSR** | Client-Side Rendering | SPAs, interactive apps |
| **SSR** | Server-Side Rendering | SEO-critical content, blogs |
| **Hybrid** | Hybrid Rendering | Best of both worlds |

---

## CSR (Client-Side Rendering)

### What is CSR?

The browser downloads JavaScript and renders the app entirely on the client side.

**Flow:**
```
1. Browser requests page
   ‚Üì
2. Server sends empty HTML + JS bundle
   ‚Üì
3. Browser downloads JS
   ‚Üì
4. JavaScript executes and renders UI
   ‚Üì
5. User sees content
```

### When to Use CSR

**‚úÖ Good for:**
- Single-page applications (SPAs)
- Apps behind login (no SEO needed)
- Highly interactive dashboards
- Internal tools

**‚ùå Not ideal for:**
- Content that needs SEO
- Slow networks (large JS bundle)
- Users with JavaScript disabled

### Example

Your FlutterJS app defaults to CSR mode:

```dart
// lib/main.dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('CSR App')),
        body: Center(child: Text('Rendered on client')),
      ),
    );
  }
}
```

**Build command:**
```bash
flutterjs build --mode csr
```

**Output:**
```html
<!-- index.html -->
<html>
  <head>
    <title>My App</title>
    <script src="app.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <!-- Content rendered by JavaScript -->
  </body>
</html>
```

### Pros & Cons

**Pros:**
- Fast navigation after initial load
- Rich interactivity
- Simple deployment (static hosting)

**Cons:**
- Slow first load (download JS first)
- Poor SEO (empty HTML until JS runs)
- Doesn't work without JavaScript

---

## SSR (Server-Side Rendering)

### What is SSR?

The server renders the full HTML before sending it to the browser.

**Flow:**
```
1. Browser requests page
   ‚Üì
2. Server executes FlutterJS app
   ‚Üì
3. Server generates full HTML
   ‚Üì
4. Server sends HTML to browser
   ‚Üì
5. User sees content immediately
   ‚Üì
6. JavaScript "hydrates" (adds interactivity)
```

### When to Use SSR

**‚úÖ Good for:**
- SEO-critical content (blogs, e-commerce, marketing sites)
- Content-heavy sites
- First-load performance matters
- Social media sharing (Open Graph previews)

**‚ùå Not ideal for:**
- Apps with no public content
- Highly dynamic apps that change constantly

### Configuration

> [!NOTE]
> For a technical deep dive into how Hydration works under the hood, see [VDOM Rendering & Hydration](../architecture/vdom-rendering.md#server-side-rendering-ssr--hydration).

Create a `flutterjs.config.js`:

```javascript
// flutterjs.config.js
module.exports = {
  mode: 'ssr',
  server: {
    port: 3000,
  },
};
```

**Build command:**
```bash
flutterjs build --mode ssr
```

### Server Setup

SSR requires a Node.js server:

```javascript
// server.js (generated by FlutterJS)
import express from 'express';
import { renderToHTML } from './dist/ssr.js';

const app = express();

app.get('*', async (req, res) => {
  const html = await renderToHTML(req.url);
  res.send(html);
});

app.listen(3000, () => {
  console.log('SSR server running on http://localhost:3000');
});
```

**Deploy to:**
- Vercel
- Netlify (with functions)
- AWS Lambda
- Your own Node.js server

### Pros & Cons

**Pros:**
- Excellent SEO (search engines see full HTML)
- Fast first paint (content visible immediately)
- Works without JavaScript (partially)
- Social media previews work

**Cons:**
- Requires Node.js server (can't use static hosting)
- Higher server costs
- More complex deployment

---

## Hybrid Rendering

### What is Hybrid?

Combines SSR for initial load with CSR for subsequent navigation.

**Flow:**
```
1. First page request ‚Üí SSR (server renders)
   ‚Üì
2. User sees content immediately
   ‚Üì
3. JavaScript loads in background
   ‚Üì
4. App "hydrates" (becomes interactive)
   ‚Üì
5. Subsequent navigation ‚Üí CSR (client-side, instant)
```

### When to Use Hybrid

**‚úÖ Best for:**
- Marketing websites with SPAs
- E-commerce sites
- Content sites with interactive features
- When you want both SEO and performance

### Configuration

```javascript
// flutterjs.config.js
module.exports = {
  mode: 'hybrid',
  ssr: {
    routes: ['/', '/about', '/pricing'],  // SSR these routes
  },
};
```

**Build command:**
```bash
flutterjs build --mode hybrid
```

### How It Works

```
Route: /           ‚Üí SSR (for SEO)
Route: /about      ‚Üí SSR (for SEO)
Route: /dashboard  ‚Üí CSR (no SEO needed)
Navigation: / ‚Üí /about ‚Üí CSR (instant, client-side)
```

### Pros & Cons

**Pros:**
- Best of both worlds
- SEO + fast navigation
- Flexible per-route rendering

**Cons:**
- Most complex setup
- Requires careful configuration
- Larger initial bundle

---

## Comparison Table

| Feature | CSR | SSR | Hybrid |
|---------|-----|-----|--------|
| **SEO** | ‚ùå Poor | ‚úÖ Excellent | ‚úÖ Excellent |
| **First Paint** | üê¢ Slow | ‚ö° Fast | ‚ö° Fast |
| **Navigation** | ‚ö° Instant | üê¢ Slow | ‚ö° Instant |
| **Deployment** | ‚úÖ Static | ‚ùå Server | ‚ùå Server |
| **Complexity** | ‚úÖ Simple | ‚ö†Ô∏è Medium | ‚ùå Complex |
| **Cost** | ‚úÖ Low | ‚ö†Ô∏è Medium | ‚ö†Ô∏è Medium |

---

## Configuration Reference

### CSR Configuration

```javascript
// flutterjs.config.js
module.exports = {
  mode: 'csr',
  build: {
    output: 'dist',
    minify: true,
  },
};
```

### SSR Configuration

```javascript
// flutterjs.config.js
module.exports = {
  mode: 'ssr',
  server: {
    port: 3000,
  },
  build: {
    output: 'dist',
    minify: true,
  },
};
```

### Hybrid Configuration

```javascript
// flutterjs.config.js
module.exports = {
  mode: 'hybrid',
  ssr: {
    routes: ['/', '/about', '/blog/*'],  // Glob patterns supported
  },
  server: {
    port: 3000,
  },
};
```

---

## SEO Considerations

### Meta Tags

Add meta tags for SEO (works in all modes):

```html
<!-- public/index.html -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- SEO -->
  <title>My FlutterJS App</title>
  <meta name="description" content="A fast, SEO-friendly web app built with FlutterJS">
  
  <!-- Open Graph (social media) -->
  <meta property="og:title" content="My FlutterJS App">
  <meta property="og:description" content="A fast, SEO-friendly web app">
  <meta property="og:image" content="https://example.com/preview.jpg">
  <meta property="og:url" content="https://example.com">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="My FlutterJS App">
  <meta name="twitter:description" content="A fast, SEO-friendly web app">
  <meta name="twitter:image" content="https://example.com/preview.jpg">
</head>
```

### Semantic HTML

FlutterJS generates semantic HTML automatically:

```html
<!-- FlutterJS output -->
<div class="flutter-scaffold">
  <header class="flutter-appbar">
    <h1>Page Title</h1>
  </header>
  <main>
    <article>
      <h2>Section Title</h2>
      <p>Content here...</p>
    </article>
  </main>
</div>
```

Search engines can understand this structure!

---

## Performance Tips

### 1. Code Splitting (Planned)

Split your app into chunks:

```javascript
// Future feature
module.exports = {
  build: {
    splitChunks: true,
  },
};
```

### 2. Lazy Loading (Planned)

Load routes on demand:

```dart
// Future feature
routes: {
  '/': () => HomeScreen(),
  '/profile': () => import('./screens/profile.dart'),  // Lazy loaded
}
```

### 3. Caching

Use service workers (PWA support planned):

```javascript
// Future feature
module.exports = {
  pwa: {
    enabled: true,
    cacheStrategy: 'networkFirst',
  },
};
```

---

## Deployment

### Deploy CSR (Static)

```bash
# Build
flutterjs build --mode csr

# Deploy to Netlify, Vercel, GitHub Pages, etc.
# Just upload the `dist/` folder!
```

### Deploy SSR (Node.js)

```bash
# Build
flutterjs build --mode ssr

# Deploy to Vercel, Netlify Functions, AWS Lambda
# Or run on your own Node.js server:
node server.js
```

---

## Current Status

> [!NOTE]
> **As of v1.0 (Jan 2026):**
> - ‚úÖ CSR mode fully supported
> - üöß SSR mode in development
> - üöß Hybrid mode planned

---

## Next Steps

- Try [Examples](../examples/counter-app.md)
- Learn about [Architecture](../architecture/overview.md)
- Explore [Widget Catalog](widget-catalog.md)
