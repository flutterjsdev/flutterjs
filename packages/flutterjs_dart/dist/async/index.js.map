{
  "version": 3,
  "sources": ["../../src/async/index.js"],
  "sourcesContent": ["// dart:async implementation\r\n\r\nexport class Timer {\r\n    constructor(duration, callback) {\r\n        this._timer = setTimeout(callback, duration.inMilliseconds || duration);\r\n    }\r\n\r\n    static periodic(duration, callback) {\r\n        const timer = new Timer(0, () => { });\r\n        // Clear initial timeout, set interval\r\n        clearTimeout(timer._timer);\r\n        timer._timer = setInterval(() => callback(timer), duration.inMilliseconds || duration);\r\n        return timer;\r\n    }\r\n\r\n    static run(callback) {\r\n        setTimeout(callback, 0);\r\n    }\r\n\r\n    cancel() {\r\n        clearTimeout(this._timer); // Works for clearInterval too in browsers usually\r\n        clearInterval(this._timer);\r\n    }\r\n}\r\n\r\nexport class Future {\r\n    constructor(computation) {\r\n        this._promise = new Promise((resolve, reject) => {\r\n            try {\r\n                const result = computation();\r\n                resolve(result);\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Internal: wrap existing promise\r\n    static _wrap(promise) {\r\n        const f = new Future(() => { });\r\n        f._promise = promise;\r\n        return f;\r\n    }\r\n\r\n    static value(value) {\r\n        return Future._wrap(Promise.resolve(value));\r\n    }\r\n\r\n    static error(error) {\r\n        return Future._wrap(Promise.reject(error));\r\n    }\r\n\r\n    static delayed(duration, computation) {\r\n        return Future._wrap(new Promise((resolve, reject) => {\r\n            setTimeout(() => {\r\n                try {\r\n                    if (computation) {\r\n                        resolve(computation());\r\n                    } else {\r\n                        resolve(null);\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, duration.inMilliseconds || duration);\r\n        }));\r\n    }\r\n\r\n    static wait(futures) {\r\n        const promises = futures.map(f => f instanceof Future ? f._promise : f);\r\n        return Future._wrap(Promise.all(promises));\r\n    }\r\n\r\n    then(onValue, { onError } = {}) {\r\n        const p = this._promise.then(\r\n            val => onValue(val),\r\n            err => {\r\n                if (onError) {\r\n                    return onError(err);\r\n                }\r\n                throw err;\r\n            }\r\n        );\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    catchError(onError, { test } = {}) {\r\n        const p = this._promise.catch(err => {\r\n            if (test && !test(err)) throw err;\r\n            return onError(err);\r\n        });\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    whenComplete(action) {\r\n        const p = this._promise.finally(() => {\r\n            return action();\r\n        });\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    // To allow await in JS specific code if needed (not standard Dart but helpful)\r\n    thenJS(onFulfilled, onRejected) {\r\n        return this._promise.then(onFulfilled, onRejected);\r\n    }\r\n}\r\n\r\nexport class Completer {\r\n    constructor() {\r\n        this.future = new Future(() => { });\r\n        // Replace the promise with one we control\r\n        this.future._promise = new Promise((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    complete(value) {\r\n        this._resolve(value);\r\n    }\r\n\r\n    completeError(error) {\r\n        this._reject(error);\r\n    }\r\n\r\n    get isCompleted() {\r\n        // Hard to track without extra state, skipping for lightweight wrapper\r\n        return false;\r\n    }\r\n}\r\n\r\nexport class Stream {\r\n    constructor() {\r\n        // Basic placeholder\r\n    }\r\n    // TODO: Full Stream implementation\r\n}\r\n\r\nexport class StreamController {\r\n    constructor() {\r\n        this.stream = new Stream();\r\n    }\r\n    // TODO: Full StreamController implementation\r\n}\r\n"],
  "mappings": "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",
  "names": ["Timer", "duration", "callback", "timer", "Future", "computation", "resolve", "reject", "result", "e", "promise", "f", "value", "error", "futures", "promises", "onValue", "onError", "p", "val", "err", "test", "action", "onFulfilled", "onRejected", "Completer", "Stream", "StreamController"]
}
