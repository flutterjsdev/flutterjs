{
  "version": 3,
  "sources": ["../../src/async/index.js"],
  "sourcesContent": ["// dart:async implementation\r\n\r\nexport class Timer {\r\n    constructor(duration, callback) {\r\n        this._timer = setTimeout(callback, duration.inMilliseconds || duration);\r\n    }\r\n\r\n    static periodic(duration, callback) {\r\n        const timer = new Timer(0, () => { });\r\n        // Clear initial timeout, set interval\r\n        clearTimeout(timer._timer);\r\n        timer._timer = setInterval(() => callback(timer), duration.inMilliseconds || duration);\r\n        return timer;\r\n    }\r\n\r\n    static run(callback) {\r\n        setTimeout(callback, 0);\r\n    }\r\n\r\n    cancel() {\r\n        clearTimeout(this._timer); // Works for clearInterval too in browsers usually\r\n        clearInterval(this._timer);\r\n    }\r\n}\r\n\r\nexport class Future {\r\n    constructor(computation) {\r\n        this._promise = new Promise((resolve, reject) => {\r\n            try {\r\n                const result = computation();\r\n                resolve(result);\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Internal: wrap existing promise\r\n    static _wrap(promise) {\r\n        const f = new Future(() => { });\r\n        f._promise = promise;\r\n        return f;\r\n    }\r\n\r\n    static value(value) {\r\n        return Future._wrap(Promise.resolve(value));\r\n    }\r\n\r\n    static error(error) {\r\n        return Future._wrap(Promise.reject(error));\r\n    }\r\n\r\n    static delayed(duration, computation) {\r\n        return Future._wrap(new Promise((resolve, reject) => {\r\n            setTimeout(() => {\r\n                try {\r\n                    if (computation) {\r\n                        resolve(computation());\r\n                    } else {\r\n                        resolve(null);\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, duration.inMilliseconds || duration);\r\n        }));\r\n    }\r\n\r\n    static wait(futures) {\r\n        const promises = futures.map(f => f instanceof Future ? f._promise : f);\r\n        return Future._wrap(Promise.all(promises));\r\n    }\r\n\r\n    then(onValue, { onError } = {}) {\r\n        const p = this._promise.then(\r\n            val => onValue(val),\r\n            err => {\r\n                if (onError) {\r\n                    return onError(err);\r\n                }\r\n                throw err;\r\n            }\r\n        );\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    catchError(onError, { test } = {}) {\r\n        const p = this._promise.catch(err => {\r\n            if (test && !test(err)) throw err;\r\n            return onError(err);\r\n        });\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    whenComplete(action) {\r\n        const p = this._promise.finally(() => {\r\n            return action();\r\n        });\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    // To allow await in JS specific code if needed (not standard Dart but helpful)\r\n    thenJS(onFulfilled, onRejected) {\r\n        return this._promise.then(onFulfilled, onRejected);\r\n    }\r\n}\r\n\r\nexport class Completer {\r\n    constructor() {\r\n        this.future = new Future(() => { });\r\n        // Replace the promise with one we control\r\n        this.future._promise = new Promise((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    complete(value) {\r\n        this._resolve(value);\r\n    }\r\n\r\n    completeError(error) {\r\n        this._reject(error);\r\n    }\r\n\r\n    get isCompleted() {\r\n        // Hard to track without extra state, skipping for lightweight wrapper\r\n        return false;\r\n    }\r\n}\r\n\r\nexport class StreamSubscription {\r\n    constructor(callbacks) {\r\n        this.callbacks = callbacks;\r\n        this.isPaused = false;\r\n        this.isCanceled = false;\r\n    }\r\n\r\n    cancel() {\r\n        this.isCanceled = true;\r\n        if (this.callbacks && this.callbacks.onCancel) {\r\n            this.callbacks.onCancel();\r\n        }\r\n    }\r\n\r\n    pause() {\r\n        this.isPaused = true;\r\n    }\r\n\r\n    resume() {\r\n        this.isPaused = false;\r\n    }\r\n}\r\n\r\nexport class Stream {\r\n    constructor(onListen) {\r\n        this._onListen = onListen;\r\n    }\r\n\r\n    listen(onData, { onError, onDone, cancelOnError } = {}) {\r\n        const subscription = new StreamSubscription({\r\n            onData,\r\n            onError,\r\n            onDone,\r\n            onCancel: () => {\r\n                // Cleanup logic if needed\r\n            }\r\n        });\r\n\r\n        if (this._onListen) {\r\n            const cancelCallback = this._onListen(subscription);\r\n            if (cancelCallback && typeof cancelCallback === 'function') {\r\n                subscription.callbacks.onCancel = cancelCallback;\r\n            }\r\n        }\r\n\r\n        return subscription;\r\n    }\r\n\r\n    // Basic transforms\r\n    map(convert) {\r\n        const controller = new StreamController();\r\n        this.listen(\r\n            data => controller.add(convert(data)),\r\n            {\r\n                onError: err => controller.addError(err),\r\n                onDone: () => controller.close()\r\n            }\r\n        );\r\n        return controller.stream;\r\n    }\r\n\r\n    static fromIterable(iterable) {\r\n        const controller = new StreamController();\r\n        // Run asynchronously\r\n        setTimeout(() => {\r\n            for (const item of iterable) {\r\n                if (controller.isClosed) break;\r\n                controller.add(item);\r\n            }\r\n            if (!controller.isClosed) controller.close();\r\n        }, 0);\r\n        return controller.stream;\r\n    }\r\n}\r\n\r\nexport class StreamController {\r\n    constructor() {\r\n        this._listeners = [];\r\n        this.isClosed = false;\r\n    }\r\n\r\n    get stream() {\r\n        if (!this._stream) {\r\n            this._stream = new Stream((subscription) => {\r\n                this._listeners.push(subscription);\r\n                return () => {\r\n                    const idx = this._listeners.indexOf(subscription);\r\n                    if (idx >= 0) this._listeners.splice(idx, 1);\r\n                };\r\n            });\r\n        }\r\n        return this._stream;\r\n    }\r\n\r\n    get hasListener() {\r\n        return this._listeners.length > 0;\r\n    }\r\n\r\n    add(event) {\r\n        if (this.isClosed) return;\r\n        // Copy to avoid modification while emitting\r\n        [...this._listeners].forEach(sub => {\r\n            if (!sub.isCanceled && !sub.isPaused && sub.callbacks.onData) {\r\n                sub.callbacks.onData(event);\r\n            }\r\n        });\r\n    }\r\n\r\n    addError(error) {\r\n        if (this.isClosed) return;\r\n        [...this._listeners].forEach(sub => {\r\n            if (!sub.isCanceled && !sub.isPaused && sub.callbacks.onError) {\r\n                sub.callbacks.onError(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    close() {\r\n        if (this.isClosed) return;\r\n        this.isClosed = true;\r\n        [...this._listeners].forEach(sub => {\r\n            if (!sub.isCanceled && !sub.isPaused && sub.callbacks.onDone) {\r\n                sub.callbacks.onDone();\r\n            }\r\n        });\r\n        this._listeners = [];\r\n    }\r\n}\r\n\r\n// --- Zone ---\r\nexport class Zone {\r\n    static get current() {\r\n        return _root;\r\n    }\r\n\r\n    fork({ specification, zoneValues } = {}) {\r\n        return this;\r\n    }\r\n\r\n    run(action) {\r\n        return action();\r\n    }\r\n\r\n    bindCallback(callback) {\r\n        return callback;\r\n    }\r\n\r\n    bindUnaryCallback(callback) {\r\n        return callback;\r\n    }\r\n\r\n    bindBinaryCallback(callback) {\r\n        return callback;\r\n    }\r\n}\r\n\r\nconst _root = new Zone();\r\n\r\nexport function runZoned(body, { zoneValues, zoneSpecification, onError } = {}) {\r\n    return body();\r\n}\r\n\r\nexport function runZonedGuarded(body, onError, { zoneValues, zoneSpecification } = {}) {\r\n    try {\r\n        return body();\r\n    } catch (e) {\r\n        onError(e, null);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["Timer", "duration", "callback", "timer", "Future", "computation", "resolve", "reject", "result", "e", "promise", "f", "value", "error", "futures", "promises", "onValue", "onError", "p", "val", "err", "test", "action", "onFulfilled", "onRejected", "Completer", "StreamSubscription", "callbacks", "Stream", "onListen", "onData", "onDone", "cancelOnError", "subscription", "cancelCallback", "convert", "controller", "StreamController", "data", "iterable", "item", "idx", "event", "sub", "Zone", "_root", "specification", "zoneValues", "runZoned", "body", "zoneSpecification", "runZonedGuarded"]
}
