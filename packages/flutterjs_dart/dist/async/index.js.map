{
  "version": 3,
  "sources": ["../../src/async/index.js"],
  "sourcesContent": ["// Copyright 2025 The FlutterJS Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style license that can be\r\n// found in the LICENSE file.\r\n\r\n// dart:async implementation\r\n\r\nexport class Timer {\r\n    constructor(duration, callback) {\r\n        this._timer = setTimeout(callback, duration.inMilliseconds || duration);\r\n    }\r\n\r\n    static periodic(duration, callback) {\r\n        const timer = new Timer(0, () => { });\r\n        // Clear initial timeout, set interval\r\n        clearTimeout(timer._timer);\r\n        timer._timer = setInterval(() => callback(timer), duration.inMilliseconds || duration);\r\n        return timer;\r\n    }\r\n\r\n    static run(callback) {\r\n        setTimeout(callback, 0);\r\n    }\r\n\r\n    cancel() {\r\n        clearTimeout(this._timer); // Works for clearInterval too in browsers usually\r\n        clearInterval(this._timer);\r\n    }\r\n}\r\n\r\nexport class Future {\r\n    constructor(computation) {\r\n        this._promise = new Promise((resolve, reject) => {\r\n            try {\r\n                const result = computation();\r\n                resolve(result);\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Internal: wrap existing promise\r\n    static _wrap(promise) {\r\n        const f = new Future(() => { });\r\n        f._promise = promise;\r\n        return f;\r\n    }\r\n\r\n    static value(value) {\r\n        return Future._wrap(Promise.resolve(value));\r\n    }\r\n\r\n    static error(error) {\r\n        return Future._wrap(Promise.reject(error));\r\n    }\r\n\r\n    static delayed(duration, computation) {\r\n        return Future._wrap(new Promise((resolve, reject) => {\r\n            setTimeout(() => {\r\n                try {\r\n                    if (computation) {\r\n                        resolve(computation());\r\n                    } else {\r\n                        resolve(null);\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, duration.inMilliseconds || duration);\r\n        }));\r\n    }\r\n\r\n    static wait(futures) {\r\n        const promises = futures.map(f => f instanceof Future ? f._promise : f);\r\n        return Future._wrap(Promise.all(promises));\r\n    }\r\n\r\n    then(onValue, { onError } = {}) {\r\n        const p = this._promise.then(\r\n            val => onValue(val),\r\n            err => {\r\n                if (onError) {\r\n                    return onError(err);\r\n                }\r\n                throw err;\r\n            }\r\n        );\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    catchError(onError, { test } = {}) {\r\n        const p = this._promise.catch(err => {\r\n            if (test && !test(err)) throw err;\r\n            return onError(err);\r\n        });\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    whenComplete(action) {\r\n        const p = this._promise.finally(() => {\r\n            return action();\r\n        });\r\n        return Future._wrap(p);\r\n    }\r\n\r\n    // To allow await in JS specific code if needed (not standard Dart but helpful)\r\n    thenJS(onFulfilled, onRejected) {\r\n        return this._promise.then(onFulfilled, onRejected);\r\n    }\r\n}\r\n\r\nexport class Completer {\r\n    constructor() {\r\n        this.future = new Future(() => { });\r\n        // Replace the promise with one we control\r\n        this.future._promise = new Promise((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    complete(value) {\r\n        this._resolve(value);\r\n    }\r\n\r\n    completeError(error) {\r\n        this._reject(error);\r\n    }\r\n\r\n    get isCompleted() {\r\n        // Hard to track without extra state, skipping for lightweight wrapper\r\n        return false;\r\n    }\r\n}\r\n\r\nexport * from './stream.js';\r\n\r\n// --- Zone ---\r\nexport class Zone {\r\n    static get current() {\r\n        return _root;\r\n    }\r\n\r\n    fork({ specification, zoneValues } = {}) {\r\n        return this;\r\n    }\r\n\r\n    run(action) {\r\n        return action();\r\n    }\r\n\r\n    bindCallback(callback) {\r\n        return callback;\r\n    }\r\n\r\n    bindUnaryCallback(callback) {\r\n        return callback;\r\n    }\r\n\r\n    bindBinaryCallback(callback) {\r\n        return callback;\r\n    }\r\n}\r\n\r\nconst _root = new Zone();\r\n\r\nexport function runZoned(body, { zoneValues, zoneSpecification, onError } = {}) {\r\n    return body();\r\n}\r\n\r\nexport function runZonedGuarded(body, onError, { zoneValues, zoneSpecification } = {}) {\r\n    try {\r\n        return body();\r\n    } catch (e) {\r\n        onError(e, null);\r\n    }\r\n}\r\nexport * from './stream_view.js';\r\n"],
  "mappings": "AAMO,MAAMA,CAAM,CACf,YAAYC,EAAUC,EAAU,CAC5B,KAAK,OAAS,WAAWA,EAAUD,EAAS,gBAAkBA,CAAQ,CAC1E,CAEA,OAAO,SAASA,EAAUC,EAAU,CAChC,MAAMC,EAAQ,IAAIH,EAAM,EAAG,IAAM,CAAE,CAAC,EAEpC,oBAAaG,EAAM,MAAM,EACzBA,EAAM,OAAS,YAAY,IAAMD,EAASC,CAAK,EAAGF,EAAS,gBAAkBA,CAAQ,EAC9EE,CACX,CAEA,OAAO,IAAID,EAAU,CACjB,WAAWA,EAAU,CAAC,CAC1B,CAEA,QAAS,CACL,aAAa,KAAK,MAAM,EACxB,cAAc,KAAK,MAAM,CAC7B,CACJ,CAEO,MAAME,CAAO,CAChB,YAAYC,EAAa,CACrB,KAAK,SAAW,IAAI,QAAQ,CAACC,EAASC,IAAW,CAC7C,GAAI,CACA,MAAMC,EAASH,EAAY,EAC3BC,EAAQE,CAAM,CAClB,OAASC,EAAG,CACRF,EAAOE,CAAC,CACZ,CACJ,CAAC,CACL,CAGA,OAAO,MAAMC,EAAS,CAClB,MAAMC,EAAI,IAAIP,EAAO,IAAM,CAAE,CAAC,EAC9B,OAAAO,EAAE,SAAWD,EACNC,CACX,CAEA,OAAO,MAAMC,EAAO,CAChB,OAAOR,EAAO,MAAM,QAAQ,QAAQQ,CAAK,CAAC,CAC9C,CAEA,OAAO,MAAMC,EAAO,CAChB,OAAOT,EAAO,MAAM,QAAQ,OAAOS,CAAK,CAAC,CAC7C,CAEA,OAAO,QAAQZ,EAAUI,EAAa,CAClC,OAAOD,EAAO,MAAM,IAAI,QAAQ,CAACE,EAASC,IAAW,CACjD,WAAW,IAAM,CACb,GAAI,CAEID,EADAD,EACQA,EAAY,EAEZ,IAFa,CAI7B,OAASI,EAAG,CACRF,EAAOE,CAAC,CACZ,CACJ,EAAGR,EAAS,gBAAkBA,CAAQ,CAC1C,CAAC,CAAC,CACN,CAEA,OAAO,KAAKa,EAAS,CACjB,MAAMC,EAAWD,EAAQ,IAAIH,GAAKA,aAAaP,EAASO,EAAE,SAAWA,CAAC,EACtE,OAAOP,EAAO,MAAM,QAAQ,IAAIW,CAAQ,CAAC,CAC7C,CAEA,KAAKC,EAAS,CAAE,QAAAC,CAAQ,EAAI,CAAC,EAAG,CAC5B,MAAMC,EAAI,KAAK,SAAS,KACpBC,GAAOH,EAAQG,CAAG,EAClBC,GAAO,CACH,GAAIH,EACA,OAAOA,EAAQG,CAAG,EAEtB,MAAMA,CACV,CACJ,EACA,OAAOhB,EAAO,MAAMc,CAAC,CACzB,CAEA,WAAWD,EAAS,CAAE,KAAAI,CAAK,EAAI,CAAC,EAAG,CAC/B,MAAMH,EAAI,KAAK,SAAS,MAAME,GAAO,CACjC,GAAIC,GAAQ,CAACA,EAAKD,CAAG,EAAG,MAAMA,EAC9B,OAAOH,EAAQG,CAAG,CACtB,CAAC,EACD,OAAOhB,EAAO,MAAMc,CAAC,CACzB,CAEA,aAAaI,EAAQ,CACjB,MAAMJ,EAAI,KAAK,SAAS,QAAQ,IACrBI,EAAO,CACjB,EACD,OAAOlB,EAAO,MAAMc,CAAC,CACzB,CAGA,OAAOK,EAAaC,EAAY,CAC5B,OAAO,KAAK,SAAS,KAAKD,EAAaC,CAAU,CACrD,CACJ,CAEO,MAAMC,CAAU,CACnB,aAAc,CACV,KAAK,OAAS,IAAIrB,EAAO,IAAM,CAAE,CAAC,EAElC,KAAK,OAAO,SAAW,IAAI,QAAQ,CAACE,EAASC,IAAW,CACpD,KAAK,SAAWD,EAChB,KAAK,QAAUC,CACnB,CAAC,CACL,CAEA,SAASK,EAAO,CACZ,KAAK,SAASA,CAAK,CACvB,CAEA,cAAcC,EAAO,CACjB,KAAK,QAAQA,CAAK,CACtB,CAEA,IAAI,aAAc,CAEd,MAAO,EACX,CACJ,CAEA,WAAc,cAGP,MAAMa,CAAK,CACd,WAAW,SAAU,CACjB,OAAOC,CACX,CAEA,KAAK,CAAE,cAAAC,EAAe,WAAAC,CAAW,EAAI,CAAC,EAAG,CACrC,OAAO,IACX,CAEA,IAAIP,EAAQ,CACR,OAAOA,EAAO,CAClB,CAEA,aAAapB,EAAU,CACnB,OAAOA,CACX,CAEA,kBAAkBA,EAAU,CACxB,OAAOA,CACX,CAEA,mBAAmBA,EAAU,CACzB,OAAOA,CACX,CACJ,CAEA,MAAMyB,EAAQ,IAAID,EAEX,SAASI,EAASC,EAAM,CAAE,WAAAF,EAAY,kBAAAG,EAAmB,QAAAf,CAAQ,EAAI,CAAC,EAAG,CAC5E,OAAOc,EAAK,CAChB,CAEO,SAASE,EAAgBF,EAAMd,EAAS,CAAE,WAAAY,EAAY,kBAAAG,CAAkB,EAAI,CAAC,EAAG,CACnF,GAAI,CACA,OAAOD,EAAK,CAChB,OAAStB,EAAG,CACRQ,EAAQR,EAAG,IAAI,CACnB,CACJ,CACA,WAAc",
  "names": ["Timer", "duration", "callback", "timer", "Future", "computation", "resolve", "reject", "result", "e", "promise", "f", "value", "error", "futures", "promises", "onValue", "onError", "p", "val", "err", "test", "action", "onFulfilled", "onRejected", "Completer", "Zone", "_root", "specification", "zoneValues", "runZoned", "body", "zoneSpecification", "runZonedGuarded"]
}
