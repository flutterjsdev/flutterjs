// Copyright 2025 The FlutterJS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

class l{constructor(e,t){this._timer=setTimeout(t,e.inMilliseconds||e)}static periodic(e,t){const s=new l(0,()=>{});return clearTimeout(s._timer),s._timer=setInterval(()=>t(s),e.inMilliseconds||e),s}static run(e){setTimeout(e,0)}cancel(){clearTimeout(this._timer),clearInterval(this._timer)}}class i{constructor(e){this._promise=new Promise((t,s)=>{try{const r=e();t(r)}catch(r){s(r)}})}static _wrap(e){const t=new i(()=>{});return t._promise=e,t}static value(e){return i._wrap(Promise.resolve(e))}static error(e){return i._wrap(Promise.reject(e))}static delayed(e,t){return i._wrap(new Promise((s,r)=>{setTimeout(()=>{try{s(t?t():null)}catch(o){r(o)}},e.inMilliseconds||e)}))}static wait(e){const t=e.map(s=>s instanceof i?s._promise:s);return i._wrap(Promise.all(t))}then(e,{onError:t}={}){const s=this._promise.then(r=>e(r),r=>{if(t)return t(r);throw r});return i._wrap(s)}catchError(e,{test:t}={}){const s=this._promise.catch(r=>{if(t&&!t(r))throw r;return e(r)});return i._wrap(s)}whenComplete(e){const t=this._promise.finally(()=>e());return i._wrap(t)}thenJS(e,t){return this._promise.then(e,t)}}class d{constructor(){this.future=new i(()=>{}),this.future._promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}complete(e){this._resolve(e)}completeError(e){this._reject(e)}get isCompleted(){return!1}}class h{constructor(e){this.callbacks=e,this.isPaused=!1,this.isCanceled=!1}cancel(){this.isCanceled=!0,this.callbacks&&this.callbacks.onCancel&&this.callbacks.onCancel()}pause(){this.isPaused=!0}resume(){this.isPaused=!1}}class u{constructor(e){this._onListen=e}listen(e,{onError:t,onDone:s,cancelOnError:r}={}){const o=new h({onData:e,onError:t,onDone:s,onCancel:()=>{}});if(this._onListen){const c=this._onListen(o);c&&typeof c=="function"&&(o.callbacks.onCancel=c)}return o}map(e){const t=new a;return this.listen(s=>t.add(e(s)),{onError:s=>t.addError(s),onDone:()=>t.close()}),t.stream}static fromIterable(e){const t=new a;return setTimeout(()=>{for(const s of e){if(t.isClosed)break;t.add(s)}t.isClosed||t.close()},0),t.stream}}class a{constructor(){this._listeners=[],this.isClosed=!1}get stream(){return this._stream||(this._stream=new u(e=>(this._listeners.push(e),()=>{const t=this._listeners.indexOf(e);t>=0&&this._listeners.splice(t,1)}))),this._stream}get hasListener(){return this._listeners.length>0}add(e){this.isClosed||[...this._listeners].forEach(t=>{!t.isCanceled&&!t.isPaused&&t.callbacks.onData&&t.callbacks.onData(e)})}addError(e){this.isClosed||[...this._listeners].forEach(t=>{!t.isCanceled&&!t.isPaused&&t.callbacks.onError&&t.callbacks.onError(e)})}close(){this.isClosed||(this.isClosed=!0,[...this._listeners].forEach(e=>{!e.isCanceled&&!e.isPaused&&e.callbacks.onDone&&e.callbacks.onDone()}),this._listeners=[])}}class m{static get current(){return p}fork({specification:e,zoneValues:t}={}){return this}run(e){return e()}bindCallback(e){return e}bindUnaryCallback(e){return e}bindBinaryCallback(e){return e}}const p=new m;function f(n,{zoneValues:e,zoneSpecification:t,onError:s}={}){return n()}function _(n,e,{zoneValues:t,zoneSpecification:s}={}){try{return n()}catch(r){e(r,null)}}export{d as Completer,i as Future,u as Stream,a as StreamController,h as StreamSubscription,l as Timer,m as Zone,f as runZoned,_ as runZonedGuarded};
//# sourceMappingURL=index.js.map
