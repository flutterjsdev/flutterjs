class c{constructor(e,t){this._timer=setTimeout(t,e.inMilliseconds||e)}static periodic(e,t){const r=new c(0,()=>{});return clearTimeout(r._timer),r._timer=setInterval(()=>t(r),e.inMilliseconds||e),r}static run(e){setTimeout(e,0)}cancel(){clearTimeout(this._timer),clearInterval(this._timer)}}class i{constructor(e){this._promise=new Promise((t,r)=>{try{const s=e();t(s)}catch(s){r(s)}})}static _wrap(e){const t=new i(()=>{});return t._promise=e,t}static value(e){return i._wrap(Promise.resolve(e))}static error(e){return i._wrap(Promise.reject(e))}static delayed(e,t){return i._wrap(new Promise((r,s)=>{setTimeout(()=>{try{r(t?t():null)}catch(n){s(n)}},e.inMilliseconds||e)}))}static wait(e){const t=e.map(r=>r instanceof i?r._promise:r);return i._wrap(Promise.all(t))}then(e,{onError:t}={}){const r=this._promise.then(s=>e(s),s=>{if(t)return t(s);throw s});return i._wrap(r)}catchError(e,{test:t}={}){const r=this._promise.catch(s=>{if(t&&!t(s))throw s;return e(s)});return i._wrap(r)}whenComplete(e){const t=this._promise.finally(()=>e());return i._wrap(t)}thenJS(e,t){return this._promise.then(e,t)}}class l{constructor(){this.future=new i(()=>{}),this.future._promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}complete(e){this._resolve(e)}completeError(e){this._reject(e)}get isCompleted(){return!1}}class a{constructor(){}}class m{constructor(){this.stream=new a}}export{l as Completer,i as Future,a as Stream,m as StreamController,c as Timer};
//# sourceMappingURL=index.js.map
