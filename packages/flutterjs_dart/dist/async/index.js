class o{constructor(e,t){this._timer=setTimeout(t,e.inMilliseconds||e)}static periodic(e,t){const r=new o(0,()=>{});return clearTimeout(r._timer),r._timer=setInterval(()=>t(r),e.inMilliseconds||e),r}static run(e){setTimeout(e,0)}cancel(){clearTimeout(this._timer),clearInterval(this._timer)}}class i{constructor(e){this._promise=new Promise((t,r)=>{try{const n=e();t(n)}catch(n){r(n)}})}static _wrap(e){const t=new i(()=>{});return t._promise=e,t}static value(e){return i._wrap(Promise.resolve(e))}static error(e){return i._wrap(Promise.reject(e))}static delayed(e,t){return i._wrap(new Promise((r,n)=>{setTimeout(()=>{try{r(t?t():null)}catch(c){n(c)}},e.inMilliseconds||e)}))}static wait(e){const t=e.map(r=>r instanceof i?r._promise:r);return i._wrap(Promise.all(t))}then(e,{onError:t}={}){const r=this._promise.then(n=>e(n),n=>{if(t)return t(n);throw n});return i._wrap(r)}catchError(e,{test:t}={}){const r=this._promise.catch(n=>{if(t&&!t(n))throw n;return e(n)});return i._wrap(r)}whenComplete(e){const t=this._promise.finally(()=>e());return i._wrap(t)}thenJS(e,t){return this._promise.then(e,t)}}class p{constructor(){this.future=new i(()=>{}),this.future._promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}complete(e){this._resolve(e)}completeError(e){this._reject(e)}get isCompleted(){return!1}}export*from"./stream.js";class a{static get current(){return l}fork({specification:e,zoneValues:t}={}){return this}run(e){return e()}bindCallback(e){return e}bindUnaryCallback(e){return e}bindBinaryCallback(e){return e}}const l=new a;function m(s,{zoneValues:e,zoneSpecification:t,onError:r}={}){return s()}function u(s,e,{zoneValues:t,zoneSpecification:r}={}){try{return s()}catch(n){e(n,null)}}export*from"./stream_view.js";export{p as Completer,i as Future,o as Timer,a as Zone,m as runZoned,u as runZonedGuarded};
//# sourceMappingURL=index.js.map
