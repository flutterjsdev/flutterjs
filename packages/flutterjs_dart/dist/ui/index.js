class i{constructor(t,r){this.dx=t,this.dy=r}get distance(){return Math.sqrt(this.dx*this.dx+this.dy*this.dy)}static get zero(){return new i(0,0)}static get infinite(){return new i(1/0,1/0)}translate(t,r){return new i(this.dx+t,this.dy+r)}scale(t,r){return new i(this.dx*t,this.dy*r)}}class n{constructor(t,r){this.width=t,this.height=r}static get zero(){return new n(0,0)}static get infinite(){return new n(1/0,1/0)}}class s{constructor(t,r,e,h){this.left=t,this.top=r,this.right=e,this.bottom=h}get width(){return this.right-this.left}get height(){return this.bottom-this.top}static fromLTWH(t,r,e,h){return new s(t,r,t+e,r+h)}static fromCircle(t,r){return new s(t.dx-r,t.dy-r,t.dx+r,t.dy+r)}}class a{constructor(t){this.value=t}get alpha(){return this.value>>24&255}get opacity(){return this.alpha/255}get red(){return this.value>>16&255}get green(){return this.value>>8&255}get blue(){return this.value&255}withOpacity(t){t=Math.max(0,Math.min(1,t));const r=Math.round(t*255);return new a(this.value&16777215|r<<24)}}class u{constructor(t){this.x=t,this.y=t}static circular(t){return new u(t)}}class c{constructor(){this._rect=new s(0,0,0,0)}static fromRectAndRadius(t,r){const e=new c;return e._rect=t,e}}var o={Offset:i,Size:n,Rect:s,Color:a,Radius:u,RRect:c};export{a as Color,i as Offset,c as RRect,u as Radius,s as Rect,n as Size,o as default};
//# sourceMappingURL=index.js.map
