// Copyright 2025 The FlutterJS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ============================================================================
// VNODE DIFFER - Compares old and new VNode trees and generates patches
// Layer: RECONCILIATION
// Implements efficient diffing like React's reconciliation algorithm
// ============================================================================

import { VNode } from './vnode.js';
import { VNodeRenderer } from "./vnode_renderer.js";

/**
 * Patch types generated by differ
 */
const PatchType = {
  CREATE: 'CREATE',          // New node added
  REMOVE: 'REMOVE',          // Node removed
  REPLACE: 'REPLACE',        // Node type changed
  UPDATE_PROPS: 'UPDATE_PROPS',  // Props changed
  UPDATE_STYLE: 'UPDATE_STYLE',  // Style changed
  UPDATE_TEXT: 'UPDATE_TEXT',    // Text content changed
  UPDATE_EVENTS: 'UPDATE_EVENTS', // Event handlers changed
  REORDER: 'REORDER'         // Children reordered
};

class Patch {
  constructor(type, index, node, value = null) {
    this.type = type;
    this.index = index;        // Position in parent's children
    this.node = node;          // VNode or old VNode
    this.value = value;        // New value (props, events, etc.)

    // For CREATE patches, node IS the new node
    if (type === 'CREATE') {
      this.newNode = node;
    }
    // For REPLACE patches, value IS the new node
    if (type === 'REPLACE' && value) {
      this.newNode = value;
    }
  }
}

class VNodeDiffer {
  /**
   * Diff two VNode trees and generate patches
   * Returns array of Patch objects that can be applied to DOM
   */
  static diff(oldVNode, newVNode, index = null) {
    const patches = [];

    // Helper to log patches (remove in production)
    const logPatches = (p, source) => {
      // Disabled - too verbose
    };

    // Handle null/undefined cases
    if (!oldVNode && !newVNode) {
      return patches;
    }

    // New node added
    if (!oldVNode && newVNode) {
      patches.push(new Patch(PatchType.CREATE, index, newVNode));
      return patches;
    }

    // Node removed
    if (oldVNode && !newVNode) {
      patches.push(new Patch(PatchType.REMOVE, index, oldVNode));
      return patches;
    }

    // Handle text nodes
    if (typeof oldVNode === 'string' || typeof oldVNode === 'number') {
      if (oldVNode !== newVNode) {
        // Text changed
        patches.push(
          new Patch(PatchType.UPDATE_TEXT, index, oldVNode, newVNode)
        );
      }
      return patches;
    }

    // Both are VNodes - check if same type
    if (oldVNode instanceof VNode && newVNode instanceof VNode) {
      if (oldVNode.tag !== newVNode.tag) {
        // Completely different elements
        patches.push(new Patch(PatchType.REPLACE, index, oldVNode, newVNode));
        logPatches(patches, 'diffVNode');
        return patches;
      }

      // Same element type - check children and props
      const propPatches = this.diffProps(oldVNode, newVNode, index);
      patches.push(...propPatches);

      const eventPatches = this.diffEvents(oldVNode, newVNode, index);
      patches.push(...eventPatches);

      const stylePatches = this.diffStyle(oldVNode, newVNode, index);
      patches.push(...stylePatches);

      // console.log(`[VNodeDiffer] Diffing children for ${oldVNode.tag}. Count: ${oldVNode.children?.length} vs ${newVNode.children?.length}`);
      const childPatches = this.diffChildren(
        oldVNode.children,
        newVNode.children,
        index
      );
      patches.push(...childPatches);

      return patches;
    }

    // Check for mixed types (e.g. string vs VNode)
    if ((typeof oldVNode === 'string' && newVNode instanceof VNode) ||
      (oldVNode instanceof VNode && typeof newVNode === 'string')) {
      patches.push(new Patch(PatchType.REPLACE, index, oldVNode, newVNode));
      return patches;
    }

    // Fallback: replace if completely different
    patches.push(new Patch(PatchType.REPLACE, index, oldVNode, newVNode));
    logPatches(patches, 'fallback');
    return patches;
  }

  /**
   * Diff props between old and new VNode
   */
  static diffProps(oldVNode, newVNode, index) {
    const patches = [];
    const oldProps = oldVNode.props || {};
    const newProps = newVNode.props || {};

    const changes = this.calculateDiff(oldProps, newProps);

    // Only generate patch if there are actual changes
    if (changes) {
      patches.push(
        new Patch(PatchType.UPDATE_PROPS, index, oldVNode, { changes })
      );
    }

    return patches;
  }

  /**
   * Diff events between old and new VNode
   */
  static diffEvents(oldVNode, newVNode, index) {
    const patches = [];
    const oldEvents = oldVNode.events || {};
    const newEvents = newVNode.events || {};

    const changes = this.calculateDiff(oldEvents, newEvents);

    if (changes) {
      patches.push(
        new Patch(PatchType.UPDATE_EVENTS, index, oldVNode, { changes })
      );
    }

    return patches;
  }

  /**
   * Diff styles between old and new VNode
   */
  static diffStyle(oldVNode, newVNode, index) {
    const patches = [];
    const oldStyle = oldVNode.style || {};
    const newStyle = newVNode.style || {};

    const changes = this.calculateDiff(oldStyle, newStyle);

    if (changes) {
      patches.push(
        new Patch(PatchType.UPDATE_STYLE, index, oldVNode, { changes })
      );
    }

    return patches;
  }

  /**
   * Calculate detailed difference between two objects
   * Returns { added, removed, updated } or null if no changes
   */
  static calculateDiff(oldObj, newObj) {
    const added = {};
    const removed = {};
    const updated = {};
    let hasAdded = false;
    let hasRemoved = false;
    let hasUpdated = false;

    const allKeys = new Set([
      ...Object.keys(oldObj),
      ...Object.keys(newObj)
    ]);

    for (const key of allKeys) {
      const oldVal = oldObj[key];
      const newVal = newObj[key];

      if (oldVal === undefined && newVal !== undefined) {
        added[key] = newVal;
        hasAdded = true;
      } else if (oldVal !== undefined && newVal === undefined) {
        removed[key] = oldVal;
        hasRemoved = true;
      } else if (oldVal !== newVal) {
        updated[key] = newVal;
        hasUpdated = true;
      }
    }

    if (!hasAdded && !hasRemoved && !hasUpdated) {
      return null;
    }

    const result = {};
    if (hasAdded) result.added = added;
    if (hasRemoved) result.removed = removed;
    if (hasUpdated) result.updated = updated;

    return result;
  }

  /**
   * Diff children using key-based or position-based reconciliation
   */
  static diffChildren(oldChildren = [], newChildren = [], parentIndex) {
    const patches = [];

    // Use keys for reconciliation if available
    const oldKeyed = this.groupByKey(oldChildren);
    const newKeyed = this.groupByKey(newChildren);

    const maxLen = Math.max(oldChildren.length, newChildren.length);

    for (let i = 0; i < maxLen; i++) {
      const oldChild = oldChildren[i];
      const newChild = newChildren[i];
      const childIndex = parentIndex !== null && parentIndex !== undefined ? `${parentIndex}.${i}` : `${i}`;

      if (!oldChild && newChild) {
        // New child added
        patches.push(new Patch(PatchType.CREATE, childIndex, newChild));
      } else if (oldChild && !newChild) {
        // Child removed
        patches.push(new Patch(PatchType.REMOVE, childIndex, oldChild));
      } else if (oldChild && newChild) {
        // Recursively diff
        const childPatches = this.diff(oldChild, newChild, childIndex);
        patches.push(...childPatches);
      }
    }

    return patches;
  }

  /**
   * Group VNodes by key for efficient reconciliation
   */
  static groupByKey(vnodes = []) {
    const keyed = new Map();
    const unkeyed = [];

    vnodes.forEach(vnode => {
      if (vnode instanceof VNode && vnode.key) {
        keyed.set(vnode.key, vnode);
      } else {
        unkeyed.push(vnode);
      }
    });

    return { keyed, unkeyed };
  }

  /**
   * Apply patches to DOM
   * Called after diff to update actual DOM
   */
  static applyPatches(domElement, patches, vNodeMap = new Map()) {
    patches.forEach(patch => {
      const targetElement = this.findElement(domElement, patch.index);

      if (!targetElement) {
        console.warn(`Could not find element at index ${patch.index}`);
        return;
      }

      switch (patch.type) {
        case PatchType.CREATE:
          this.applyCreate(targetElement, patch);
          break;

        case PatchType.REMOVE:
          this.applyRemove(targetElement, patch);
          break;

        case PatchType.REPLACE:
          this.applyReplace(targetElement, patch);
          break;

        case PatchType.UPDATE_PROPS:
          this.applyUpdateProps(targetElement, patch);
          break;

        case PatchType.UPDATE_TEXT:
          this.applyUpdateText(targetElement, patch);
          break;

        case PatchType.UPDATE_STYLE:
          // VNodeRenderer has updateStyle which takes (element, oldStyle, newStyle)
          // But here we might not have a helper? 
          // Previous files showed VNodeRenderer.updateProps handles style? 
          // Check VNodeRenderer.js... using explicit updateStyle if available or manual.
          // VNodeRenderer.updateStyle is assumed to exist given diffStyle exists.
          if (VNodeRenderer.updateStyle) {
            VNodeRenderer.updateStyle(targetElement, patch.value.old, patch.value.new);
          } else {
            // Fallback if VNodeRenderer.updateStyle is missing (it was updateStyles in some versions?)
            // Assume VNodeRenderer handles it or implement basic style patch
            const { added, removed, updated } = patch.value.changes || {};
            if (added) Object.assign(targetElement.style, added);
            if (updated) Object.assign(targetElement.style, updated);
            if (removed) Object.keys(removed).forEach(k => targetElement.style[k] = '');
          }
          break;

        case PatchType.UPDATE_EVENTS:
          this.applyUpdateEvents(targetElement, patch);
          break;

        case PatchType.REORDER:
          this.applyReorder(targetElement, patch);
          break;
      }
    });
  }

  /**
   * Find DOM element by index path
   * Index format: "0.1.2" means: root's 0th child's 1st child's 2nd child
   */
  static findElement(root, index) {
    if (index === 0 || index === '0') {
      return root;
    }

    const path = String(index).split('.');
    let current = root;

    for (const step of path) {
      const childIndex = parseInt(step);
      current = current.childNodes[childIndex];

      if (!current) {
        return null;
      }
    }

    return current;
  }

  /**
   * Apply CREATE patch
   */
  static applyCreate(parent, patch) {


    const newDom = VNodeRenderer.createDOMNode(patch.node);

    if (parent.childNodes.length === 0) {
      parent.appendChild(newDom);
    } else {
      const childIndex = parseInt(String(patch.index).split('.').pop());
      if (childIndex < parent.childNodes.length) {
        parent.insertBefore(newDom, parent.childNodes[childIndex]);
      } else {
        parent.appendChild(newDom);
      }
    }
  }

  /**
   * Apply REMOVE patch
   */
  static applyRemove(parent, patch) {
    const childIndex = parseInt(String(patch.index).split('.').pop());
    if (parent.childNodes[childIndex]) {
      parent.removeChild(parent.childNodes[childIndex]);
    }
  }

  /**
   * Apply REPLACE patch
   */
  static applyReplace(parent, patch) {

    const childIndex = parseInt(String(patch.index).split('.').pop());
    const oldChild = parent.childNodes[childIndex];

    if (oldChild) {
      const newDom = VNodeRenderer.createDOMNode(patch.value);
      parent.replaceChild(newDom, oldChild);
    }
  }

  /**
   * Apply UPDATE_PROPS patch
   */
  static applyUpdateProps(element, patch) {

    VNodeRenderer.updateProps(element, patch.value.old, patch.value.new);
  }

  /**
   * Apply UPDATE_TEXT patch
   */
  static applyUpdateText(element, patch) {
    element.textContent = String(patch.value);
  }

  /**
   * Apply UPDATE_EVENTS patch
   */
  static applyUpdateEvents(element, patch) {

    VNodeRenderer.updateEvents(element, patch.value.old, patch.value.new);
  }

  /**
   * Apply REORDER patch
   */
  static applyReorder(parent, patch) {
    // Reorder children according to new indices
    const newOrder = patch.value;
    const fragment = document.createDocumentFragment();

    newOrder.forEach(index => {
      fragment.appendChild(parent.childNodes[index]);
    });

    parent.appendChild(fragment);
  }

  /**
   * Get statistics about patches (for debugging)
   */
  static getStats(patches) {
    const stats = {
      total: patches.length,
      creates: 0,
      removes: 0,
      replaces: 0,
      updates: 0
    };

    patches.forEach(patch => {
      if (patch.type === PatchType.CREATE) stats.creates++;
      else if (patch.type === PatchType.REMOVE) stats.removes++;
      else if (patch.type === PatchType.REPLACE) stats.replaces++;
      else stats.updates++;
    });

    return stats;
  }
}


export { VNodeDiffer, Patch, PatchType };