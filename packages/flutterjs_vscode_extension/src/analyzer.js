class FJSAnalyzer {
  constructor() {
    this.dartMethods = [
      'increment', 'fetchQuote', 'reset', 'notifyListeners',
      'watch', 'read', 'select',
      'get', 'post', 'put', 'delete',
      'jsonDecode', 'jsonEncode',
      'min', 'max', 'sqrt', 'pow',
    ];

    this.jsBuiltins = [
      'toString', 'valueOf', 'charAt', 'charCodeAt', 'concat', 'indexOf',
      'lastIndexOf', 'slice', 'substring', 'substr', 'toLowerCase', 'toUpperCase',
      'trim', 'split', 'replace', 'match', 'search', 'startsWith', 'endsWith',
      'includes', 'repeat', 'padStart', 'padEnd', 'push', 'pop', 'shift',
      'unshift', 'splice', 'slice', 'concat', 'join', 'reverse', 'sort',
      'map', 'filter', 'reduce', 'forEach', 'find', 'findIndex', 'some',
      'every', 'indexOf', 'lastIndexOf', 'includes', 'flat', 'flatMap',
      'then', 'catch', 'finally', 'parse', 'stringify', 'keys', 'values',
      'entries', 'assign', 'create',
    ];
  }

  analyze(content, filePath) {
    const issues = [];
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Skip generated file header
      if (i < 5 && line.includes('Generated by FlutterJS')) {
        continue;
      }

      issues.push(...this.checkInvalidSyntax(line, i));
      issues.push(...this.checkImports(line, i));
      issues.push(...this.checkUndefinedMethods(line, i));
      issues.push(...this.checkTypeErrors(line, i));
    }

    return issues;
  }

  checkInvalidSyntax(line, lineIndex) {
    const issues = [];

    // Only flag Dart-ONLY syntax (not valid in JavaScript)
    const dartOnlyPatterns = [
      { pattern: /\bfinal\s+\w+\s*=/g, message: 'Dart syntax `final` not converted - use `const` or `let`' },
      { pattern: /\blate\s+\w+/g, message: 'Dart syntax `late` not converted' },
      { pattern: /\brequired\s+/g, message: 'Dart syntax `required` not converted' },
    ];

    for (const { pattern, message } of dartOnlyPatterns) {
      let match;
      while ((match = pattern.exec(line)) !== null) {
        if (this.isInComment(line, match.index)) {
          continue;
        }

        issues.push({
          line: lineIndex,
          column: match.index,
          length: match[0].length,
          message,
          code: 'DART-SYNTAX-NOT-CONVERTED',
          severity: 'error',
        });
      }
    }

    return issues;
  }

  checkImports(line, lineIndex) {
    const issues = [];

    if (!line.trim().startsWith('import')) {
      return issues;
    }

    // Valid transpiled imports
    if (line.includes('@flutterjs/') || line.includes('./')) {
      return issues;
    }

    // Node.js built-ins are OK
    if (line.includes("'http'") || line.includes("'fs'") || line.includes("'path'")) {
      return issues;
    }

    // Warn about raw Dart imports
    if (line.includes('package:') || line.includes('dart:')) {
      const col = line.indexOf('package:') !== -1 ? line.indexOf('package:') : line.indexOf('dart:');
      issues.push({
        line: lineIndex,
        column: col,
        length: 20,
        message: 'Dart imports should be transpiled to FJS (@flutterjs/* or relative paths)',
        code: 'UNTRANSPILED-IMPORT',
        severity: 'warning',
      });
    }

    return issues;
  }

  checkUndefinedMethods(line, lineIndex) {
    const issues = [];

    if (this.isCommentOrString(line)) {
      return issues;
    }

    const methodCall = /\.(\w+)\s*\(/g;
    let match;

    while ((match = methodCall.exec(line)) !== null) {
      const methodName = match[1];

      if (this.dartMethods.includes(methodName) || this.jsBuiltins.includes(methodName)) {
        continue;
      }

      // Warn only for suspicious method names
      if (methodName.length > 30 || methodName.includes('_')) {
        issues.push({
          line: lineIndex,
          column: match.index,
          length: methodName.length,
          message: `Unknown method: "${methodName}"`,
          code: 'UNKNOWN-METHOD',
          severity: 'warning',
        });
      }
    }

    return issues;
  }

  checkTypeErrors(line, lineIndex) {
    const issues = [];

    if (this.isCommentOrString(line)) {
      return issues;
    }

    const typeArgPattern = /<(\w+)>/g;
    let match;

    while ((match = typeArgPattern.exec(line)) !== null) {
      const beforeType = line.substring(Math.max(0, match.index - 20), match.index).trim();

      // OK after method names
      if (/\.\w+\s*$/.test(beforeType)) {
        continue;
      }

      // OK in declarations
      if (/:\s*$/.test(beforeType) || /\bconst\s+$/.test(beforeType)) {
        continue;
      }

      issues.push({
        line: lineIndex,
        column: match.index,
        length: match[0].length,
        message: 'Type argument in unexpected location',
        code: 'TYPE-ARG-MISPLACED',
        severity: 'warning',
      });
    }

    return issues;
  }

  isCommentOrString(line) {
    const trimmed = line.trim();
    return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');
  }

  isInComment(line, position) {
    return line.substring(0, position).includes('//');
  }
}

module.exports = { FJSAnalyzer };