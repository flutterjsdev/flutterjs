// Copyright 2025 The FlutterJS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:meta/meta.dart';

import '../core/source_location.dart';
import '../expressions/expression_ir.dart';
import '../core/ir_node.dart';
import 'key_type_ir.dart';

/// <---------------------------------------------------------------------------->
/// widget_node_ir.dart
/// ----------------------------------------------------------------------------
///
/// Core IR structure representing a single widget node in the widget tree.
///
/// Responsibilities:
/// • Capture widget constructor type and arguments
/// • Hold references to child widget nodes
/// • Store metadata (keys, attributes, source locations)
///
/// WidgetNodeIR is used in:
/// • Build method IR output
/// • Widget tree diffing / reconciliation
/// • Visual widget tree inspectors
/// • Code transformation (e.g., automated refactoring)
///
/// Design Principles:
/// • Immutable, clean IR
/// • JSON serializable
/// • Independent of Flutter runtime (pure data)
/// • Supports complex nested widget structures
///
/// This file forms the **foundation of the entire widget IR system**.

@immutable
class WidgetNodeIR extends IRNode {
  /// Widget type/class name (e.g., "Container", "Text", "CustomWidget")
  final String widgetType;

  /// Constructor name if named constructor (e.g., "fromJson" in Icon.fromJson)
  final String? constructorName;

  /// Properties passed to widget as key-value expression pairs
  ///
  /// Maps property names to their value expressions
  /// Examples:
  /// - "padding": PaddingExpression(EdgeInsets.all(8))
  /// - "child": WidgetExpression(Container(...))
  /// - "color": ColorExpression(Colors.blue)
  final Map<String, ExpressionIR> properties;

  /// Child widgets (for containers with children)
  ///
  /// Empty list if this widget has no children
  /// Single-child widgets have exactly one child
  /// Multi-child widgets (Row, Column, Stack) have multiple
  final List<WidgetNodeIR> children;

  /// Optional key for this widget
  ///
  /// If present, helps Flutter identify this widget across rebuilds
  /// Null means no key (widget identity based on position only)
  final KeyTypeIR? key;

  /// Whether this widget is declared with `const` keyword
  ///
  /// Const widgets are:
  /// - Not recreated on every build
  /// - Shared across widget instances
  /// - Better for performance (less memory allocation)
  final bool isConst;

  /// Depth in tree (root = 0)
  ///
  /// Used for performance analysis and layout debugging
  /// Excessive depth (>20) suggests need for optimization
  final int treeDepth;

  /// Whether this widget is conditional (only renders sometimes)
  ///
  /// Set to true if widget is inside if/else or ternary
  final bool isConditional;

  /// Whether this widget is inside a loop or generated dynamically
  ///
  /// Set to true if widget is generated by map(), for loop, etc.
  final bool isInLoop;

  /// Analysis data about this widget
  final WidgetNodeAnalysisIR? analysis;

  WidgetNodeIR({
    required String id,
    required SourceLocationIR sourceLocation,
    required this.widgetType,
    this.constructorName,
    this.properties = const {},
    this.children = const [],
    this.key,
    this.isConst = false,
    this.treeDepth = 0,
    this.isConditional = false,
    this.isInLoop = false,
    this.analysis,
  }) : super(id: id, sourceLocation: sourceLocation);

  /// Number of widgets in this subtree (including self)
  int get subtreeSize {
    return 1 + children.fold(0, (sum, child) => sum + child.subtreeSize);
  }

  /// Maximum depth of this subtree from this node
  int get subtreeDepth {
    if (children.isEmpty) return 1;
    return 1 +
        children.map((c) => c.subtreeDepth).reduce((a, b) => a > b ? a : b);
  }

  /// Whether this widget has any children
  bool get hasChildren => children.isNotEmpty;

  /// Whether this widget has a key for tracking across rebuilds
  bool get hasKey => key != null;

  /// Estimated performance impact of this widget
  ///
  /// Based on const status, complexity, and children count
  double get estimatedRebuildCost {
    double cost = 1.0;

    // Const widgets are free to rebuild
    if (isConst) return 0.0;

    // Cost increases with number of children
    cost += children.length * 0.5;

    // Cost increases with property complexity
    for (final prop in properties.values) {
      if (prop is MethodCallExpressionIR) {
        cost += 1.0; // Method calls are expensive
      }
    }

    return cost;
  }

  /// Whether this widget needs optimization
  bool get needsOptimization {
    // Widget too deep in tree
    if (treeDepth > 20) return true;

    // Non-const widget with no dependencies
    if (!isConst && children.isEmpty && properties.isEmpty) return true;

    // Widget in loop without key
    if (isInLoop && !hasKey) return true;

    return false;
  }

  /// Get all widget types in this subtree
  Set<String> getDescendantWidgetTypes() {
    final types = <String>{widgetType};
    for (final child in children) {
      types.addAll(child.getDescendantWidgetTypes());
    }
    return types;
  }

  /// Find all non-const widgets in this subtree
  List<WidgetNodeIR> getNonConstDescendants() {
    final nonConst = <WidgetNodeIR>[];
    if (!isConst) nonConst.add(this);
    for (final child in children) {
      nonConst.addAll(child.getNonConstDescendants());
    }
    return nonConst;
  }

  /// Find all widgets without keys in loops
  List<WidgetNodeIR> getUnkeyedLoopDescendants() {
    final unkeyed = <WidgetNodeIR>[];
    if (isInLoop && !hasKey) unkeyed.add(this);
    for (final child in children) {
      unkeyed.addAll(child.getUnkeyedLoopDescendants());
    }
    return unkeyed;
  }

  @override
  String toShortString() =>
      '${isConst ? 'const ' : ''}$widgetType${constructorName != null ? '.${constructorName!}' : ''}${children.isNotEmpty ? ' [${children.length} children]' : ''}';

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'widgetType': widgetType,
      'constructorName': constructorName,
      'properties': properties.map(
        (key, value) => MapEntry(key, value.toJson()),
      ),
      'children': children.map((c) => c.toJson()).toList(),
      'key': key?.toJson(),
      'isConst': isConst,
      'treeDepth': treeDepth,
      'isConditional': isConditional,
      'isInLoop': isInLoop,
      'analysis': analysis?.toJson(),
      'sourceLocation': sourceLocation.toJson(),
    };
  }
}

/// Analysis metadata for a widget node
@immutable
class WidgetNodeAnalysisIR extends IRNode {
  /// Whether this widget triggers parent rebuild
  final bool triggersParentRebuild;

  /// State fields this widget depends on
  final List<String> stateFieldDependencies;

  /// Provider types this widget reads from
  final List<String> providerDependencies;

  /// Estimated render time in microseconds
  final int estimatedRenderTimeUs;

  /// Known performance issues with this widget
  final List<String> performanceIssues;

  WidgetNodeAnalysisIR({
    required String id,
    required SourceLocationIR sourceLocation,
    this.triggersParentRebuild = false,
    this.stateFieldDependencies = const [],
    this.providerDependencies = const [],
    this.estimatedRenderTimeUs = 0,
    this.performanceIssues = const [],
  }) : super(id: id, sourceLocation: sourceLocation);

  @override
  String toShortString() =>
      'Analysis [triggers: $triggersParentRebuild, deps: ${stateFieldDependencies.length}, issues: ${performanceIssues.length}]';

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'triggersParentRebuild': triggersParentRebuild,
      'stateFieldDependencies': stateFieldDependencies,
      'providerDependencies': providerDependencies,
      'estimatedRenderTimeUs': estimatedRenderTimeUs,
      'performanceIssues': performanceIssues,
      'sourceLocation': sourceLocation.toJson(),
    };
  }

  factory WidgetNodeAnalysisIR.fromJson(
    Map<String, dynamic> json,
    SourceLocationIR sourceLocation,
  ) {
    return WidgetNodeAnalysisIR(
      id: json['id'] as String,
      sourceLocation: sourceLocation,
      triggersParentRebuild: json['triggersParentRebuild'] as bool? ?? false,
      stateFieldDependencies: List<String>.from(
        json['stateFieldDependencies'] as List<dynamic>? ?? [],
      ),
      providerDependencies: List<String>.from(
        json['providerDependencies'] as List<dynamic>? ?? [],
      ),
      estimatedRenderTimeUs: json['estimatedRenderTimeUs'] as int? ?? 0,
      performanceIssues: List<String>.from(
        json['performanceIssues'] as List<dynamic>? ?? [],
      ),
    );
  }
}
