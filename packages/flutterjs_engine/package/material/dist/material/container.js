import{Widget as E,StatelessWidget as m}from"../core/widget_element.js";import{Element as k}from"@flutterjs/runtime";import{VNode as C}from"@flutterjs/vdom/vnode";import{Clip as f}from"../utils/utils.js";import{Padding as p}from"../widgets/widgets.js";import{EdgeInsets as P}from"../utils/edge_insets.js";import{BoxConstraints as b}from"../utils/box_constraints.js";import{Align as j}from"../widgets/compoment/center.js";import{ClipPath as I}from"../widgets/compoment/clip.js";import{ConstrainedBox as w,LimitedBox as O}from"../widgets/compoment/sized_box.js";import{Transform as A}from"../widgets/compoment/transform.js";const a={background:"background",foreground:"foreground"};class c{constructor(){if(new.target===c)throw new Error("Decoration is abstract");this.padding=new P(0,0,0,0)}toCSSStyle(){throw new Error("toCSSStyle() must be implemented")}debugAssertIsValid(){return!0}}class x extends c{constructor({color:i=null,image:t=null,border:e=null,borderRadius:n=null,boxShadow:o=[],gradient:s=null,backgroundBlendMode:r=null,shape:d="rectangle"}={}){super(),this.color=i,this.image=t,this.border=e,this.borderRadius=n,this.boxShadow=o,this.gradient=s,this.backgroundBlendMode=r,this.shape=d}toCSSStyle(){const i={};if(this.color&&(i.backgroundColor=this.color),this.borderRadius)if(typeof this.borderRadius=="number")i.borderRadius=`${this.borderRadius}px`;else if(this.borderRadius.all!==void 0)i.borderRadius=`${this.borderRadius.all}px`;else{const{topLeft:t=0,topRight:e=0,bottomLeft:n=0,bottomRight:o=0}=this.borderRadius;i.borderRadius=`${t}px ${e}px ${o}px ${n}px`}if(this.border&&typeof this.border=="object"){const{width:t=1,color:e="black",style:n="solid"}=this.border;i.border=`${t}px ${n} ${e}`}if(this.boxShadow&&this.boxShadow.length>0&&(i.boxShadow=this.boxShadow.map(t=>{const{offsetX:e=0,offsetY:n=0,blurRadius:o=0,spreadRadius:s=0,color:r="rgba(0,0,0,0.5)"}=t;return`${e}px ${n}px ${o}px ${s}px ${r}`}).join(", ")),this.gradient){const{type:t="linear",colors:e=[],stops:n=[]}=this.gradient;if(t==="linear"){const o=e.map((s,r)=>`${s} ${(n[r]||r/e.length)*100}%`).join(", ");i.background=`linear-gradient(135deg, ${o})`}}return this.backgroundBlendMode&&(i.mixBlendMode=this.backgroundBlendMode),i}}class R extends m{constructor({key:i=null,color:t="white",child:e=null}={}){super(i),this.color=t,this.child=e}build(i){return new h({decoration:new x({color:this.color}),child:this.child})}}class S{constructor({decoration:i=null,position:t=a.background,configuration:e={}}={}){this.decoration=i,this.position=t,this.configuration=e}debugInfo(){return{type:"RenderDecoratedBox",position:this.position,hasDecoration:!!this.decoration}}}class h extends E{constructor({key:i=null,decoration:t=null,position:e=a.background,child:n=null}={}){if(super(i),!t)throw new Error("DecoratedBox requires a decoration");this.decoration=t,this.position=e,this.child=n,this._renderObject=null}createRenderObject(i){return new S({decoration:this.decoration,position:this.position,configuration:{}})}updateRenderObject(i,t){t.decoration=this.decoration,t.position=this.position}build(i){this._renderObject?this.updateRenderObject(i,this._renderObject):this._renderObject=this.createRenderObject(i);const t=i.element.getElementId(),e=i.element.getWidgetPath();let n=null;if(this.child){const r=this.child.createElement(i.element,i.element.runtime);r.mount(i.element),n=r.performRebuild()}const s={position:"relative",...this.decoration.toCSSStyle()};return new C({tag:"div",props:{style:s,"data-element-id":t,"data-widget-path":e,"data-widget":"DecoratedBox","data-position":this.position},children:n?[n]:[],key:this.key})}debugFillProperties(i){super.debugFillProperties(i);const t=this.position===a.background?"bg":"fg";i.push({name:t,value:this.decoration})}createElement(i,t){return new v(this,i,t)}}class v extends k{performRebuild(){return this.widget.build(this.context)}}class N extends m{constructor({key:i=null,alignment:t=null,padding:e=null,color:n=null,decoration:o=null,foregroundDecoration:s=null,width:r=null,height:d=null,constraints:g=null,margin:u=null,transform:B=null,transformAlignment:D=null,child:$=null,clipBehavior:y=f.none}={}){if(super(i),e!==null&&!e.isNonNegative)throw new Error("padding must be non-negative");if(u!==null&&!u.isNonNegative)throw new Error("margin must be non-negative");if(n!==null&&o!==null)throw new Error("Cannot provide both color and decoration. Use BoxDecoration(color: color).");if(o!==null&&!o.debugAssertIsValid())throw new Error("decoration is not valid");this.alignment=t,this.padding=e,this.color=n,this.decoration=o,this.foregroundDecoration=s,this.margin=u,this.transform=B,this.transformAlignment=D,this.child=$,this.clipBehavior=y,r!==null||d!==null?this.constraints=g?.tighten({width:r,height:d})||b.tightFor({width:r,height:d}):this.constraints=g}_getPaddingIncludingDecoration(){return this.padding===null?this.decoration?.padding:this.decoration?.padding===null||this.decoration?.padding===void 0?this.padding:this.padding.add(this.decoration.padding)}build(i){let t=this.child;this.child===null&&(this.constraints===null||!this.constraints.isTight)?t=new O({maxWidth:0,maxHeight:0,child:new w({constraints:b.expand()})}):this.alignment!==null&&(t=new j({alignment:this.alignment,child:t}));const e=this._getPaddingIncludingDecoration();return e!==null&&(t=new p({padding:e,child:t})),this.color!==null&&(t=new R({color:this.color,child:t})),this.clipBehavior!==f.none&&this.decoration!==null&&(t=new I({clipBehavior:this.clipBehavior,child:t})),this.decoration!==null&&(t=new h({decoration:this.decoration,child:t})),this.foregroundDecoration!==null&&(t=new h({decoration:this.foregroundDecoration,position:a.foreground,child:t})),this.constraints!==null&&(t=new w({constraints:this.constraints,child:t})),this.margin!==null&&(t=new p({padding:this.margin,child:t})),this.transform!==null&&(t=new A({transform:this.transform,alignment:this.transformAlignment,child:t})),t}debugFillProperties(i){super.debugFillProperties(i),this.alignment!==null&&i.push({name:"alignment",value:this.alignment}),this.padding!==null&&i.push({name:"padding",value:this.padding}),this.color!==null?i.push({name:"bg",value:this.color}):this.decoration!==null&&i.push({name:"bg",value:this.decoration}),this.foregroundDecoration!==null&&i.push({name:"fg",value:this.foregroundDecoration}),this.constraints!==null&&i.push({name:"constraints",value:this.constraints}),this.margin!==null&&i.push({name:"margin",value:this.margin})}}export{x as BoxDecoration,R as ColoredBox,N as Container,h as DecoratedBox,v as DecoratedBoxElement,c as Decoration,a as DecorationPosition,S as RenderDecoratedBox};
//# sourceMappingURL=container.js.map
