import{Widget as C,StatelessWidget as d}from"../core/widget_element.js";import{Element as M}from"@flutterjs/runtime";import{VNode as a}from"@flutterjs/vdom/vnode";import{Clip as b,Alignment as P}from"../utils/utils.js";import{Padding as x}from"../widgets/widgets.js";const m={background:"background",foreground:"foreground"};class u{constructor(t=0,i=0,n=0,e=0){this.top=t,this.right=i,this.bottom=n,this.left=e}static symmetric({vertical:t=0,horizontal:i=0}={}){return new u(t,i,t,i)}static all(t=0){return new u(t,t,t,t)}static only({top:t=0,right:i=0,bottom:n=0,left:e=0}={}){return new u(t,i,n,e)}get isNonNegative(){return this.top>=0&&this.right>=0&&this.bottom>=0&&this.left>=0}get horizontal(){return this.left+this.right}get vertical(){return this.top+this.bottom}add(t){return new u(this.top+t.top,this.right+t.right,this.bottom+t.bottom,this.left+t.left)}toCSSString(){return this.top===this.right&&this.right===this.bottom&&this.bottom===this.left?`${this.top}px`:this.top===this.bottom&&this.left===this.right?`${this.top}px ${this.left}px`:`${this.top}px ${this.right}px ${this.bottom}px ${this.left}px`}toCSSMargin(){return`${this.top}px ${this.right}px ${this.bottom}px ${this.left}px`}toCSSPadding(){return`${this.top}px ${this.right}px ${this.bottom}px ${this.left}px`}}class h{constructor(t=0,i=1/0,n=0,e=1/0){this.minWidth=t,this.maxWidth=i,this.minHeight=n,this.maxHeight=e}static tight(t){return new h(t.width,t.width,t.height,t.height)}static loose(t){return new h(0,t.width,0,t.height)}static expand({width:t=1/0,height:i=1/0}={}){return new h(0,t,0,i)}static tightFor({width:t=null,height:i=null}={}){return new h(t!==null?t:0,t!==null?t:1/0,i!==null?i:0,i!==null?i:1/0)}get isTight(){return this.minWidth===this.maxWidth&&this.minHeight===this.maxHeight}debugAssertIsValid(){if(!(this.minWidth>=0&&this.maxWidth>=this.minWidth&&this.minHeight>=0&&this.maxHeight>=this.minHeight))throw new Error(`Invalid BoxConstraints: ${this.minWidth}..${this.maxWidth}, ${this.minHeight}..${this.maxHeight}`);return!0}tighten({width:t=null,height:i=null}={}){return new h(t!==null?Math.max(this.minWidth,t):this.minWidth,t!==null?Math.min(this.maxWidth,t):this.maxWidth,i!==null?Math.max(this.minHeight,i):this.minHeight,i!==null?Math.min(this.maxHeight,i):this.maxHeight)}constrain(t){return{width:Math.max(this.minWidth,Math.min(this.maxWidth,t.width)),height:Math.max(this.minHeight,Math.min(this.maxHeight,t.height))}}toString(){return`BoxConstraints(${this.minWidth}..${this.maxWidth}, ${this.minHeight}..${this.maxHeight})`}}class f{constructor(){if(new.target===f)throw new Error("Decoration is abstract");this.padding=new u(0,0,0,0)}toCSSStyle(){throw new Error("toCSSStyle() must be implemented")}debugAssertIsValid(){return!0}}class y extends f{constructor({color:t=null,image:i=null,border:n=null,borderRadius:e=null,boxShadow:s=[],gradient:l=null,backgroundBlendMode:r=null,shape:c="rectangle"}={}){super(),this.color=t,this.image=i,this.border=n,this.borderRadius=e,this.boxShadow=s,this.gradient=l,this.backgroundBlendMode=r,this.shape=c}toCSSStyle(){const t={};if(this.color&&(t.backgroundColor=this.color),this.borderRadius)if(typeof this.borderRadius=="number")t.borderRadius=`${this.borderRadius}px`;else if(this.borderRadius.all!==void 0)t.borderRadius=`${this.borderRadius.all}px`;else{const{topLeft:i=0,topRight:n=0,bottomLeft:e=0,bottomRight:s=0}=this.borderRadius;t.borderRadius=`${i}px ${n}px ${s}px ${e}px`}if(this.border&&typeof this.border=="object"){const{width:i=1,color:n="black",style:e="solid"}=this.border;t.border=`${i}px ${e} ${n}`}if(this.boxShadow&&this.boxShadow.length>0&&(t.boxShadow=this.boxShadow.map(i=>{const{offsetX:n=0,offsetY:e=0,blurRadius:s=0,spreadRadius:l=0,color:r="rgba(0,0,0,0.5)"}=i;return`${n}px ${e}px ${s}px ${l}px ${r}`}).join(", ")),this.gradient){const{type:i="linear",colors:n=[],stops:e=[]}=this.gradient;if(i==="linear"){const s=n.map((l,r)=>`${l} ${(e[r]||r/n.length)*100}%`).join(", ");t.background=`linear-gradient(135deg, ${s})`}}return this.backgroundBlendMode&&(t.mixBlendMode=this.backgroundBlendMode),t}}class S extends d{constructor({key:t=null,color:i="white",child:n=null}={}){super(t),this.color=i,this.child=n}build(t){return new g({decoration:new y({color:this.color}),child:this.child})}}class W{constructor({decoration:t=null,position:i=m.background,configuration:n={}}={}){this.decoration=t,this.position=i,this.configuration=n}debugInfo(){return{type:"RenderDecoratedBox",position:this.position,hasDecoration:!!this.decoration}}}class g extends C{constructor({key:t=null,decoration:i=null,position:n=m.background,child:e=null}={}){if(super(t),!i)throw new Error("DecoratedBox requires a decoration");this.decoration=i,this.position=n,this.child=e,this._renderObject=null}createRenderObject(t){return new W({decoration:this.decoration,position:this.position,configuration:{}})}updateRenderObject(t,i){i.decoration=this.decoration,i.position=this.position}build(t){this._renderObject?this.updateRenderObject(t,this._renderObject):this._renderObject=this.createRenderObject(t);const i=t.element.getElementId(),n=t.element.getWidgetPath();let e=null;if(this.child){const r=this.child.createElement(t.element,t.element.runtime);r.mount(t.element),e=r.performRebuild()}const l={position:"relative",...this.decoration.toCSSStyle()};return new a({tag:"div",props:{style:l,"data-element-id":i,"data-widget-path":n,"data-widget":"DecoratedBox","data-position":this.position},children:e?[e]:[],key:this.key})}debugFillProperties(t){super.debugFillProperties(t);const i=this.position===m.background?"bg":"fg";t.push({name:i,value:this.decoration})}createElement(t,i){return new v(this,t,i)}}class v extends M{performRebuild(){return this.widget.build(this.context)}}class j extends d{constructor({key:t=null,alignment:i=null,padding:n=null,color:e=null,decoration:s=null,foregroundDecoration:l=null,width:r=null,height:c=null,constraints:$=null,margin:p=null,transform:D=null,transformAlignment:I=null,child:B=null,clipBehavior:k=b.none}={}){if(super(t),n!==null&&!n.isNonNegative)throw new Error("padding must be non-negative");if(p!==null&&!p.isNonNegative)throw new Error("margin must be non-negative");if(e!==null&&s!==null)throw new Error("Cannot provide both color and decoration. Use BoxDecoration(color: color).");if(s!==null&&!s.debugAssertIsValid())throw new Error("decoration is not valid");this.alignment=i,this.padding=n,this.color=e,this.decoration=s,this.foregroundDecoration=l,this.margin=p,this.transform=D,this.transformAlignment=I,this.child=B,this.clipBehavior=k,r!==null||c!==null?this.constraints=$?.tighten({width:r,height:c})||h.tightFor({width:r,height:c}):this.constraints=$}_getPaddingIncludingDecoration(){return this.padding===null?this.decoration?.padding:this.decoration?.padding===null||this.decoration?.padding===void 0?this.padding:this.padding.add(this.decoration.padding)}build(t){let i=this.child;this.child===null&&(this.constraints===null||!this.constraints.isTight)?i=new R({maxWidth:0,maxHeight:0,child:new w({constraints:h.expand()})}):this.alignment!==null&&(i=new N({alignment:this.alignment,child:i}));const n=this._getPaddingIncludingDecoration();return n!==null&&(i=new x({padding:n,child:i})),this.color!==null&&(i=new S({color:this.color,child:i})),this.clipBehavior!==b.none&&this.decoration!==null&&(i=new H({clipBehavior:this.clipBehavior,child:i})),this.decoration!==null&&(i=new g({decoration:this.decoration,child:i})),this.foregroundDecoration!==null&&(i=new g({decoration:this.foregroundDecoration,position:m.foreground,child:i})),this.constraints!==null&&(i=new w({constraints:this.constraints,child:i})),this.margin!==null&&(i=new x({padding:this.margin,child:i})),this.transform!==null&&(i=new E({transform:this.transform,alignment:this.transformAlignment,child:i})),i}debugFillProperties(t){super.debugFillProperties(t),this.alignment!==null&&t.push({name:"alignment",value:this.alignment}),this.padding!==null&&t.push({name:"padding",value:this.padding}),this.color!==null?t.push({name:"bg",value:this.color}):this.decoration!==null&&t.push({name:"bg",value:this.decoration}),this.foregroundDecoration!==null&&t.push({name:"fg",value:this.foregroundDecoration}),this.constraints!==null&&t.push({name:"constraints",value:this.constraints}),this.margin!==null&&t.push({name:"margin",value:this.margin})}}class N extends d{constructor({key:t=null,alignment:i=P.center,child:n=null}={}){super(t),this.alignment=i,this.child=n}build(t){const i=this.child?.createElement(t.element,t.element.runtime);if(i){i.mount(t.element);const n=i.performRebuild();return new a({tag:"div",props:{style:{display:"flex",justifyContent:"center",alignItems:"center",width:"100%",height:"100%"}},children:[n]})}return new a({tag:"div",children:[]})}}class H extends d{constructor({key:t=null,clipBehavior:i=b.hardEdge,child:n=null}={}){super(t),this.clipBehavior=i,this.child=n}build(t){const i=this.child?.createElement(t.element,t.element.runtime);return i?(i.mount(t.element),i.performRebuild()):new a({tag:"div",children:[]})}}class w extends d{constructor({key:t=null,constraints:i=null,child:n=null}={}){super(t),this.constraints=i,this.child=n}build(t){const i=this.child?.createElement(t.element,t.element.runtime);let n=null;i&&(i.mount(t.element),n=i.performRebuild());const e={};return this.constraints&&(this.constraints.minWidth>0&&(e.minWidth=`${this.constraints.minWidth}px`),this.constraints.maxWidth<1/0&&(e.maxWidth=`${this.constraints.maxWidth}px`),this.constraints.minHeight>0&&(e.minHeight=`${this.constraints.minHeight}px`),this.constraints.maxHeight<1/0&&(e.maxHeight=`${this.constraints.maxHeight}px`),this.constraints.minWidth===0&&this.constraints.maxWidth===1/0&&(e.width="100%"),this.constraints.minHeight===0&&this.constraints.maxHeight===1/0&&(e.height="100%")),new a({tag:"div",props:{style:e},children:n?[n]:[]})}}class R extends d{constructor({key:t=null,maxWidth:i=1/0,maxHeight:n=1/0,child:e=null}={}){super(t),this.maxWidth=i,this.maxHeight=n,this.child=e}build(t){const i=this.child?.createElement(t.element,t.element.runtime);return i?(i.mount(t.element),i.performRebuild()):new a({tag:"div",children:[]})}}class E extends d{constructor({key:t=null,transform:i=null,alignment:n=null,child:e=null}={}){super(t),this.transform=i,this.alignment=n,this.child=e}build(t){const i=this.child?.createElement(t.element,t.element.runtime);return i?(i.mount(t.element),i.performRebuild()):new a({tag:"div",children:[]})}}export{h as BoxConstraints,y as BoxDecoration,H as ClipPath,S as ColoredBox,w as ConstrainedBox,j as Container,g as DecoratedBox,v as DecoratedBoxElement,f as Decoration,m as DecorationPosition,u as EdgeInsets,R as LimitedBox,x as Padding,W as RenderDecoratedBox,E as Transform};
//# sourceMappingURL=container.js.map
