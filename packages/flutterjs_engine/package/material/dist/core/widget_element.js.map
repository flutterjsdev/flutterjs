{
  "version": 3,
  "sources": ["../../src/core/widget_element.js"],
  "sourcesContent": ["/**\r\n * FIXED: Complete Stateful/Stateless Widget System\r\n * \r\n * KEY FIXES:\r\n * 1. StatefulElement properly initializes State with lifecycle\r\n * 2. State.setState() correctly marks element for rebuild\r\n * 3. Proper context passing through entire widget tree\r\n * 4. Both StatelessElement and StatefulElement work correctly\r\n */\r\n\r\nimport { Diagnosticable, Element, StatelessElement, StatefulElement } from \"@flutterjs/runtime/element\";\r\nimport { VNode } from \"@flutterjs/vdom/vnode\";\r\n\r\n// ============================================================================\r\n// STATE BASE CLASS - FIXED\r\n// ============================================================================\r\n\r\n/**\r\n * State - Mutable state holder for StatefulWidget\r\n * \r\n * \u00E2\u0153\u2026 CRITICAL: This is now properly integrated with StatefulElement\r\n */\r\nclass State extends Diagnosticable {\r\n  constructor() {\r\n    super();\r\n\r\n    // Internal references\r\n    this._element = null;           // Owner StatefulElement\r\n    this._widget = null;            // Current widget configuration\r\n    this._mounted = false;          // Is state mounted?\r\n    this._building = false;         // Currently building?\r\n\r\n    // Lifecycle tracking\r\n    this._didInitState = false;\r\n    this._didMount = false;\r\n    this._isActive = false;\r\n\r\n    // Performance tracking\r\n    this._buildCount = 0;\r\n  }\r\n\r\n  /**\r\n   * Get the widget that created this state\r\n   */\r\n  get widget() {\r\n    return this._widget;\r\n  }\r\n\r\n  /**\r\n   * Get the build context\r\n   */\r\n  get context() {\r\n    return this._element?.context || null;\r\n  }\r\n\r\n  /**\r\n   * Check if state is mounted\r\n   */\r\n  get mounted() {\r\n    return this._mounted;\r\n  }\r\n\r\n  // ========== LIFECYCLE METHODS ==========\r\n\r\n  /**\r\n   * Called once when state is first created\r\n   * Override to initialize state variables\r\n   */\r\n  initState() {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Called when widget configuration changes\r\n   * @param {Widget} oldWidget - Previous widget\r\n   */\r\n  didUpdateWidget(oldWidget) {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Called when inherited dependencies change\r\n   */\r\n  didChangeDependencies() {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Called after first frame is rendered\r\n   */\r\n  didMount() {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Called when state is about to be permanently removed\r\n   * Override to cleanup resources\r\n   */\r\n  dispose() {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Called when state is reactivated\r\n   */\r\n  activate() {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Called when state is deactivated\r\n   */\r\n  deactivate() {\r\n    // Override in subclass\r\n  }\r\n\r\n  /**\r\n   * Build the widget tree\r\n   * MUST be overridden in subclass\r\n   * @param {BuildContext} context - Build context\r\n   * @returns {Widget|VNode} Widget tree or VNode\r\n   */\r\n  build(context) {\r\n    throw new Error(`${this.constructor.name}.build(context) must be implemented`);\r\n  }\r\n\r\n  // ========== STATE MANAGEMENT ==========\r\n\r\n  /**\r\n   * Update state and schedule rebuild\r\n   * @param {Function|Object} updateFn - Update function or object\r\n   */\r\n  setState(updateFn) {\r\n    if (!this.mounted) {\r\n      console.warn(`[State] setState called on unmounted state`);\r\n      return;\r\n    }\r\n\r\n    if (this._building) {\r\n      console.warn(`[State] setState called during build`);\r\n    }\r\n\r\n    // Apply update\r\n    if (typeof updateFn === 'function') {\r\n      try {\r\n        updateFn.call(this);\r\n      } catch (error) {\r\n        console.error(`[State] setState update function failed:`, error);\r\n        throw error;\r\n      }\r\n    } else if (typeof updateFn === 'object' && updateFn !== null) {\r\n      Object.assign(this, updateFn);\r\n    }\r\n\r\n    // Trigger rebuild\r\n    if (this._element && typeof this._element.markNeedsBuild === 'function') {\r\n      this._element.markNeedsBuild();\r\n    }\r\n  }\r\n\r\n  // ========== INTERNAL LIFECYCLE (called by StatefulElement) ==========\r\n\r\n  /**\r\n   * Internal: Initialize state\r\n   * Called by StatefulElement after mount\r\n   */\r\n  _init() {\r\n    if (this._didInitState) {\r\n      return;\r\n    }\r\n\r\n    this._didInitState = true;\r\n    this._mounted = true;\r\n    this._isActive = true;\r\n\r\n    try {\r\n      console.log(`[State] Calling initState for ${this.constructor.name}`);\r\n      this.initState();\r\n    } catch (error) {\r\n      console.error(`[State] initState failed:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Call didChangeDependencies\r\n   */\r\n  _didChangeDependencies() {\r\n    try {\r\n      this.didChangeDependencies();\r\n    } catch (error) {\r\n      console.error(`[State] didChangeDependencies failed:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Call didMount\r\n   */\r\n  _didMount() {\r\n    if (this._didMount) {\r\n      return;\r\n    }\r\n\r\n    this._didMount = true;\r\n\r\n    try {\r\n      console.log(`[State] Calling didMount for ${this.constructor.name}`);\r\n      this.didMount();\r\n    } catch (error) {\r\n      console.error(`[State] didMount failed:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Dispose state\r\n   */\r\n  _dispose() {\r\n    this._mounted = false;\r\n    this._isActive = false;\r\n\r\n    try {\r\n      console.log(`[State] Calling dispose for ${this.constructor.name}`);\r\n      this.dispose();\r\n    } catch (error) {\r\n      console.error(`[State] dispose failed:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Deactivate state\r\n   */\r\n  _deactivate() {\r\n    if (!this._isActive) {\r\n      return;\r\n    }\r\n\r\n    this._isActive = false;\r\n\r\n    try {\r\n      this.deactivate();\r\n    } catch (error) {\r\n      console.error(`[State] deactivate failed:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal: Reactivate state\r\n   */\r\n  _reactivate() {\r\n    if (this._isActive) {\r\n      return;\r\n    }\r\n\r\n    this._isActive = true;\r\n\r\n    try {\r\n      this.activate();\r\n    } catch (error) {\r\n      console.error(`[State] activate failed:`, error);\r\n    }\r\n  }\r\n\r\n  toStringShort() {\r\n    return `${this.constructor.name}`;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// WIDGET BASE CLASS\r\n// ============================================================================\r\n\r\nclass Widget extends Diagnosticable {\r\n  constructor(key = null) {\r\n    super();\r\n    if (new.target === Widget) {\r\n      throw new Error('Widget is abstract and cannot be instantiated');\r\n    }\r\n    this.key = key;\r\n  }\r\n\r\n  /**\r\n   * Create an Element for this widget\r\n   * Must be implemented in subclasses\r\n   */\r\n  createElement(parent, runtime) {\r\n    throw new Error(\r\n      `${this.constructor.name}.createElement() must be implemented`\r\n    );\r\n  }\r\n\r\n  toStringShort() {\r\n    return `${this.constructor.name}${this.key ? `(key: ${this.key})` : '(unkeyed)'}`;\r\n  }\r\n\r\n  debugFillProperties(properties) {\r\n    super.debugFillProperties(properties);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// STATELESS WIDGET\r\n// ============================================================================\r\n\r\nclass StatelessWidget extends Widget {\r\n  constructor(key = null) {\r\n    super(key);\r\n  }\r\n\r\n  /**\r\n   * Build the widget UI\r\n   * MUST be overridden\r\n   */\r\n  build(context) {\r\n    throw new Error(`${this.constructor.name}.build(context) must be implemented`);\r\n  }\r\n\r\n  /**\r\n   * Create element for this widget\r\n   */\r\n  createElement(parent, runtime) {\r\n    return new StatelessElement(this, parent, runtime);\r\n  }\r\n}\r\n\r\n// StatelessElement is imported from @flutterjs/runtime\r\n\r\n// ============================================================================\r\n// STATEFUL WIDGET\r\n// ============================================================================\r\n\r\nclass StatefulWidget extends Widget {\r\n  constructor(key = null) {\r\n    super(key);\r\n  }\r\n\r\n  /**\r\n   * Create the state object\r\n   * MUST be overridden\r\n   */\r\n  createState() {\r\n    throw new Error(`${this.constructor.name}.createState() must be implemented`);\r\n  }\r\n\r\n  /**\r\n   * Create element for this widget\r\n   */\r\n  createElement(parent, runtime) {\r\n    return new StatefulElement(this, parent, runtime);\r\n  }\r\n}\r\n\r\n// StatefulElement is imported from @flutterjs/runtime\r\n\r\n// ============================================================================\r\n// PROXY WIDGET\r\n// ============================================================================\r\n\r\nclass ProxyWidget extends Widget {\r\n  constructor({ key = null, child = null } = {}) {\r\n    super(key);\r\n    if (new.target === ProxyWidget) {\r\n      throw new Error('ProxyWidget is abstract');\r\n    }\r\n    this.child = child;\r\n  }\r\n\r\n  createElement(parent, runtime) {\r\n    return new ProxyElement(this, parent, runtime);\r\n  }\r\n}\r\n\r\n/**\r\n * ProxyElement - Element for proxy widget\r\n */\r\nclass ProxyElement extends Element {\r\n  constructor(widget, parent = null, runtime = null) {\r\n    super(widget, parent, runtime);\r\n  }\r\n\r\n  performRebuild() {\r\n    if (!this.widget.child) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const childElement = this.widget.child.createElement(this, this.runtime);\r\n\r\n      if (childElement && typeof childElement.mount === 'function') {\r\n        childElement.mount(this);\r\n      }\r\n\r\n      // \u2705 FIX: Reuse existing VNode if child already built during mount\r\n      // ProxyElement creates a NEW element every time, and mount() triggers a build.\r\n      // We must not trigger performRebuild() again or we get duplication.\r\n      if (childElement && childElement._vnode) {\r\n        return childElement._vnode;\r\n      }\r\n\r\n      if (childElement && typeof childElement.performRebuild === 'function') {\r\n        return childElement.performRebuild();\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error(`[ProxyElement] performRebuild failed:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// ERROR WIDGET\r\n// ============================================================================\r\n\r\nclass ErrorWidget extends StatelessWidget {\r\n  constructor({ message = 'Error', error = null } = {}) {\r\n    super();\r\n    this.message = message;\r\n    this.error = error;\r\n  }\r\n\r\n  build(context) {\r\n    return new VNode({\r\n      tag: 'div',\r\n      props: {\r\n        style: {\r\n          backgroundColor: '#ff1744',\r\n          color: 'white',\r\n          padding: '16px',\r\n          borderRadius: '4px',\r\n          fontFamily: 'monospace',\r\n          fontSize: '12px',\r\n          whiteSpace: 'pre-wrap',\r\n          wordBreak: 'break-word'\r\n        }\r\n      },\r\n      children: [this.message]\r\n    });\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// KEY CLASSES\r\n// ============================================================================\r\n\r\nclass Key {\r\n  constructor() {\r\n    if (new.target === Key) {\r\n      throw new Error('Key is abstract');\r\n    }\r\n  }\r\n}\r\n\r\nclass ValueKey extends Key {\r\n  constructor(value) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  equals(other) {\r\n    return other instanceof ValueKey && this.value === other.value;\r\n  }\r\n\r\n  toString() {\r\n    return `ValueKey(${this.value})`;\r\n  }\r\n}\r\n\r\nclass ObjectKey extends Key {\r\n  constructor(value) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  equals(other) {\r\n    return other instanceof ObjectKey && this.value === other.value;\r\n  }\r\n\r\n  toString() {\r\n    return `ObjectKey(${this.value})`;\r\n  }\r\n}\r\n\r\nclass GlobalKey extends Key {\r\n  constructor(debugLabel = null) {\r\n    super();\r\n    this.debugLabel = debugLabel;\r\n    this._currentElement = null;\r\n  }\r\n\r\n  get currentContext() {\r\n    return this._currentElement?.context || null;\r\n  }\r\n\r\n  get currentWidget() {\r\n    return this._currentElement?.widget || null;\r\n  }\r\n\r\n  get currentState() {\r\n    return this._currentElement?.state || null;\r\n  }\r\n\r\n  equals(other) {\r\n    return other instanceof GlobalKey && this === other;\r\n  }\r\n\r\n  toString() {\r\n    return `GlobalKey${this.debugLabel ? `(${this.debugLabel})` : ''}`;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EXPORTS\r\n// ============================================================================\r\n\r\nexport {\r\n  State,\r\n  Widget,\r\n  StatelessWidget,\r\n  StatelessElement,\r\n  StatefulWidget,\r\n  StatefulElement,\r\n  ProxyWidget,\r\n  ProxyElement,\r\n  ErrorWidget,\r\n  Key,\r\n  ValueKey,\r\n  ObjectKey,\r\n  GlobalKey,\r\n  Diagnosticable\r\n};"],
  "mappings": "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",
  "names": ["Diagnosticable", "Element", "StatelessElement", "StatefulElement", "VNode", "State", "oldWidget", "context", "updateFn", "error", "Widget", "key", "parent", "runtime", "properties", "StatelessWidget", "StatefulWidget", "ProxyWidget", "child", "ProxyElement", "widget", "childElement", "ErrorWidget", "message", "Key", "ValueKey", "value", "other", "ObjectKey", "GlobalKey", "debugLabel"]
}
