{
  "version": 3,
  "sources": ["../../src/widgets/navigator.js"],
  "sourcesContent": ["/**\r\n * ============================================================================\r\n * Navigator Widget\r\n * ============================================================================\r\n * \r\n * A widget that manages a set of child widgets with a stack discipline.\r\n */\r\n\r\nimport { StatefulWidget, State } from '../core/widget_element.js';\r\nimport { VNode } from '@flutterjs/vdom/vnode';\r\n\r\nclass Route {\r\n    constructor({ settings = {}, builder = null } = {}) {\r\n        this.settings = settings;\r\n        this.builder = builder;\r\n    }\r\n}\r\n\r\nclass Navigator extends StatefulWidget {\r\n    constructor({\r\n        key = null,\r\n        initialRoute = '/',\r\n        onGenerateRoute = null,\r\n        onUnknownRoute = null,\r\n        routes = {}\r\n    } = {}) {\r\n        super(key);\r\n        this.initialRoute = initialRoute;\r\n        this.onGenerateRoute = onGenerateRoute;\r\n        this.onUnknownRoute = onUnknownRoute;\r\n        this.routes = routes;\r\n    }\r\n\r\n    createState() {\r\n        return new NavigatorState();\r\n    }\r\n\r\n    static of(context) {\r\n        // Find the nearest NavigatorState ancestor\r\n        // This requires context.findAncestorStateOfType\r\n        // For now, we assume context.findAncestorStateOfType is available or implemented in BuildContext\r\n        // If not, we might need a workaround or implement it.\r\n\r\n        // Check if context has findAncestorStateOfType\r\n        if (context && typeof context.findAncestorStateOfType === 'function') {\r\n            const state = context.findAncestorStateOfType(NavigatorState);\r\n            if (state) return state;\r\n        }\r\n\r\n        // Fallback: simple traversal if available (depends on context implementation)\r\n        let ancestor = context;\r\n        while (ancestor) {\r\n            if (ancestor instanceof NavigatorState) return ancestor;\r\n            if (ancestor.state instanceof NavigatorState) return ancestor.state;\r\n            ancestor = ancestor.parent;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nclass NavigatorState extends State {\r\n    constructor() {\r\n        super();\r\n        this._history = [];\r\n    }\r\n\r\n    initState() {\r\n        super.initState();\r\n\r\n        // Listen for browser back button\r\n        if (typeof window !== 'undefined') {\r\n            window.addEventListener('popstate', this._handlePopState.bind(this));\r\n\r\n            // Sync initial route with current URL if explicitly on client side\r\n            const p = window.location.pathname;\r\n            if (p && p !== '/' && p !== this.widget.initialRoute) {\r\n                // If URL is /details but initialRoute is /, prefer URL\r\n                // Actually, MaterialApp usually handles this, but we can double check\r\n            }\r\n        }\r\n\r\n        // Initialize with initial route WITHOUT calling setState\r\n        // (we're already in initial build, no need to trigger another rebuild)\r\n        const route = this._routeNamed(this.widget.initialRoute, null);\r\n        if (route) {\r\n            this._history.push(route);\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        if (typeof window !== 'undefined') {\r\n            window.removeEventListener('popstate', this._handlePopState.bind(this));\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    _handlePopState(event) {\r\n        if (this._history.length > 1) {\r\n            this._history.pop();\r\n            this.setState(() => { });\r\n        }\r\n    }\r\n\r\n    push(route) {\r\n        this._history.push(route);\r\n\r\n        // Sync with browser URL\r\n        if (typeof window !== 'undefined' && route.settings && route.settings.name) {\r\n            const name = route.settings.name;\r\n            // Avoid pushing duplicate states\r\n            if (window.location.pathname !== name) {\r\n                window.history.pushState({ name }, '', name);\r\n            }\r\n        }\r\n\r\n        this.setState(() => { });\r\n        return Promise.resolve(); // Future<T>\r\n    }\r\n\r\n    pushNamed(routeName, { arguments: args = null } = {}) {\r\n        const route = this._routeNamed(routeName, args);\r\n        if (route) {\r\n            this.push(route);\r\n        } else {\r\n            console.warn(`Navigator: No route defined for \"${routeName}\"`);\r\n        }\r\n    }\r\n\r\n    pop(result) {\r\n        if (this.canPop()) {\r\n            // If we are in browser, use history.back() to emulate natural behavior\r\n            // The 'popstate' event handler will take care of updating the state\r\n            if (typeof window !== 'undefined') {\r\n                window.history.back();\r\n                return true;\r\n            }\r\n\r\n            // Fallback for non-browser environments\r\n            this._history.pop();\r\n            this.setState(() => { });\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    canPop() {\r\n        return this._history.length > 1;\r\n    }\r\n\r\n    _routeNamed(name, args) {\r\n        const settings = { name, arguments: args };\r\n\r\n        // 1. Check routes map\r\n        if (this.widget.routes && this.widget.routes[name]) {\r\n            return new Route({\r\n                settings,\r\n                builder: this.widget.routes[name]\r\n            });\r\n        }\r\n\r\n        // 2. onGenerateRoute\r\n        if (this.widget.onGenerateRoute) {\r\n            return this.widget.onGenerateRoute(settings);\r\n        }\r\n\r\n        // 3. onUnknownRoute\r\n        if (this.widget.onUnknownRoute) {\r\n            return this.widget.onUnknownRoute(settings);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    build(context) {\r\n        if (this._history.length === 0) {\r\n            return null; // Or empty container\r\n        }\r\n\r\n        // Get top route\r\n        const route = this._history[this._history.length - 1];\r\n\r\n        // Build the page\r\n        if (route.builder) {\r\n            console.log(`[Navigator] Building route ${this._history.length}:`, route.settings);\r\n            const page = route.builder(context);\r\n\r\n            // CRITICAL FIX: Add a key based on route name to force rebuild when route changes\r\n            // This prevents \"Widget unchanged, reusing existing vnode\" issue\r\n            if (page && route.settings && route.settings.name) {\r\n                // If the page widget doesn't have a key, add one based on the route name\r\n                if (!page.key) {\r\n                    page.key = `route_${route.settings.name}_${this._history.length}`;\r\n                }\r\n            }\r\n\r\n            return page;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport { Navigator, NavigatorState, Route };\r\n"],
  "mappings": "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",
  "names": ["StatefulWidget", "State", "Route", "settings", "builder", "Navigator", "key", "initialRoute", "onGenerateRoute", "onUnknownRoute", "routes", "NavigatorState", "context", "state", "ancestor", "p", "route", "event", "name", "routeName", "args", "result", "page"]
}
