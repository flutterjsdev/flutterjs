{
  "version": 3,
  "sources": ["../../../src/widgets/compoment/shader_mask.js"],
  "sourcesContent": ["import { ProxyWidget } from '../../core/widget_element.js';\r\nimport { VNode } from '@flutterjs/vdom/vnode';\r\nimport { BlendMode } from './opacity.js';\r\n\r\n// ============================================================================\r\n// SHADER MASK WIDGET - FLUTTER-LIKE BEHAVIOR\r\n// Applies shader mask directly to child rendering (CSS mask-image)\r\n// ============================================================================\r\n\r\nclass ShaderMask extends ProxyWidget {\r\n    constructor({ key = null, shaderCallback = null, blendMode = BlendMode.modulate, child = null } = {}) {\r\n        super({ key, child });\r\n\r\n        if (typeof shaderCallback !== 'function') {\r\n            throw new Error(\r\n                `ShaderMask requires a shaderCallback function, got: ${typeof shaderCallback}`\r\n            );\r\n        }\r\n\r\n        if (!Object.values(BlendMode).includes(blendMode)) {\r\n            throw new Error(\r\n                `Invalid blendMode: ${blendMode}`\r\n            );\r\n        }\r\n\r\n        this.shaderCallback = shaderCallback;\r\n        this.blendMode = blendMode;\r\n        this._renderObject = null;\r\n        this._containerElement = null;\r\n        this._maskImageUrl = null;\r\n    }\r\n\r\n    /**\r\n     * Create render object for shader mask\r\n     */\r\n    createRenderObject(context) {\r\n        return new RenderShaderMask({\r\n            shaderCallback: this.shaderCallback,\r\n            blendMode: this.blendMode,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update render object when properties change\r\n     */\r\n    updateRenderObject(context, renderObject) {\r\n        renderObject.shaderCallback = this.shaderCallback;\r\n        renderObject.blendMode = this.blendMode;\r\n    }\r\n\r\n    /**\r\n     * Build the widget tree\r\n     */\r\n    build(context) {\r\n        // Create or update render object\r\n        if (!this._renderObject) {\r\n            this._renderObject = this.createRenderObject(context);\r\n        } else {\r\n            this.updateRenderObject(context, this._renderObject);\r\n        }\r\n\r\n        // Build child widget\r\n        let childVNode = null;\r\n        if (this.child) {\r\n            if (this.child.createElement) {\r\n                const childElement = this.child.createElement(context.element, context.element.runtime);\r\n                childElement.mount(context.element);\r\n                childVNode = childElement.performRebuild();\r\n            } else {\r\n                childVNode = this.child;\r\n            }\r\n        }\r\n\r\n        const elementId = context.element.getElementId();\r\n        const widgetPath = context.element.getWidgetPath();\r\n\r\n        // Create container that applies mask to children\r\n        // Similar to Flutter: the shader mask applies TO the child, not over it\r\n        return new VNode({\r\n            tag: 'div',\r\n            props: {\r\n                style: {\r\n                    position: 'relative',\r\n                    overflow: 'hidden',\r\n                    display: 'inline-block'\r\n                },\r\n                'data-element-id': elementId,\r\n                'data-widget-path': widgetPath,\r\n                'data-widget': 'ShaderMask',\r\n                'data-blend-mode': this.blendMode,\r\n                ref: (el) => this._onContainerMount(el, context)\r\n            },\r\n            children: [\r\n                // Child content wrapper with mask applied\r\n                new VNode({\r\n                    tag: 'div',\r\n                    props: {\r\n                        style: {\r\n                            position: 'relative',\r\n                            width: '100%',\r\n                            height: '100%'\r\n                        },\r\n                        'data-widget': 'ShaderMaskContent',\r\n                        ref: (el) => this._onContentMount(el)\r\n                    },\r\n                    children: childVNode ? [childVNode] : []\r\n                })\r\n            ],\r\n            key: this.key\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Mount container\r\n     */\r\n    _onContainerMount(el, context) {\r\n        if (!el) return;\r\n\r\n        this._containerElement = el;\r\n\r\n        // Generate and apply shader mask when container is mounted\r\n        if (this._containerElement) {\r\n            this._generateAndApplyShaderMask();\r\n        }\r\n\r\n        // Re-render on window resize\r\n        const resizeHandler = () => this._generateAndApplyShaderMask();\r\n        window.addEventListener('resize', resizeHandler);\r\n\r\n        // Cleanup on unmount\r\n        el._cleanupResize = () => {\r\n            window.removeEventListener('resize', resizeHandler);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Mount content element\r\n     */\r\n    _onContentMount(el) {\r\n        if (!el) return;\r\n\r\n        // Apply mask to content when it's mounted\r\n        if (this._containerElement) {\r\n            this._generateAndApplyShaderMask();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate shader mask and apply it to container\r\n     */\r\n    _generateAndApplyShaderMask() {\r\n        if (!this._containerElement) return;\r\n\r\n        try {\r\n            // Get container dimensions\r\n            const rect = this._containerElement.getBoundingClientRect();\r\n            const size = {\r\n                width: Math.ceil(rect.width) || 200,\r\n                height: Math.ceil(rect.height) || 200\r\n            };\r\n\r\n            // Call shader callback to get shader configuration\r\n            const shaderConfig = this.shaderCallback(size);\r\n\r\n            // Apply shader mask to container (affects children rendering)\r\n            this._applyShaderToContainer(shaderConfig, size);\r\n        } catch (error) {\r\n            console.error('Error rendering shader mask:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply shader mask to container (Flutter-like behavior)\r\n     * The mask is applied TO the child elements, not over them\r\n     */\r\n    _applyShaderToContainer(shaderConfig, size) {\r\n        if (!this._containerElement || !shaderConfig) return;\r\n\r\n        // Handle gradient-based masks (like Flutter)\r\n        if (shaderConfig.type === 'gradient' && shaderConfig.gradient) {\r\n            // Create SVG-based mask from gradient\r\n            const maskSvg = this._createGradientMask(shaderConfig.gradient, size);\r\n            this._applyMaskImage(maskSvg);\r\n        }\r\n\r\n        // Handle SVG-based masks\r\n        if (shaderConfig.type === 'svg' && shaderConfig.svgContent) {\r\n            // Use SVG directly as mask\r\n            this._applyMaskImage(`url('data:image/svg+xml;utf8,${encodeURIComponent(shaderConfig.svgContent)}')`);\r\n        }\r\n\r\n        // Handle URL-based masks\r\n        if (shaderConfig.type === 'url' && shaderConfig.url) {\r\n            this._applyMaskImage(`url('${shaderConfig.url}')`);\r\n        }\r\n\r\n        // Handle custom mask-image CSS\r\n        if (shaderConfig.maskImage) {\r\n            this._applyMaskImage(shaderConfig.maskImage);\r\n        }\r\n\r\n        // Apply blend mode if needed\r\n        if (this.blendMode) {\r\n            this._containerElement.style.mixBlendMode = this.blendMode;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply mask-image to container\r\n     */\r\n    _applyMaskImage(maskImage) {\r\n        if (!this._containerElement || !maskImage) return;\r\n\r\n        // Apply CSS mask (works on all modern browsers)\r\n        this._containerElement.style.WebkitMaskImage = maskImage;\r\n        this._containerElement.style.WebkitMaskSize = '100% 100%';\r\n        this._containerElement.style.WebkitMaskRepeat = 'no-repeat';\r\n        this._containerElement.style.WebkitMaskPosition = '0 0';\r\n\r\n        // Standard mask properties\r\n        this._containerElement.style.maskImage = maskImage;\r\n        this._containerElement.style.maskSize = '100% 100%';\r\n        this._containerElement.style.maskRepeat = 'no-repeat';\r\n        this._containerElement.style.maskPosition = '0 0';\r\n\r\n        this._maskImageUrl = maskImage;\r\n    }\r\n\r\n    /**\r\n     * Create SVG-based gradient mask from gradient string\r\n     */\r\n    _createGradientMask(gradientCss, size) {\r\n        // Parse gradient and create SVG mask\r\n        const svgNS = 'http://www.w3.org/2000/svg';\r\n        const svg = document.createElementNS(svgNS, 'svg');\r\n        svg.setAttribute('width', size.width);\r\n        svg.setAttribute('height', size.height);\r\n        svg.setAttribute('viewBox', `0 0 ${size.width} ${size.height}`);\r\n\r\n        const defs = document.createElementNS(svgNS, 'defs');\r\n\r\n        // Create gradient definition from CSS gradient\r\n        const gradient = document.createElementNS(svgNS, 'linearGradient');\r\n        gradient.setAttribute('id', 'maskGradient');\r\n        gradient.setAttribute('x1', '0%');\r\n        gradient.setAttribute('y1', '0%');\r\n        gradient.setAttribute('x2', '100%');\r\n        gradient.setAttribute('y2', '0%');\r\n\r\n        // Parse simple gradient colors\r\n        // For: linear-gradient(to right, rgba(0,0,0,1), rgba(0,0,0,0))\r\n        const colorStops = [\r\n            { offset: '0%', color: '#000000', opacity: '1' },\r\n            { offset: '100%', color: '#000000', opacity: '0' }\r\n        ];\r\n\r\n        colorStops.forEach(stop => {\r\n            const stop_el = document.createElementNS(svgNS, 'stop');\r\n            stop_el.setAttribute('offset', stop.offset);\r\n            stop_el.setAttribute('stop-color', stop.color);\r\n            stop_el.setAttribute('stop-opacity', stop.opacity);\r\n            gradient.appendChild(stop_el);\r\n        });\r\n\r\n        defs.appendChild(gradient);\r\n        svg.appendChild(defs);\r\n\r\n        // Create rect with gradient\r\n        const rect = document.createElementNS(svgNS, 'rect');\r\n        rect.setAttribute('width', size.width);\r\n        rect.setAttribute('height', size.height);\r\n        rect.setAttribute('fill', 'url(#maskGradient)');\r\n        svg.appendChild(rect);\r\n\r\n        // Convert SVG to data URL\r\n        const svgString = new XMLSerializer().serializeToString(svg);\r\n        return `url('data:image/svg+xml;utf8,${encodeURIComponent(svgString)}')`;\r\n    }\r\n\r\n    /**\r\n     * Debug properties\r\n     */\r\n    debugFillProperties(properties) {\r\n        super.debugFillProperties(properties);\r\n        properties.push({\r\n            name: 'blendMode',\r\n            value: this.blendMode\r\n        });\r\n        properties.push({\r\n            name: 'shaderCallback',\r\n            value: 'function'\r\n        });\r\n        if (this._maskImageUrl) {\r\n            properties.push({\r\n                name: 'maskApplied',\r\n                value: 'true'\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create element\r\n     */\r\n    createElement(parent, runtime) {\r\n        return new ShaderMaskElement(this,parent, runtime);\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// RENDER SHADER MASK\r\n// ============================================================================\r\n\r\nclass RenderShaderMask {\r\n    constructor({ shaderCallback = null, blendMode = BlendMode.modulate } = {}) {\r\n        this.shaderCallback = shaderCallback;\r\n        this.blendMode = blendMode;\r\n    }\r\n\r\n    /**\r\n     * Apply shader mask to element\r\n     */\r\n    applyToElement(element) {\r\n        if (element) {\r\n            element.style.position = 'relative';\r\n            element.style.overflow = 'hidden';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate shader (calls the callback)\r\n     */\r\n    generateShader(size) {\r\n        try {\r\n            return this.shaderCallback(size);\r\n        } catch (error) {\r\n            console.error('Error in shaderCallback:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get debug info\r\n     */\r\n    debugInfo() {\r\n        return {\r\n            type: 'RenderShaderMask',\r\n            blendMode: this.blendMode,\r\n            hasShaderCallback: typeof this.shaderCallback === 'function'\r\n        };\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// SHADER MASK ELEMENT\r\n// ============================================================================\r\n\r\nclass ShaderMaskElement extends ProxyWidget.constructor.prototype.constructor {\r\n    performRebuild() {\r\n        return this.widget.build(this.context);\r\n    }\r\n\r\n    detach() {\r\n        // Cleanup resize listener\r\n        if (this.widget._containerElement && this.widget._containerElement._cleanupResize) {\r\n            this.widget._containerElement._cleanupResize();\r\n        }\r\n        super.detach();\r\n    }\r\n}\r\n\r\nexport { ShaderMask, RenderShaderMask };"],
  "mappings": "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",
  "names": ["ProxyWidget", "VNode", "BlendMode", "ShaderMask", "key", "shaderCallback", "blendMode", "child", "context", "RenderShaderMask", "renderObject", "childVNode", "childElement", "elementId", "widgetPath", "el", "resizeHandler", "rect", "size", "shaderConfig", "error", "maskSvg", "maskImage", "gradientCss", "svgNS", "svg", "defs", "gradient", "stop", "stop_el", "svgString", "properties", "parent", "runtime", "ShaderMaskElement", "element"]
}
