import{Widget as b,StatelessWidget as v}from"../../core/widget_element.js";import{Element as x}from"@flutterjs/runtime";import"@flutterjs/vdom/vnode";import{TextDirection as g}from"../../utils/utils.js";import"../../utils/geometry.js";class m{constructor(t=0,l=0,i=0,n=0){this.left=t,this.top=l,this.right=i,this.bottom=n}static fill(){return new m(0,0,0,0)}static fromRect(t,l){return new m(t.left,t.top,l.width-t.right,l.height-t.bottom)}toString(){return`RelativeRect(${this.left}, ${this.top}, ${this.right}, ${this.bottom})`}}class w{constructor(){this.left=null,this.top=null,this.right=null,this.bottom=null,this.width=null,this.height=null}isPositioned(){return this.left!==null||this.top!==null||this.right!==null||this.bottom!==null||this.width!==null||this.height!==null}reset(){this.left=null,this.top=null,this.right=null,this.bottom=null,this.width=null,this.height=null}debugInfo(){return{left:this.left,top:this.top,right:this.right,bottom:this.bottom,width:this.width,height:this.height,isPositioned:this.isPositioned()}}}class o extends b{constructor({key:t=null,left:l=null,top:i=null,right:n=null,bottom:h=null,width:s=null,height:e=null,child:u=null}={}){if(super(t),l!==null&&n!==null&&s!==null)throw new Error("Cannot specify left, right, and width simultaneously. Either (left, right, width) or (left, right) or (left, width) is valid.");if(i!==null&&h!==null&&e!==null)throw new Error("Cannot specify top, bottom, and height simultaneously. Either (top, bottom, height) or (top, bottom) or (top, height) is valid.");this.left=l,this.top=i,this.right=n,this.bottom=h,this.width=s,this.height=e,this.child=u}static fill({key:t=null,left:l=0,top:i=0,right:n=0,bottom:h=0,child:s=null}={}){return new o({key:t,left:l,top:i,right:n,bottom:h,child:s})}static fromRect({key:t=null,rect:l=null,child:i=null}={}){if(!l)throw new Error("rect parameter is required");return new o({key:t,left:l.left,top:l.top,width:l.width,height:l.height,right:null,bottom:null,child:i})}static fromRelativeRect({key:t=null,rect:l=null,child:i=null}={}){if(!l)throw new Error("rect parameter is required");return new o({key:t,left:l.left,top:l.top,right:l.right,bottom:l.bottom,width:null,height:null,child:i})}static directional({key:t=null,textDirection:l=g.ltr,start:i=null,top:n=null,end:h=null,bottom:s=null,width:e=null,height:u=null,child:r=null}={}){if(!r)throw new Error("child parameter is required");const a=l===g.rtl,f=a?h:i,d=a?i:h;return new o({key:t,left:f,top:n,right:d,bottom:s,width:e,height:u,child:r})}applyParentData(t){t.parentData||(t.parentData=new w);const l=t.parentData;let i=!1;l.left!==this.left&&(l.left=this.left,i=!0),l.top!==this.top&&(l.top=this.top,i=!0),l.right!==this.right&&(l.right=this.right,i=!0),l.bottom!==this.bottom&&(l.bottom=this.bottom,i=!0),l.width!==this.width&&(l.width=this.width,i=!0),l.height!==this.height&&(l.height=this.height,i=!0),i&&t.parent&&t.parent.markNeedsLayout?.()}build(t){return this.child}get isPurelyPositioned(){return this.width===null&&this.height===null}getPositioningStyle(){const t={position:"absolute"};return this.left!==null&&(t.left=`${this.left}px`),this.top!==null&&(t.top=`${this.top}px`),this.right!==null&&(t.right=`${this.right}px`),this.bottom!==null&&(t.bottom=`${this.bottom}px`),this.width!==null&&(t.width=`${this.width}px`),this.height!==null&&(t.height=`${this.height}px`),t}debugFillProperties(t){super.debugFillProperties(t),this.left!==null&&t.push({name:"left",value:this.left}),this.top!==null&&t.push({name:"top",value:this.top}),this.right!==null&&t.push({name:"right",value:this.right}),this.bottom!==null&&t.push({name:"bottom",value:this.bottom}),this.width!==null&&t.push({name:"width",value:this.width}),this.height!==null&&t.push({name:"height",value:this.height})}createElement(t,l){return new c(this,t,l)}}class c extends x{performRebuild(){return this.widget.build(this.context)}updateRenderObject(t){this.widget.applyParentData&&this.widget.applyParentData(t)}}class y extends v{constructor({key:t=null,start:l=null,top:i=null,end:n=null,bottom:h=null,width:s=null,height:e=null,child:u=null}={}){super(t),this.start=l,this.top=i,this.end=n,this.bottom=h,this.width=s,this.height=e,this.child=u}build(t){if(!this.child)throw new Error("PositionedDirectional requires a child widget");const l=t?.textDirection||g.ltr;return o.directional({textDirection:l,start:this.start,top:this.top,end:this.end,bottom:this.bottom,width:this.width,height:this.height,child:this.child,key:this.key})}debugFillProperties(t){super.debugFillProperties(t),this.start!==null&&t.push({name:"start",value:this.start}),this.top!==null&&t.push({name:"top",value:this.top}),this.end!==null&&t.push({name:"end",value:this.end}),this.bottom!==null&&t.push({name:"bottom",value:this.bottom}),this.width!==null&&t.push({name:"width",value:this.width}),this.height!==null&&t.push({name:"height",value:this.height})}}class P{static resolveConstraints({left:t=null,top:l=null,right:i=null,bottom:n=null,width:h=null,height:s=null,containerWidth:e=0,containerHeight:u=0}={}){let r=t??0,a=l??0,f=h,d=s;return t!==null&&i!==null&&h===null?f=e-t-i:t!==null&&h!==null?f=h:i!==null&&h!==null?r=e-i-h:i!==null&&t===null&&(r=e-(h||0)-i),l!==null&&n!==null&&s===null?d=u-l-n:l!==null&&s!==null?d=s:n!==null&&s!==null?a=u-n-s:n!==null&&l===null&&(a=u-(s||0)-n),{left:r,top:a,width:f||"auto",height:d||"auto"}}static isFullyConstrained({left:t=null,right:l=null,width:i=null,top:n=null,bottom:h=null,height:s=null}={}){return(t!==null&&l!==null||t!==null&&i!==null||l!==null&&i!==null)&&(n!==null&&h!==null||n!==null&&s!==null||h!==null&&s!==null)}}export{o as Positioned,y as PositionedDirectional,c as PositionedElement,P as PositioningHelper,m as RelativeRect,w as StackParentData};
//# sourceMappingURL=positioned.js.map
