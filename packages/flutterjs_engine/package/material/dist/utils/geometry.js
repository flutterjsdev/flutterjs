class u{constructor(t=0,i=0){this._dx=t,this._dy=i}get dx(){return this._dx}get dy(){return this._dy}get isInfinite(){return this._dx>=Number.POSITIVE_INFINITY||this._dy>=Number.POSITIVE_INFINITY}get isFinite(){return Number.isFinite(this._dx)&&Number.isFinite(this._dy)}lessThan(t){return this._dx<t._dx&&this._dy<t._dy}lessThanOrEqual(t){return this._dx<=t._dx&&this._dy<=t._dy}greaterThan(t){return this._dx>t._dx&&this._dy>t._dy}greaterThanOrEqual(t){return this._dx>=t._dx&&this._dy>=t._dy}equals(t){return!t||!(t instanceof u)?!1:this._dx===t._dx&&this._dy===t._dy}hashCode(){return this._hashCombine(this._dx,this._dy)}_hashCombine(t,i){let e=0;return e=(e<<5)-e+t,e=(e<<5)-e+i,e&e}toString(){return`${this.constructor.name}(${this._dx.toFixed(1)}, ${this._dy.toFixed(1)})`}}class h extends u{constructor(t=0,i=0){super(t,i)}get width(){return this._dx}get height(){return this._dy}static get zero(){return new h(0,0)}static get infinite(){return new h(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}static copy(t){return!t||!(t instanceof h)?new h:new h(t.width,t.height)}static square(t){return new h(t,t)}static fromWidth(t){return new h(t,Number.POSITIVE_INFINITY)}static fromHeight(t){return new h(Number.POSITIVE_INFINITY,t)}static fromRadius(t){return new h(t*2,t*2)}get isEmpty(){return this.width<=0||this.height<=0}get aspectRatio(){return this.height!==0?this.width/this.height:this.width>0?Number.POSITIVE_INFINITY:this.width<0?Number.NEGATIVE_INFINITY:0}get shortestSide(){return Math.min(Math.abs(this.width),Math.abs(this.height))}get longestSide(){return Math.max(Math.abs(this.width),Math.abs(this.height))}get flipped(){return new h(this.height,this.width)}topLeft(t=new n(0,0)){return t}topCenter(t=new n(0,0)){return new n(t.dx+this.width/2,t.dy)}topRight(t=new n(0,0)){return new n(t.dx+this.width,t.dy)}centerLeft(t=new n(0,0)){return new n(t.dx,t.dy+this.height/2)}center(t=new n(0,0)){return new n(t.dx+this.width/2,t.dy+this.height/2)}centerRight(t=new n(0,0)){return new n(t.dx+this.width,t.dy+this.height/2)}bottomLeft(t=new n(0,0)){return new n(t.dx,t.dy+this.height)}bottomCenter(t=new n(0,0)){return new n(t.dx+this.width/2,t.dy+this.height)}bottomRight(t=new n(0,0)){return new n(t.dx+this.width,t.dy+this.height)}contains(t){return!t||!(t instanceof n)?!1:t.dx>=0&&t.dx<this.width&&t.dy>=0&&t.dy<this.height}subtract(t){if(t instanceof h)return new n(this.width-t.width,this.height-t.height);if(t instanceof n)return new h(this.width-t.dx,this.height-t.dy);throw new Error(`Cannot subtract ${t.constructor.name} from Size`)}add(t){if(!t||!(t instanceof n))throw new Error("Can only add Offset to Size");return new h(this.width+t.dx,this.height+t.dy)}multiply(t){if(typeof t!="number")throw new Error("Can only multiply Size by number");return new h(this.width*t,this.height*t)}divide(t){if(typeof t!="number")throw new Error("Can only divide Size by number");if(t===0)throw new Error("Division by zero");return new h(this.width/t,this.height/t)}floorDivide(t){if(typeof t!="number")throw new Error("Can only divide Size by number");if(t===0)throw new Error("Division by zero");return new h(Math.floor(this.width/t),Math.floor(this.height/t))}modulo(t){if(typeof t!="number")throw new Error("Can only apply modulo with number");return new h(this.width%t,this.height%t)}static lerp(t,i,e){if(typeof e!="number"||e<0||e>1)throw new Error("Parameter t must be between 0 and 1");return i==null?t==null?null:t.multiply(1-e):t==null?i.multiply(e):new h(h._lerpDouble(t.width,i.width,e),h._lerpDouble(t.height,i.height,e))}static _lerpDouble(t,i,e){return t+(i-t)*e}equals(t){return!t||!(t instanceof h)?!1:this._dx===t._dx&&this._dy===t._dy}hashCode(){return this._hashCombine(this.width,this.height)}toString(){return`Size(${this.width.toFixed(1)}, ${this.height.toFixed(1)})`}}class n extends u{constructor(t=0,i=0){super(t,i)}static get zero(){return new n(0,0)}static get infinite(){return new n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}static fromDirection(t,i=1){return new n(i*Math.cos(t),i*Math.sin(t))}static lerp(t,i,e){if(typeof e!="number"||e<0||e>1)throw new Error("Parameter t must be between 0 and 1");return i==null?t==null?null:t.multiply(1-e):t==null?i.multiply(e):new n(n._lerpDouble(t.dx,i.dx,e),n._lerpDouble(t.dy,i.dy,e))}static _lerpDouble(t,i,e){return t+(i-t)*e}get distance(){return Math.sqrt(this._dx*this._dx+this._dy*this._dy)}get distanceSquared(){return this._dx*this._dx+this._dy*this._dy}get direction(){return Math.atan2(this._dy,this._dx)}add(t){if(!t||!(t instanceof n))throw new Error("Can only add Offset to Offset");return new n(this._dx+t._dx,this._dy+t._dy)}subtract(t){if(!t||!(t instanceof n))throw new Error("Can only subtract Offset from Offset");return new n(this._dx-t._dx,this._dy-t._dy)}multiply(t){if(typeof t!="number")throw new Error("Can only multiply Offset by number");return new n(this._dx*t,this._dy*t)}divide(t){if(typeof t!="number")throw new Error("Can only divide Offset by number");if(t===0)throw new Error("Division by zero");return new n(this._dx/t,this._dy/t)}floorDivide(t){if(typeof t!="number")throw new Error("Can only divide Offset by number");if(t===0)throw new Error("Division by zero");return new n(Math.floor(this._dx/t),Math.floor(this._dy/t))}modulo(t){if(typeof t!="number")throw new Error("Can only apply modulo with number");return new n(this._dx%t,this._dy%t)}scale(t,i=t){return new n(this._dx*t,this._dy*i)}rotate(t){const i=Math.cos(t),e=Math.sin(t);return new n(this._dx*i-this._dy*e,this._dx*e+this._dy*i)}translate(t=0,i=0){return new n(this._dx+t,this._dy+i)}get negate(){return new n(-this._dx,-this._dy)}equals(t){return!t||!(t instanceof n)?!1:this._dx===t._dx&&this._dy===t._dy}hashCode(){return this._hashCombine(this._dx,this._dy)}toString(){return`Offset(${this._dx.toFixed(1)}, ${this._dy.toFixed(1)})`}}class l{constructor(t=0,i=0,e=0,o=0){this.left=t,this.top=i,this.right=e,this.bottom=o}static fromLTWH(t,i,e,o){return new l(t,i,t+e,i+o)}static fromCircle(t,i){return new l(t.dx-i,t.dy-i,t.dx+i,t.dy+i)}static fromPoints(t,i){return new l(Math.min(t.dx,i.dx),Math.min(t.dy,i.dy),Math.max(t.dx,i.dx),Math.max(t.dy,i.dy))}get width(){return this.right-this.left}get height(){return this.bottom-this.top}get size(){return new h(this.width,this.height)}get topLeft(){return new n(this.left,this.top)}get bottomRight(){return new n(this.right,this.bottom)}get center(){return new n(this.left+this.width/2,this.top+this.height/2)}contains(t){return t.dx>=this.left&&t.dx<this.right&&t.dy>=this.top&&t.dy<this.bottom}intersects(t){return!(this.left>=t.right||this.right<=t.left||this.top>=t.bottom||this.bottom<=t.top)}toString(){return`Rect.fromLTRB(${this.left.toFixed(1)}, ${this.top.toFixed(1)}, ${this.right.toFixed(1)}, ${this.bottom.toFixed(1)})`}}class r{constructor(t=0,i=0){this.x=t,this.y=i}static circular(t){return new r(t,t)}static elliptical(t,i){return new r(t,i)}static get zero(){return new r(0,0)}clamp(t={}){const{minimum:i,maximum:e}=t,o=i||r.circular(Number.NEGATIVE_INFINITY),m=e||r.circular(Number.POSITIVE_INFINITY);return new r(r._clampDouble(this.x,o.x,m.x),r._clampDouble(this.y,o.y,m.y))}clampValues(t={}){const{minimumX:i,minimumY:e,maximumX:o,maximumY:m}=t;return new r(r._clampDouble(this.x,i??Number.NEGATIVE_INFINITY,o??Number.POSITIVE_INFINITY),r._clampDouble(this.y,e??Number.NEGATIVE_INFINITY,m??Number.POSITIVE_INFINITY))}static _clampDouble(t,i,e){return t<i?i:t>e?e:t}negate(){return new r(-this.x,-this.y)}subtract(t){if(!t||!(t instanceof r))throw new Error("Can only subtract Radius from Radius");return new r(this.x-t.x,this.y-t.y)}add(t){if(!t||!(t instanceof r))throw new Error("Can only add Radius to Radius");return new r(this.x+t.x,this.y+t.y)}multiply(t){if(typeof t!="number")throw new Error("Can only multiply Radius by number");return new r(this.x*t,this.y*t)}divide(t){if(typeof t!="number")throw new Error("Can only divide Radius by number");if(t===0)throw new Error("Division by zero");return new r(this.x/t,this.y/t)}floorDivide(t){if(typeof t!="number")throw new Error("Can only divide Radius by number");if(t===0)throw new Error("Division by zero");return new r(Math.floor(this.x/t),Math.floor(this.y/t))}modulo(t){if(typeof t!="number")throw new Error("Can only apply modulo with number");return new r(this.x%t,this.y%t)}static lerp(t,i,e){if(typeof e!="number"||e<0||e>1)throw new Error("Parameter t must be between 0 and 1");if(i==null){if(t==null)return null;const o=1-e;return new r(t.x*o,t.y*o)}return t==null?new r(i.x*e,i.y*e):new r(r._lerpDouble(t.x,i.x,e),r._lerpDouble(t.y,i.y,e))}static _lerpDouble(t,i,e){return t+(i-t)*e}equals(t){return!t||!(t instanceof r)?!1:this.x===t.x&&this.y===t.y}hashCode(){let t=0;return t=(t<<5)-t+this.x,t=(t<<5)-t+this.y,t&t}toString(){return this.x===this.y?`Radius.circular(${this.x.toFixed(1)})`:`Radius.elliptical(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`}}class s{constructor(t,i,e,o){this.topLeft=t||r.zero,this.topRight=i||r.zero,this.bottomRight=e||r.zero,this.bottomLeft=o||r.zero}static all(t){return t instanceof r||(t=r.circular(t)),new s(t,t,t,t)}static circular(t){const i=r.circular(t);return new s(i,i,i,i)}static vertical(t,i){return new s(t,t,i,i)}static horizontal(t,i){return new s(t,i,i,t)}static only({topLeft:t,topRight:i,bottomRight:e,bottomLeft:o}={}){return new s(t||r.zero,i||r.zero,e||r.zero,o||r.zero)}static fromBorderSide(t,i){return i instanceof r||(i=r.circular(i)),new s(i,i,i,i)}static get zero(){return new s(r.zero,r.zero,r.zero,r.zero)}get isNonNegative(){return this.topLeft.x>=0&&this.topLeft.y>=0&&this.topRight.x>=0&&this.topRight.y>=0&&this.bottomRight.x>=0&&this.bottomRight.y>=0&&this.bottomLeft.x>=0&&this.bottomLeft.y>=0}clamp(t={}){const{minimum:i,maximum:e}=t;return new s(this.topLeft.clamp({minimum:i,maximum:e}),this.topRight.clamp({minimum:i,maximum:e}),this.bottomRight.clamp({minimum:i,maximum:e}),this.bottomLeft.clamp({minimum:i,maximum:e}))}subtract(t){if(!t||!(t instanceof s))throw new Error("Can only subtract BorderRadius from BorderRadius");return new s(this.topLeft.subtract(t.topLeft),this.topRight.subtract(t.topRight),this.bottomRight.subtract(t.bottomRight),this.bottomLeft.subtract(t.bottomLeft))}add(t){if(!t||!(t instanceof s))throw new Error("Can only add BorderRadius to BorderRadius");return new s(this.topLeft.add(t.topLeft),this.topRight.add(t.topRight),this.bottomRight.add(t.bottomRight),this.bottomLeft.add(t.bottomLeft))}multiply(t){if(typeof t!="number")throw new Error("Can only multiply BorderRadius by number");return new s(this.topLeft.multiply(t),this.topRight.multiply(t),this.bottomRight.multiply(t),this.bottomLeft.multiply(t))}divide(t){if(typeof t!="number")throw new Error("Can only divide BorderRadius by number");return new s(this.topLeft.divide(t),this.topRight.divide(t),this.bottomRight.divide(t),this.bottomLeft.divide(t))}toCSSString(){return this._isUniform()?this.topLeft.x===this.topRight.x&&this.topRight.x===this.bottomRight.x&&this.bottomRight.x===this.bottomLeft.x?`${this.topLeft.x}px`:`${this.topLeft.x}px ${this.topRight.x}px ${this.bottomRight.x}px ${this.bottomLeft.x}px`:`${this.topLeft.x}px ${this.topRight.x}px ${this.bottomRight.x}px ${this.bottomLeft.x}px`}_isUniform(){return this.topLeft.x===this.topLeft.y&&this.topRight.x===this.topRight.y&&this.bottomRight.x===this.bottomRight.y&&this.bottomLeft.x===this.bottomLeft.y}static lerp(t,i,e){if(typeof e!="number"||e<0||e>1)throw new Error("Parameter t must be between 0 and 1");return i==null?t==null?null:t.multiply(1-e):t==null?i.multiply(e):new s(r.lerp(t.topLeft,i.topLeft,e),r.lerp(t.topRight,i.topRight,e),r.lerp(t.bottomRight,i.bottomRight,e),r.lerp(t.bottomLeft,i.bottomLeft,e))}equals(t){return!t||!(t instanceof s)?!1:this.topLeft.equals(t.topLeft)&&this.topRight.equals(t.topRight)&&this.bottomRight.equals(t.bottomRight)&&this.bottomLeft.equals(t.bottomLeft)}hashCode(){let t=0;return t=(t<<5)-t+this.topLeft.hashCode(),t=(t<<5)-t+this.topRight.hashCode(),t=(t<<5)-t+this.bottomRight.hashCode(),t=(t<<5)-t+this.bottomLeft.hashCode(),t&t}toString(){return this.topLeft.equals(this.topRight)&&this.topRight.equals(this.bottomRight)&&this.bottomRight.equals(this.bottomLeft)?`BorderRadius.all(${this.topLeft.toString()})`:`BorderRadius(topLeft: ${this.topLeft}, topRight: ${this.topRight}, bottomRight: ${this.bottomRight}, bottomLeft: ${this.bottomLeft})`}}export{s as BorderRadius,n as Offset,u as OffsetBase,r as Radius,l as Rect,h as Size};
//# sourceMappingURL=geometry.js.map
