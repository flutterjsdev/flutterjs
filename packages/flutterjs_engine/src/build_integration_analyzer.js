console.log("HELLO FROM BUILD ANALYZER - VERIFYING EXECUTION");
/**
 * ============================================================================
 * BuildAnalyzer - Analysis Pipeline (Phases 1-7)
 * ============================================================================
 *
 * Responsibility: Source code analysis, dependency resolution, and transformation
 * 
 * Phases:
 * 1. Analyze source code
 * 2. Resolve dependencies
 * 3. Install packages
 * 4. Collect packages (âœ… UPDATED: Uses enhanced PackageCollector)
 * 5. Transform code (âœ… UPDATED: Uses enhanced ImportRewriter)
 * 6. Initialize runtime
 * 7. Build widget metadata
 */

import fs from "fs";
import path from "path";
import chalk from "chalk";
import ora from "ora";

import { PathResolver } from "./path-resolver.js";
import { Analyzer } from "@flutterjs/analyzer/analyzer";
import { DependencyResolver } from "./dependency_resolver.js";
// import { PackageInstaller } from "./flutterjs_package_installer.js"; // REMOVED
import { PackageCollector } from "./package_collector.js";
import { ImportRewriter } from "./import_rewriter.js";
import { CodeTransformer } from "./code_transformer.js";

class BuildAnalyzer {
  constructor(buildIntegration) {
    this.integration = buildIntegration;
    this.config = buildIntegration.config;
    this.projectRoot = buildIntegration.projectRoot;

    // Initialize sub-systems
    this.pathResolver = new PathResolver(buildIntegration.projectRoot, this.config);
    this.dependencyResolver = new DependencyResolver({
      projectRoot: buildIntegration.projectRoot,
      debugMode: this.config.debugMode,
      config: this.config, // âœ… Pass full config for package resolution
    });
    // this.packageInstaller = new PackageInstaller(...); // REMOVED

    // âœ… DEBUG: Log config status
    console.log(chalk.magenta('\n[DEBUG] BuildIntegrationAnalyzer initialized'));
    console.log(chalk.magenta(`  Has config: ${!!this.config}`));
    console.log(chalk.magenta(`  Has config.packages: ${!!this.config?.packages}`));
    if (this.config?.packages) {
      console.log(chalk.magenta(`  Config packages: ${Object.keys(this.config.packages).join(', ')}`));
      Object.entries(this.config.packages).forEach(([name, pkg]) => {
        if (pkg.path) {
          console.log(chalk.magenta(`    ${name}: ${pkg.path}`));
        }
      });
    }
    console.log();

    this.packageCollector = new PackageCollector({
      projectRoot: buildIntegration.projectRoot,
      outputDir: this.config.outputDir,
      debugMode: this.config.debugMode,
    });
    this.importRewriter = new ImportRewriter({
      debugMode: this.config.debugMode,
      baseDir: '/node_modules/@flutterjs',  // âœ… FIXED: Absolute path without ./
    });
    this.codeTransformer = new CodeTransformer({}, {
      debugMode: this.config.debugMode,
    });

    if (this.config.debugMode) {
      console.log(chalk.gray("[BuildAnalyzer] Initialized\n"));
    }
  }

  /**
   * ========================================================================
   * PHASE 1: ANALYZE SOURCE CODE
   * ========================================================================
   */
  async phase1_analyze() {
    console.log(chalk.red('\n========== ANALYZE AND RESOLVE CALLED =========='));
    console.log(chalk.red(`Project: ${this.projectRoot}`));
    console.log(chalk.red(`MainFile: ${this.pathResolver.getSourcePath()}`));
    console.log(chalk.red(`Has Config: ${!!this.config}`));
    console.log(chalk.red(`Has Config.packages: ${!!this.config?.packages}`));
    console.log(chalk.red('================================================\n'));
    const spinner = ora(
      chalk.blue("ðŸ“Š Phase 1: Analyzing source code...")
    ).start();

    try {
      const sourcePath = this.pathResolver.getSourcePath();

      if (!fs.existsSync(sourcePath)) {
        throw new Error(`Source file not found: ${sourcePath}`);
      }

      const sourceCode = fs.readFileSync(sourcePath, "utf-8");

      // âœ… NEW: Detect if source is already JS (generated by Dart)
      const isJS = sourcePath.endsWith('.js');

      let widgets = { stateless: [], stateful: [] };
      let imports = [];
      let analysisResult = {};

      if (isJS) {
        if (this.config.debugMode) {
          console.log(chalk.blue('  â„¹ï¸  Detected JavaScript source - Using Regex Analysis'));
        }

        // Simple Regex Analysis for JS
        // Extract imports
        // Robust Regex Analysis for JS (handling minified code)
        // Matches: import { X } from 'y'; import 'y'; import{X}from'y';
        const importRegex = /import\s*(?:(?:\{[\s\S]*?\}|[\w$*,\s]+)\s*from\s*)?['"]([^'"]+)['"]/g;
        let match;
        while ((match = importRegex.exec(sourceCode)) !== null) {
          imports.push(match[1]);
        }

        // Extract widgets (heuristic based on class names/extends)
        const classRegex = /class\s+(\w+)\s+(?:extends\s+(\w+))?/g;
        while ((match = classRegex.exec(sourceCode)) !== null) {
          const name = match[1];
          const superClass = match[2];

          if (superClass === 'StatelessWidget') widgets.stateless.push(name);
          if (superClass === 'StatefulWidget') widgets.stateful.push(name);
        }

      } else {
        // Legacy Dart Analysis
        const analyzer = new Analyzer({
          sourceCode,
          sourceFile: sourcePath,
          debugMode: this.config.debugMode,
          includeImports: true,
          includeContext: true,
          includeSsr: true,
          outputFormat: "json",
        });

        analysisResult = await analyzer.analyze();
        widgets = this.normalizeWidgets(analysisResult.widgets);
        imports = analysisResult.imports || [];
      }

      // âœ… IMPORTANT: Always ensure core packages (@flutterjs/vdom, @flutterjs/runtime) are in imports
      // These are required by the runtime bootstrap and widget system
      const finalImports = this.ensureCoreImports(imports);

      this.integration.analysis = {
        sourcePath,
        sourceCode,
        widgets: {
          stateless: widgets.stateless,
          stateful: widgets.stateful,
          count: widgets.stateless.length + widgets.stateful.length,
          all: [...widgets.stateless, ...widgets.stateful],
        },
        imports: finalImports,  // âœ… Updated with vdom
        metadata: {
          projectName: "FlutterJS App",
          rootWidget: widgets.stateful[0] || widgets.stateless[0] || "MyApp",
          stateClasses: this.extractStateClasses(widgets.stateful),
          linesOfCode: sourceCode.split("\n").length,
        },
      };

      spinner.succeed(chalk.green("âœ” Analysis complete"));
      if (this.config.debugMode) {
        console.log(chalk.gray(`  Widgets: ${this.integration.analysis.widgets.count}`));
        console.log(chalk.gray(`  Stateless: ${widgets.stateless.length}`));
        console.log(chalk.gray(`  Stateful: ${widgets.stateful.length}`));
        console.log(chalk.gray(`  Imports: ${Object.keys(this.integration.analysis.imports).length}`)); // Adjusted log
        console.log(chalk.gray(`  Includes @flutterjs/vdom: YES (automatic)`));
        console.log(chalk.gray(`  Root: ${this.integration.analysis.metadata.rootWidget}\n`));
      }
    } catch (error) {
      spinner.fail(chalk.red(`âœ– Analysis failed: ${error.message}`));
      throw error;
    }
  }

  /**
   * âœ… NEW: Ensure core packages are always in imports
   * vdom and runtime are required by all Flutter widgets and bootstrap
   */
  ensureCoreImports(imports) {
    // Handle different import formats
    let importObject = {};

    if (Array.isArray(imports)) {
      // Format: ['@flutterjs/runtime', '@flutterjs/material', ...]
      for (const item of imports) {
        if (typeof item === 'string') {
          importObject[item] = [];
        } else if (item && typeof item === 'object' && item.source) {
          importObject[item.source] = [];
        }
      }
    } else if (typeof imports === 'object' && imports !== null) {
      // Format: { '@flutterjs/runtime': ['runApp'], '@flutterjs/material': [...] }
      importObject = { ...imports };
    }

    // âœ… Always add vdom and runtime as required dependencies
    const corePackages = ['@flutterjs/vdom', '@flutterjs/runtime', '@flutterjs/seo', '@flutterjs/dart'];

    for (const pkg of corePackages) {
      if (!importObject[pkg]) {
        importObject[pkg] = [];

        if (this.config.debugMode) {
          console.log(chalk.yellow(`  â„¹ï¸  Auto-added ${pkg} to imports (required core dependency)`));
        }
      }
    }

    return importObject;
  }

  /**
   * ========================================================================
   * PHASE 2: RESOLVE DEPENDENCIES
   * ========================================================================
   */
  async phase2_resolveDependencies() {
    const spinner = ora(
      chalk.blue("ðŸ”— Phase 2: Resolving dependencies...")
    ).start();

    try {
      // âœ… FIXED: Pass analyzer result directly
      const resolutionResult = await this.dependencyResolver.resolveAll(
        this.integration.analysis
      );

      this.integration.resolution = this.normalizeResolution(resolutionResult);

      // âœ… FIX: Ensure all packages from flutterjs.config.js are included in resolution
      // This is critical for generic node_modules that might not be explicitly imported
      // but are required at runtime (e.g. http -> http_parser)
      if (this.config.packages) {
        for (const [name, pkg] of Object.entries(this.config.packages)) {
          if (!this.integration.resolution.packages.has(name)) {
            if (this.config.debugMode) {
              console.log(chalk.gray(`  Simulating resolution for config package: ${name}`));
            }
            this.integration.resolution.packages.set(name, pkg.path);
          }
        }
      }

      if (this.config.debugMode) {
        console.log(chalk.yellow("\nResolved Packages:"));
        this.integration.resolution.packages.forEach((info, name) => {
          console.log(chalk.green(`  âœ” ${name}`));
          console.log(chalk.gray(`     ${info.location || info.source}`));
        });
        console.log();
      }

      spinner.succeed(
        chalk.green(`âœ” Resolved ${this.integration.resolution.packages.size} packages`)
      );
    } catch (error) {
      spinner.fail(chalk.red(`âœ– Resolution failed: ${error.message}`));
      throw error;
    }
  }

  /**
   * ========================================================================
   * PHASE 3: INSTALL PACKAGES
   * ========================================================================
   */
  async phase3_installPackages() {
    const spinner = ora(
      chalk.blue("ðŸ“¦ Phase 3: Installing packages...")
    ).start();

    // âœ… STUBBED: Handled by Dart
    spinner.succeed(chalk.green(`âœ” Packages prepared by Dart`));
    return;
  }

  /**
   * ========================================================================
   * PHASE 4: COLLECT PACKAGES
   * ========================================================================
   * âœ… UPDATED: Uses enhanced PackageCollector.collectAndCopyPackages()
   */
  async phase4_collectPackages() {
    const spinner = ora(
      chalk.blue("ðŸ“‹ Phase 4: Collecting packages...")
    ).start();

    // âœ… SKIP in development mode
    if (this.config.mode === 'development') {
      spinner.info(chalk.yellow("â„¹ï¸  Skipping package collection (dev mode)"));
      this.integration.collection = {
        copiedFiles: [],
        failedFiles: [],
        totalSize: 0,
        session: null,
      };
      return;
    }

    try {
      if (!this.integration.resolution || this.integration.resolution.packages.size === 0) {
        spinner.info(chalk.yellow("â„¹ï¸  No packages to collect"));
        this.integration.collection = {
          copiedFiles: [],
          failedFiles: [],
          totalSize: 0,
          session: null,
        };
        return;
      }

      // âœ… Use enhanced PackageCollector with new method
      const session = await this.packageCollector.collectAndCopyPackages(
        this.integration.resolution
      );

      // âœ… Store session and results
      this.integration.collection = {
        copiedFiles: Array.from(session.results.keys()),
        failedFiles: session.globalErrors.length > 0 ? session.globalErrors : [],
        totalSize: session.totalSize,
        session: session,
      };

      spinner.succeed(chalk.green(`âœ” Collection complete`));
      if (this.config.debugMode) {
        const stats = session.getReport();
        console.log(chalk.gray(`  Packages: ${stats.successful}/${stats.total}`));
        console.log(chalk.gray(`  Files: ${stats.files}`));
        console.log(chalk.gray(`  Size: ${stats.size}\n`));
      }
    } catch (error) {
      spinner.fail(chalk.red(`âœ– Collection failed: ${error.message}`));
      throw error;
    }
  }

  /**
   * ========================================================================
   * PHASE 5: TRANSFORM CODE
   * ========================================================================
   * âœ… UPDATED: Uses enhanced ImportRewriter.analyzeImports()
   */
  async phase5_transformCode() {
    const spinner = ora(chalk.blue("ðŸ”§ Phase 5: Transforming code...")).start();

    try {
      const sourceCode = this.integration.analysis.sourceCode;

      // âœ… NEW: Analyze imports WITH resolution data
      const importAnalysisResult = await this.importRewriter.analyzeImportsWithResolution(
        sourceCode,
        this.integration.resolution  // Pass resolution so we can read package.json files
      );

      // Transform code
      const transformResult = this.codeTransformer.transform(sourceCode);

      // Store transformed code
      this.integration.transformed = {
        originalCode: sourceCode,
        transformedCode: transformResult.transformedCode || sourceCode,
        importsRewritten: importAnalysisResult.stats.framework,
        transformations: transformResult.transformations?.length || 0,
        exports: transformResult.exports || [],
        errors: transformResult.errors || [],
        warnings: transformResult.warnings || [],
      };

      // Store import analysis with import map
      this.integration.importAnalysis = importAnalysisResult;

      // âœ… NEW: Store the generated import map for HTML generation
      const importMapObj = importAnalysisResult.getImportMapObject();
      const importMapScript = importAnalysisResult.getImportMapScript();

      this.integration.importMap = importMapObj;
      this.integration.importMapScript = importMapScript;

      spinner.succeed(chalk.green(`âœ” Transformation complete`));
      if (this.config.debugMode) {
        console.log(chalk.gray(`  Framework imports found: ${importAnalysisResult.stats.framework}`));
        console.log(chalk.gray(`  External imports: ${importAnalysisResult.stats.external}`));
        console.log(chalk.gray(`  Local imports: ${importAnalysisResult.stats.local}`));
        console.log(chalk.gray(`  Packages loaded: ${importAnalysisResult.packageExports.size}`));

        const importCount = (importMapObj.imports) ? Object.keys(importMapObj.imports).length : 0;
        console.log(chalk.gray(`  Import map entries: ${importCount}`));

        if (importMapObj.imports && Object.keys(importMapObj.imports).length > 0) {
          console.log(chalk.gray(`\n  Import Map (first 5):`));
          let count = 0;
          for (const [key, value] of Object.entries(importMapObj.imports)) {
            if (count >= 5) {
              console.log(chalk.gray(`    ... and ${Object.keys(importMapObj.imports).length - 5} more`));
              break;
            }
            console.log(chalk.gray(`    ${key}`));
            console.log(chalk.gray(`      â†’ ${value}`));
            count++;
          }
        }

        console.log(chalk.gray(`  Transformations: ${this.integration.transformed.transformations}\n`));
      }
    } catch (error) {
      spinner.fail(chalk.red(`âœ– Transformation failed: ${error.message}`));
      throw error;
    }
  }

  /**
   * ========================================================================
   * PHASE 6: INITIALIZE RUNTIME
   * ========================================================================
   */
  async phase6_initializeRuntime() {
    const spinner = ora(
      chalk.blue("âš™ï¸  Phase 6: Initializing runtime...")
    ).start();

    try {
      this.integration.runtime = {
        initialized: true,
        mode: "build-time-stub",
        message: "Actual runtime created in browser",
      };

      if (this.config.debugMode) {
        console.log(chalk.green("âœ” Runtime stub created"));
        console.log(chalk.gray("  (Actual runtime will initialize in browser)\n"));
      }

      spinner.succeed(chalk.green("âœ” Runtime prepared"));
    } catch (error) {
      spinner.fail(
        chalk.red(`âœ– Runtime initialization failed: ${error.message}`)
      );
      throw error;
    }
  }

  /**
   * ========================================================================
   * PHASE 7: BUILD WIDGETS
   * ========================================================================
   */
  async phase7_buildWidgets() {
    const spinner = ora(
      chalk.blue("ðŸŽ¨ Phase 7: Preparing widget data...")
    ).start();

    try {
      const widgetMetadata = this.extractWidgetMetadata(
        this.integration.transformed.transformedCode
      );

      this.integration.generatedVNodes = null;
      this.integration.widgetMetadata = widgetMetadata;

      if (this.config.debugMode) {
        console.log(chalk.green("âœ” Widget metadata extracted"));
        console.log(chalk.gray(`  Found ${Object.keys(widgetMetadata).length} widgets\n`));
      }

      spinner.succeed(chalk.green("âœ” Widget preparation complete"));
    } catch (error) {
      spinner.fail(chalk.red(`âœ– Widget preparation failed: ${error.message}`));
      throw error;
    }
  }

  // ========================================================================
  // HELPER METHODS
  // ========================================================================

  /**
   * Normalize widgets from analyzer result
   */
  normalizeWidgets(widgets) {
    if (!widgets) {
      return { stateless: [], stateful: [] };
    }

    return {
      stateless: this.ensureArray(widgets.stateless),
      stateful: this.ensureArray(widgets.stateful),
    };
  }

  /**
   * Ensure value is an array
   */
  ensureArray(value) {
    if (Array.isArray(value)) {
      return value.filter((v) => v && typeof v === "string");
    }
    if (value && typeof value === "object") {
      return Object.keys(value).filter((k) => k && typeof k === "string");
    }
    return [];
  }

  /**
   * Extract state classes from stateful widgets
   */
  extractStateClasses(statefulWidgets) {
    const stateClasses = {};

    if (Array.isArray(statefulWidgets)) {
      statefulWidgets.forEach((widget) => {
        if (widget && typeof widget === "string") {
          stateClasses[widget] = `_${widget}State`;
        }
      });
    }

    return stateClasses;
  }

  /**
   * Normalize dependency resolver output
   */
  normalizeResolution(result) {
    if (!result) {
      return {
        packages: new Map(),
        allFiles: [],
        graph: new Map(),
        errors: [],
        warnings: [],
      };
    }

    let packages = result.packages || new Map();

    if (packages instanceof Map) {
      // Already a Map
    } else if (typeof packages === "object" && packages !== null) {
      // Convert object to Map
      packages = new Map(Object.entries(packages));
    } else {
      // Invalid, reset to empty Map
      packages = new Map();
    }

    return {
      packages,
      allFiles: result.allFiles || [],
      graph: result.graph || new Map(),
      errors: result.errors || [],
      warnings: result.warnings || [],
    };
  }

  /**
   * Extract widget metadata from transformed code
   */
  extractWidgetMetadata(transformedCode) {
    const metadata = {};
    const classRegex =
      /export\s+(?:class|const)\s+([A-Z][a-zA-Z0-9]*)\s+(?:extends\s+(\w+)|=\s*class)/g;
    let match;

    while ((match = classRegex.exec(transformedCode)) !== null) {
      const className = match[1];
      const extendsClass = match[2] || "unknown";

      metadata[className] = {
        name: className,
        baseClass: extendsClass,
        isStateful:
          extendsClass === "StatefulWidget" ||
          extendsClass.includes("Stateful"),
        isStateless:
          extendsClass === "StatelessWidget" ||
          extendsClass.includes("Stateless"),
      };
    }

    return metadata;
  }
}

export { BuildAnalyzer };
export default BuildAnalyzer;