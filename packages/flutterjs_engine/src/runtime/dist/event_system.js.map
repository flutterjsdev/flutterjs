{
  "version": 3,
  "sources": ["../src/event_system.js"],
  "sourcesContent": ["/**\n * FlutterJS Event System\n *\n * Manages event delegation, event handling, and propagation across the widget tree.\n * Uses event delegation at the root for efficient event management.\n *\n * Key Features:\n * - Event delegation (single root listener instead of per-element)\n * - Event bubbling and capturing\n * - Synthetic event objects\n * - Event handler registration/unregistration\n * - Gesture support (tap, long-press, swipe)\n * - Focus management\n * - Performance optimized for large DOMs\n *\n * Usage:\n * ```javascript\n * const eventSystem = new EventSystem(runtime);\n * eventSystem.initialize(rootElement);\n *\n * // Register handler\n * eventSystem.registerHandler(elementId, 'click', (event) => {\n *   console.log('Clicked!');\n * });\n * ```\n */\n\n/**\n * Synthetic Event Object\n *\n * Normalizes native browser events into a consistent format.\n * Provides cross-browser compatibility.\n */\nclass SyntheticEvent {\n  /**\n   * Create synthetic event\n   * @param {Event} nativeEvent - Native browser event\n   * @param {string} type - Event type\n   * @param {HTMLElement} target - Target element\n   * @param {HTMLElement} currentTarget - Current target\n   */\n  constructor(nativeEvent, type, target, currentTarget) {\n    this.nativeEvent = nativeEvent;\n    this.type = type;\n    this.target = target;\n    this.currentTarget = currentTarget;\n\n    // Event control flags\n    this._propagationStopped = false;\n    this._immediatePropagationStopped = false;\n    this._defaultPrevented = false;\n\n    // Time\n    this.timeStamp = nativeEvent.timeStamp || Date.now();\n\n    // Common properties\n    this.bubbles = nativeEvent.bubbles || false;\n    this.cancelable = nativeEvent.cancelable || false;\n\n    // Mouse/pointer properties\n    this.clientX = nativeEvent.clientX || 0;\n    this.clientY = nativeEvent.clientY || 0;\n    this.pageX = nativeEvent.pageX || 0;\n    this.pageY = nativeEvent.pageY || 0;\n    this.screenX = nativeEvent.screenX || 0;\n    this.screenY = nativeEvent.screenY || 0;\n\n    // Button information\n    this.button = nativeEvent.button !== undefined ? nativeEvent.button : -1;\n    this.buttons = nativeEvent.buttons || 0;\n\n    // Modifier keys\n    this.altKey = nativeEvent.altKey || false;\n    this.ctrlKey = nativeEvent.ctrlKey || false;\n    this.metaKey = nativeEvent.metaKey || false;\n    this.shiftKey = nativeEvent.shiftKey || false;\n\n    // Keyboard properties\n    this.key = nativeEvent.key || '';\n    this.code = nativeEvent.code || '';\n    this.keyCode = nativeEvent.keyCode || 0;\n    this.which = nativeEvent.which || 0;\n\n    // Input properties\n    this.value = nativeEvent.target?.value || '';\n    this.checked = nativeEvent.target?.checked || false;\n\n    // Touch properties\n    this.touches = nativeEvent.touches || [];\n    this.changedTouches = nativeEvent.changedTouches || [];\n    this.targetTouches = nativeEvent.targetTouches || [];\n  }\n\n  /**\n   * Prevent default action\n   */\n  preventDefault() {\n    this._defaultPrevented = true;\n    if (this.nativeEvent.preventDefault) {\n      this.nativeEvent.preventDefault();\n    }\n  }\n\n  /**\n   * Check if default prevented\n   */\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n\n  /**\n   * Stop event propagation\n   */\n  stopPropagation() {\n    this._propagationStopped = true;\n    if (this.nativeEvent.stopPropagation) {\n      this.nativeEvent.stopPropagation();\n    }\n  }\n\n  /**\n   * Stop immediate propagation\n   */\n  stopImmediatePropagation() {\n    this._immediatePropagationStopped = true;\n    this._propagationStopped = true;\n    if (this.nativeEvent.stopImmediatePropagation) {\n      this.nativeEvent.stopImmediatePropagation();\n    }\n  }\n\n  /**\n   * Check if propagation stopped\n   */\n  get isPropagationStopped() {\n    return this._propagationStopped;\n  }\n\n  /**\n   * Check if immediate propagation stopped\n   */\n  get isImmediatePropagationStopped() {\n    return this._immediatePropagationStopped;\n  }\n\n  /**\n   * Get event data for debugging\n   */\n  toString() {\n    return `SyntheticEvent(${this.type} @ ${this.target?.tagName || 'unknown'})`;\n  }\n}\n\n/**\n * Event System\n *\n * Manages all event handling for the application using delegation pattern.\n * Dramatically improves performance with large DOMs.\n */\nclass EventSystem {\n  /**\n   * Create event system\n   * @param {RuntimeEngine} runtime - Runtime engine reference\n   * @param {Object} options - Configuration options\n   */\n  constructor(runtime, options = {}) {\n    if (!runtime) {\n      throw new Error('Runtime is required for EventSystem');\n    }\n\n    this.runtime = runtime;\n\n    // Configuration\n    this.config = {\n      enableDebug: options.enableDebug || false,\n      enableCapture: options.enableCapture !== false,\n      enableBubble: options.enableBubble !== false,\n      maxEventListeners: options.maxEventListeners || 10000,\n      eventPoolSize: options.eventPoolSize || 100,\n      ...options\n    };\n\n    // Root element for delegation\n    this.rootElement = null;\n\n    // Handler registry: elementId -> { eventType -> handler[] }\n    this.handlerRegistry = new Map();\n\n    // Delegated event types\n    this.delegatedEvents = new Set([\n      'click', 'dblclick',\n      'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout',\n      'mouseenter', 'mouseleave',\n      'touchstart', 'touchend', 'touchmove', 'touchcancel',\n      'pointerdown', 'pointerup', 'pointermove', 'pointerenter', 'pointerleave',\n      'keydown', 'keyup', 'keypress',\n      'focus', 'blur',\n      'input', 'change', 'submit', 'reset',\n      'scroll', 'resize',\n      'dragstart', 'drag', 'dragover', 'drop',\n      'contextmenu'\n    ]);\n\n    // Native listeners attached at root\n    this.nativeListeners = new Map();\n\n    // Statistics\n    this.stats = {\n      handlersRegistered: 0,\n      handlersUnregistered: 0,\n      eventsDispatched: 0,\n      eventsCancelled: 0,\n      propagationStopped: 0,\n      averageListenerCount: 0\n    };\n\n    // Event pool for optimization (reuse event objects)\n    this.eventPool = [];\n\n    this.initialized = false;\n\n    if (this.config.enableDebug) {\n      console.log('[EventSystem] Created');\n    }\n  }\n\n  /**\n   * Initialize event delegation on root element\n   * @param {HTMLElement} rootElement - Root DOM element\n   * @throws {Error} If root element not valid\n   */\n  initialize(rootElement) {\n    if (!rootElement || !(rootElement instanceof HTMLElement)) {\n      throw new Error('Root element must be a valid HTMLElement');\n    }\n\n    if (this.initialized) {\n      console.warn('[EventSystem] Already initialized, skipping');\n      return;\n    }\n\n    this.rootElement = rootElement;\n\n    // Attach delegated listeners at root\n    this.delegatedEvents.forEach(eventType => {\n      const listener = this.createDelegatedListener(eventType);\n\n      // Use capture for better control\n      rootElement.addEventListener(eventType, listener, true);\n\n      this.nativeListeners.set(eventType, listener);\n\n      if (this.config.enableDebug) {\n        console.log(`[EventSystem] Delegated listener attached for '${eventType}'`);\n      }\n    });\n\n    this.initialized = true;\n\n    if (this.config.enableDebug) {\n      console.log(`[EventSystem] Initialized with ${this.delegatedEvents.size} delegated events`);\n    }\n  }\n\n  /**\n   * Create delegated listener for event type\n   * @private\n   * @param {string} eventType - Event type (e.g., 'click')\n   * @returns {Function} Event listener function\n   */\n  createDelegatedListener(eventType) {\n    return (nativeEvent) => {\n      this.stats.eventsDispatched++;\n\n      let target = nativeEvent.target;\n\n      // Traverse up from target to root\n      while (target && target !== this.rootElement) {\n        const elementId = target.dataset?.elementId;\n\n        if (elementId) {\n          this.dispatchToHandlers(elementId, eventType, nativeEvent);\n\n          // Check if propagation stopped\n          if (nativeEvent._stopPropagation) {\n            break;\n          }\n        }\n\n        target = target.parentElement;\n      }\n    };\n  }\n\n  /**\n   * Dispatch event to all handlers for element\n   * @private\n   * @param {string} elementId - Element ID\n   * @param {string} eventType - Event type\n   * @param {Event} nativeEvent - Native browser event\n   */\n  dispatchToHandlers(elementId, eventType, nativeEvent) {\n    const handlers = this.handlerRegistry.get(elementId);\n\n    if (!handlers || !handlers[eventType]) {\n      return;\n    }\n\n    const handlersArray = handlers[eventType];\n    const target = nativeEvent.target;\n\n    // Create synthetic event\n    const syntheticEvent = new SyntheticEvent(nativeEvent, eventType, target, target);\n\n    // Call each handler\n    for (const handler of handlersArray) {\n      if (syntheticEvent.isImmediatePropagationStopped) {\n        break;\n      }\n\n      try {\n        handler(syntheticEvent);\n      } catch (error) {\n        console.error(\n          `[EventSystem] Handler error for ${eventType} on element ${elementId}:`,\n          error\n        );\n      }\n    }\n\n    // Update propagation flag\n    if (syntheticEvent.isPropagationStopped) {\n      nativeEvent._stopPropagation = true;\n      nativeEvent.stopPropagation();\n    }\n\n    if (syntheticEvent.defaultPrevented) {\n      nativeEvent.preventDefault();\n    }\n  }\n\n  /**\n   * Register event handler for element\n   * @param {string} elementId - Element ID\n   * @param {string} eventType - Event type (e.g., 'click', 'change')\n   * @param {Function} handler - Handler function\n   * @throws {Error} If parameters invalid\n   */\n  registerHandler(elementId, eventType, handler) {\n    if (!elementId || typeof elementId !== 'string') {\n      throw new Error('Element ID must be a non-empty string');\n    }\n\n    if (!eventType || typeof eventType !== 'string') {\n      throw new Error('Event type must be a non-empty string');\n    }\n\n    if (typeof handler !== 'function') {\n      throw new Error('Handler must be a function');\n    }\n\n    // Get or create handler registry for element\n    if (!this.handlerRegistry.has(elementId)) {\n      this.handlerRegistry.set(elementId, {});\n    }\n\n    const handlers = this.handlerRegistry.get(elementId);\n\n    // Get or create handler array for event type\n    if (!handlers[eventType]) {\n      handlers[eventType] = [];\n    }\n\n    const handlersArray = handlers[eventType];\n\n    // Check max listeners warning\n    if (handlersArray.length >= this.config.maxEventListeners) {\n      console.warn(\n        `[EventSystem] Max event listeners (${this.config.maxEventListeners}) ` +\n        `reached for element ${elementId} event ${eventType}`\n      );\n    }\n\n    // Add handler\n    handlersArray.push(handler);\n\n    this.stats.handlersRegistered++;\n\n    if (this.config.enableDebug) {\n      console.log(\n        `[EventSystem] Registered handler for ${elementId}.${eventType} ` +\n        `(total: ${handlersArray.length})`\n      );\n    }\n  }\n\n  /**\n   * Unregister event handler for element\n   * @param {string} elementId - Element ID\n   * @param {string} eventType - Event type (optional)\n   * @param {Function} handler - Handler function (optional)\n   */\n  unregisterHandler(elementId, eventType, handler) {\n    if (!elementId) return;\n\n    const handlers = this.handlerRegistry.get(elementId);\n    if (!handlers) return;\n\n    if (!eventType) {\n      // Remove all handlers for element\n      this.handlerRegistry.delete(elementId);\n      this.stats.handlersUnregistered += Object.keys(handlers).length;\n\n      if (this.config.enableDebug) {\n        console.log(`[EventSystem] Unregistered all handlers for ${elementId}`);\n      }\n\n      return;\n    }\n\n    const handlersArray = handlers[eventType];\n    if (!handlersArray) return;\n\n    if (!handler) {\n      // Remove all handlers for event type\n      const count = handlersArray.length;\n      delete handlers[eventType];\n\n      this.stats.handlersUnregistered += count;\n\n      if (this.config.enableDebug) {\n        console.log(\n          `[EventSystem] Unregistered ${count} handlers for ${elementId}.${eventType}`\n        );\n      }\n\n      return;\n    }\n\n    // Remove specific handler\n    const index = handlersArray.indexOf(handler);\n    if (index !== -1) {\n      handlersArray.splice(index, 1);\n      this.stats.handlersUnregistered++;\n\n      if (this.config.enableDebug) {\n        console.log(\n          `[EventSystem] Unregistered handler for ${elementId}.${eventType} ` +\n          `(remaining: ${handlersArray.length})`\n        );\n      }\n    }\n  }\n\n  /**\n   * Check if element has handlers for event type\n   * @param {string} elementId - Element ID\n   * @param {string} eventType - Event type\n   * @returns {boolean} True if handlers exist\n   */\n  hasHandlers(elementId, eventType) {\n    const handlers = this.handlerRegistry.get(elementId);\n    if (!handlers) return false;\n\n    if (!eventType) {\n      return Object.keys(handlers).length > 0;\n    }\n\n    return (handlers[eventType]?.length || 0) > 0;\n  }\n\n  /**\n   * Get handler count for element\n   * @param {string} elementId - Element ID\n   * @param {string} eventType - Event type (optional)\n   * @returns {number} Handler count\n   */\n  getHandlerCount(elementId, eventType) {\n    const handlers = this.handlerRegistry.get(elementId);\n    if (!handlers) return 0;\n\n    if (!eventType) {\n      return Object.values(handlers).reduce((sum, arr) => sum + arr.length, 0);\n    }\n\n    return handlers[eventType]?.length || 0;\n  }\n\n  /**\n   * Get all event types for element\n   * @param {string} elementId - Element ID\n   * @returns {string[]} Array of event type strings\n   */\n  getEventTypes(elementId) {\n    const handlers = this.handlerRegistry.get(elementId);\n    return handlers ? Object.keys(handlers) : [];\n  }\n\n  /**\n   * Batch register multiple handlers\n   * @param {string} elementId - Element ID\n   * @param {Object} handlers - Map of eventType -> handler function\n   */\n  batchRegister(elementId, handlers) {\n    if (!handlers || typeof handlers !== 'object') {\n      throw new Error('Handlers must be an object');\n    }\n\n    Object.entries(handlers).forEach(([eventType, handler]) => {\n      if (typeof handler === 'function') {\n        this.registerHandler(elementId, eventType, handler);\n      }\n    });\n  }\n\n  /**\n   * Batch unregister handlers for element\n   * @param {string} elementId - Element ID\n   */\n  batchUnregister(elementId) {\n    this.unregisterHandler(elementId);\n  }\n\n  /**\n   * Manually dispatch event (for testing or custom events)\n   * @param {HTMLElement} element - Target element\n   * @param {string} eventType - Event type\n   * @param {Object} options - Event options\n   */\n  dispatchCustomEvent(element, eventType, options = {}) {\n    if (!element) {\n      throw new Error('Element is required');\n    }\n\n    const syntheticEvent = new SyntheticEvent(\n      options.nativeEvent || new Event(eventType),\n      eventType,\n      element,\n      element\n    );\n\n    // Merge custom properties\n    Object.assign(syntheticEvent, options);\n\n    const elementId = element.dataset?.elementId;\n    if (elementId) {\n      this.dispatchToHandlers(elementId, eventType, syntheticEvent.nativeEvent);\n    }\n  }\n\n  /**\n   * Get statistics\n   * @returns {Object} Statistics object\n   */\n  getStats() {\n    const totalHandlers = Array.from(this.handlerRegistry.values())\n      .reduce((sum, handlers) => {\n        return sum + Object.values(handlers).reduce((s, arr) => s + arr.length, 0);\n      }, 0);\n\n    return {\n      ...this.stats,\n      initialized: this.initialized,\n      delegatedEventsCount: this.delegatedEvents.size,\n      elementsWithHandlers: this.handlerRegistry.size,\n      totalHandlers: totalHandlers,\n      nativeListenersAttached: this.nativeListeners.size,\n      averageHandlersPerElement: this.handlerRegistry.size > 0\n        ? Math.round(totalHandlers / this.handlerRegistry.size)\n        : 0\n    };\n  }\n\n  /**\n   * Get detailed handler information\n   * @param {string} elementId - Element ID (optional, for specific element)\n   * @returns {Object} Detailed information\n   */\n  getDetailedInfo(elementId) {\n    if (elementId) {\n      const handlers = this.handlerRegistry.get(elementId);\n      return {\n        elementId,\n        handlers: handlers ? { ...handlers } : {},\n        hasHandlers: !!handlers\n      };\n    }\n\n    // Get info for all elements\n    const all = {};\n    this.handlerRegistry.forEach((handlers, id) => {\n      all[id] = { ...handlers };\n    });\n\n    return {\n      totalElements: this.handlerRegistry.size,\n      elements: all\n    };\n  }\n\n  /**\n   * Clear all handlers for element (cleanup on unmount)\n   * @param {string} elementId - Element ID\n   */\n  clearElement(elementId) {\n    if (!elementId) return;\n\n    const handlerCount = this.getHandlerCount(elementId);\n    this.unregisterHandler(elementId);\n\n    if (this.config.enableDebug && handlerCount > 0) {\n      console.log(\n        `[EventSystem] Cleared ${handlerCount} handlers for element ${elementId}`\n      );\n    }\n  }\n\n  /**\n   * Clear all handlers (app shutdown)\n   */\n  clearAll() {\n    const elementCount = this.handlerRegistry.size;\n    const totalHandlers = Array.from(this.handlerRegistry.values())\n      .reduce((sum, handlers) => {\n        return sum + Object.values(handlers).reduce((s, arr) => s + arr.length, 0);\n      }, 0);\n\n    this.handlerRegistry.clear();\n    this.eventPool = [];\n\n    if (this.config.enableDebug) {\n      console.log(\n        `[EventSystem] Cleared ${totalHandlers} handlers from ${elementCount} elements`\n      );\n    }\n  }\n\n  /**\n   * Dispose event system\n   */\n  dispose() {\n    // Remove delegated listeners\n    if (this.rootElement) {\n      this.nativeListeners.forEach((listener, eventType) => {\n        this.rootElement.removeEventListener(eventType, listener, true);\n      });\n    }\n\n    this.clearAll();\n    this.nativeListeners.clear();\n    this.rootElement = null;\n    this.initialized = false;\n\n    if (this.config.enableDebug) {\n      console.log('[EventSystem] Disposed');\n    }\n  }\n}\n\n\n\nexport {  EventSystem,\n    SyntheticEvent};"],
  "mappings": "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",
  "names": ["SyntheticEvent", "nativeEvent", "type", "target", "currentTarget", "EventSystem", "runtime", "options", "rootElement", "eventType", "listener", "elementId", "handlers", "handlersArray", "syntheticEvent", "handler", "error", "count", "index", "sum", "arr", "element", "totalHandlers", "s", "all", "id", "handlerCount", "elementCount"]
}
