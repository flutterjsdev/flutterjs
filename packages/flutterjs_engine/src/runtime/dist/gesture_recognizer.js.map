{
  "version": 3,
  "sources": ["../src/gesture_recognizer.js"],
  "sourcesContent": ["/**\r\n * FlutterJS Gesture Recognizer System\r\n * \r\n * Handles complex gestures like tap, long-press, swipe, pinch, and pan.\r\n * Provides Flutter-style gesture recognition for touch and mouse interactions.\r\n * \r\n * Key Features:\r\n * - Multi-touch support\r\n * - Gesture conflict resolution\r\n * - Customizable thresholds\r\n * - Performance optimized\r\n * - Memory efficient cleanup\r\n */\r\n\r\n/**\r\n * Base Gesture Recognizer\r\n * \r\n * Abstract class that all specific recognizers extend\r\n */\r\nclass GestureRecognizer {\r\n  constructor(callback, options = {}) {\r\n    if (!callback || typeof callback !== 'function') {\r\n      throw new Error('Gesture recognizer requires a callback function');\r\n    }\r\n\r\n    this.callback = callback;\r\n    this.options = options;\r\n    this.state = 'ready'; // ready, possible, recognized, failed\r\n    this.disposed = false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer/touch event\r\n   * Subclasses must implement this\r\n   */\r\n  handleEvent(eventType, event) {\r\n    throw new Error('handleEvent() must be implemented by subclass');\r\n  }\r\n\r\n  /**\r\n   * Reset recognizer state\r\n   */\r\n  reset() {\r\n    this.state = 'ready';\r\n  }\r\n\r\n  /**\r\n   * Mark gesture as recognized\r\n   */\r\n  recognize(event) {\r\n    if (this.disposed) return;\r\n\r\n    // Remove the state === 'recognized' check - allow calling recognize multiple times\r\n    this.state = 'recognized';\r\n\r\n    try {\r\n      this.callback(event);\r\n    } catch (error) {\r\n      console.error('[GestureRecognizer] Callback error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark gesture as failed\r\n   */\r\n  fail() {\r\n    this.state = 'failed';\r\n  }\r\n\r\n  /**\r\n   * Cleanup and dispose\r\n   */\r\n  dispose() {\r\n    this.disposed = true;\r\n    this.callback = null;\r\n    this.options = null;\r\n    this.state = 'ready';\r\n  }\r\n\r\n  /**\r\n   * Check if disposed\r\n   */\r\n  get isDisposed() {\r\n    return this.disposed;\r\n  }\r\n}\r\n\r\n/**\r\n * Tap Gesture Recognizer\r\n * \r\n * Detects simple tap/click gestures\r\n */\r\nclass TapRecognizer extends GestureRecognizer {\r\n  constructor(callback, options = {}) {\r\n    super(callback, options);\r\n\r\n    // Configuration\r\n    this.maxDuration = options.maxDuration || 300; // ms\r\n    this.maxMovement = options.maxMovement || 10; // px\r\n    this.minTaps = options.minTaps || 1;\r\n    this.maxTaps = options.maxTaps || 1;\r\n\r\n    // State\r\n    this.startTime = null;\r\n    this.startX = null;\r\n    this.startY = null;\r\n    this.tapCount = 0;\r\n    this.lastTapTime = 0;\r\n    this.tapTimeout = null;\r\n  }\r\n\r\n  handleEvent(eventType, event) {\r\n    if (this.disposed) return;\r\n\r\n    switch (eventType) {\r\n      case 'pointerdown':\r\n      case 'mousedown':\r\n      case 'touchstart':\r\n        this.handleDown(event);\r\n        break;\r\n\r\n      case 'pointermove':\r\n      case 'mousemove':\r\n      case 'touchmove':\r\n        this.handleMove(event);\r\n        break;\r\n\r\n      case 'pointerup':\r\n      case 'mouseup':\r\n      case 'touchend':\r\n        this.handleUp(event);\r\n        break;\r\n\r\n      case 'pointercancel':\r\n      case 'touchcancel':\r\n        this.handleCancel();\r\n        break;\r\n    }\r\n  }\r\n\r\n  handleDown(event) {\r\n    this.state = 'possible';\r\n    this.startTime = Date.now();\r\n    this.startX = this.getX(event);\r\n    this.startY = this.getY(event);\r\n  }\r\n\r\n  handleMove(event) {\r\n    if (this.state !== 'possible') return;\r\n\r\n    const x = this.getX(event);\r\n    const y = this.getY(event);\r\n\r\n    const dx = Math.abs(x - this.startX);\r\n    const dy = Math.abs(y - this.startY);\r\n    const movement = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Too much movement - fail\r\n    if (movement > this.maxMovement) {\r\n      this.fail();\r\n    }\r\n  }\r\n\r\n  handleUp(event) {\r\n    if (this.state !== 'possible') return;\r\n\r\n    const duration = Date.now() - this.startTime;\r\n    const x = this.getX(event);\r\n    const y = this.getY(event);\r\n\r\n    const dx = Math.abs(x - this.startX);\r\n    const dy = Math.abs(y - this.startY);\r\n    const movement = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Check if valid tap\r\n    if (duration <= this.maxDuration && movement <= this.maxMovement) {\r\n      this.handleTap(event);\r\n    } else {\r\n      this.fail();\r\n    }\r\n\r\n    this.reset();\r\n  }\r\n\r\n  handleTap(event) {\r\n    const now = Date.now();\r\n    const timeSinceLastTap = now - this.lastTapTime;\r\n\r\n    // Check if double/triple tap\r\n    if (timeSinceLastTap < 300) {\r\n      this.tapCount++;\r\n    } else {\r\n      this.tapCount = 1;\r\n    }\r\n\r\n    this.lastTapTime = now;\r\n\r\n    // Clear previous timeout\r\n    if (this.tapTimeout) {\r\n      clearTimeout(this.tapTimeout);\r\n      this.tapTimeout = null;\r\n    }\r\n\r\n    // If we've reached max taps, recognize immediately\r\n    if (this.tapCount >= this.maxTaps) {\r\n      this.recognize({\r\n        type: 'tap',\r\n        tapCount: this.tapCount,\r\n        position: { x: this.startX, y: this.startY },\r\n        nativeEvent: event\r\n      });\r\n      this.tapCount = 0;\r\n    }\r\n    // Otherwise wait for potential additional taps\r\n    else if (this.tapCount >= this.minTaps) {\r\n      this.tapTimeout = setTimeout(() => {\r\n        this.recognize({\r\n          type: 'tap',\r\n          tapCount: this.tapCount,\r\n          position: { x: this.startX, y: this.startY },\r\n          nativeEvent: event\r\n        });\r\n        this.tapCount = 0;\r\n      }, 300);\r\n    }\r\n  }\r\n\r\n  handleCancel() {\r\n    this.fail();\r\n    // Don't call reset() here - it overwrites the 'failed' state\r\n  }\r\n  getX(event) {\r\n    if (event.clientX !== undefined && event.clientX !== 0) {\r\n      return event.clientX;\r\n    }\r\n    if (event.touches && event.touches.length > 0) {\r\n      return event.touches[0].clientX;\r\n    }\r\n    if (event.changedTouches && event.changedTouches.length > 0) {\r\n      return event.changedTouches[0].clientX;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  getY(event) {\r\n    if (event.clientY !== undefined && event.clientY !== 0) {\r\n      return event.clientY;\r\n    }\r\n    if (event.touches && event.touches.length > 0) {\r\n      return event.touches[0].clientY;\r\n    }\r\n    if (event.changedTouches && event.changedTouches.length > 0) {\r\n      return event.changedTouches[0].clientY;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  dispose() {\r\n    if (this.tapTimeout) {\r\n      clearTimeout(this.tapTimeout);\r\n      this.tapTimeout = null;\r\n    }\r\n    super.dispose();\r\n  }\r\n}\r\n\r\n/**\r\n * Long Press Gesture Recognizer\r\n * \r\n * Detects long press / hold gestures\r\n */\r\nclass LongPressRecognizer extends GestureRecognizer {\r\n  constructor(callback, options = {}) {\r\n    super(callback, options);\r\n\r\n    // Configuration\r\n    this.duration = options.duration || 500; // ms\r\n    this.maxMovement = options.maxMovement || 10; // px\r\n\r\n    // State\r\n    this.timer = null;\r\n    this.startX = null;\r\n    this.startY = null;\r\n    this.recognized = false;\r\n  }\r\n\r\n  handleEvent(eventType, event) {\r\n    if (this.disposed) return;\r\n\r\n    switch (eventType) {\r\n      case 'pointerdown':\r\n      case 'mousedown':\r\n      case 'touchstart':\r\n        this.handleDown(event);\r\n        break;\r\n\r\n      case 'pointermove':\r\n      case 'mousemove':\r\n      case 'touchmove':\r\n        this.handleMove(event);\r\n        break;\r\n\r\n      case 'pointerup':\r\n      case 'mouseup':\r\n      case 'touchend':\r\n      case 'pointercancel':\r\n      case 'touchcancel':\r\n        this.handleEnd(event);\r\n        break;\r\n    }\r\n  }\r\n\r\n  handleDown(event) {\r\n    this.state = 'possible';\r\n    this.startX = this.getX(event);\r\n    this.startY = this.getY(event);\r\n    this.recognized = false;\r\n\r\n    // Start timer\r\n    this.timer = setTimeout(() => {\r\n      if (this.state === 'possible') {\r\n        this.recognized = true;\r\n        this.recognize({\r\n          type: 'longpress',\r\n          position: { x: this.startX, y: this.startY },\r\n          nativeEvent: event\r\n        });\r\n      }\r\n      this.timer = null;\r\n    }, this.duration);\r\n  }\r\n\r\n  handleMove(event) {\r\n    if (this.state !== 'possible' || this.recognized) return;\r\n\r\n    const x = this.getX(event);\r\n    const y = this.getY(event);\r\n\r\n    const dx = Math.abs(x - this.startX);\r\n    const dy = Math.abs(y - this.startY);\r\n    const movement = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Too much movement - cancel\r\n    if (movement > this.maxMovement) {\r\n      this.cancel();\r\n    }\r\n  }\r\n\r\n  handleEnd(event) {\r\n    this.cancel();\r\n    this.reset();\r\n  }\r\n\r\n  cancel() {\r\n    if (this.timer) {\r\n      clearTimeout(this.timer);\r\n      this.timer = null;\r\n    }\r\n    this.fail();\r\n  }\r\n\r\n  getX(event) {\r\n    return event.clientX || event.touches?.[0]?.clientX || 0;\r\n  }\r\n\r\n  getY(event) {\r\n    return event.clientY || event.touches?.[0]?.clientY || 0;\r\n  }\r\n\r\n  dispose() {\r\n    this.cancel();\r\n    super.dispose();\r\n  }\r\n}\r\n\r\n/**\r\n * Swipe Gesture Recognizer\r\n * \r\n * Detects directional swipe gestures\r\n */\r\nclass SwipeRecognizer extends GestureRecognizer {\r\n  constructor(callback, options = {}) {\r\n    super(callback, options);\r\n\r\n    // Configuration\r\n    this.minDistance = options.minDistance || 50; // px\r\n    this.maxDuration = options.maxDuration || 300; // ms\r\n    this.direction = options.direction || null; // 'horizontal', 'vertical', null (any)\r\n\r\n    // State\r\n    this.startTime = null;\r\n    this.startX = null;\r\n    this.startY = null;\r\n  }\r\n\r\n  handleEvent(eventType, event) {\r\n    if (this.disposed) return;\r\n\r\n    switch (eventType) {\r\n      case 'pointerdown':\r\n      case 'mousedown':\r\n      case 'touchstart':\r\n        this.handleDown(event);\r\n        break;\r\n\r\n      case 'pointerup':\r\n      case 'mouseup':\r\n      case 'touchend':\r\n        this.handleUp(event);\r\n        break;\r\n\r\n      case 'pointercancel':\r\n      case 'touchcancel':\r\n        this.handleCancel();\r\n        break;\r\n    }\r\n  }\r\n\r\n  handleDown(event) {\r\n    this.state = 'possible';\r\n    this.startTime = Date.now();\r\n    this.startX = this.getX(event);\r\n    this.startY = this.getY(event);\r\n  }\r\n\r\n  handleUp(event) {\r\n    if (this.state !== 'possible') return;\r\n\r\n    const duration = Date.now() - this.startTime;\r\n    const endX = this.getX(event);\r\n    const endY = this.getY(event);\r\n\r\n    const dx = endX - this.startX;\r\n    const dy = endY - this.startY;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Check if valid swipe\r\n    if (duration <= this.maxDuration && distance >= this.minDistance) {\r\n      const swipeDirection = this.getDirection(dx, dy);\r\n\r\n      // Check direction constraint\r\n      if (this.direction === 'horizontal' &&\r\n        (swipeDirection === 'up' || swipeDirection === 'down')) {\r\n        this.fail();\r\n        this.reset();\r\n        return;\r\n      }\r\n\r\n      if (this.direction === 'vertical' &&\r\n        (swipeDirection === 'left' || swipeDirection === 'right')) {\r\n        this.fail();\r\n        this.reset();\r\n        return;\r\n      }\r\n\r\n      this.recognize({\r\n        type: 'swipe',\r\n        direction: swipeDirection,\r\n        distance: distance,\r\n        velocity: distance / duration, // px/ms\r\n        delta: { dx, dy },\r\n        start: { x: this.startX, y: this.startY },\r\n        end: { x: endX, y: endY },\r\n        nativeEvent: event\r\n      });\r\n    } else {\r\n      this.fail();\r\n    }\r\n\r\n    this.reset();\r\n  }\r\n\r\n  handleCancel() {\r\n    this.fail();\r\n    this.reset();\r\n  }\r\n\r\n  getDirection(dx, dy) {\r\n    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\r\n\r\n    // Determine primary direction\r\n    if (angle >= -45 && angle < 45) return 'right';\r\n    if (angle >= 45 && angle < 135) return 'down';\r\n    if (angle >= -135 && angle < -45) return 'up';\r\n    return 'left';\r\n  }\r\n\r\n  getX(event) {\r\n    if (event.clientX !== undefined && event.clientX !== 0) {\r\n      return event.clientX;\r\n    }\r\n    if (event.touches && event.touches.length > 0) {\r\n      return event.touches[0].clientX;\r\n    }\r\n    if (event.changedTouches && event.changedTouches.length > 0) {\r\n      return event.changedTouches[0].clientX;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  getY(event) {\r\n    if (event.clientY !== undefined && event.clientY !== 0) {\r\n      return event.clientY;\r\n    }\r\n    if (event.touches && event.touches.length > 0) {\r\n      return event.touches[0].clientY;\r\n    }\r\n    if (event.changedTouches && event.changedTouches.length > 0) {\r\n      return event.changedTouches[0].clientY;\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Pan Gesture Recognizer\r\n * \r\n * Detects continuous drag/pan gestures\r\n */\r\nclass PanRecognizer extends GestureRecognizer {\r\n  constructor(callback, options = {}) {\r\n    super(callback, options);\r\n\r\n    // Configuration\r\n    this.minDistance = options.minDistance || 10; // px to start\r\n    this.direction = options.direction || null; // 'horizontal', 'vertical', null\r\n\r\n    // State\r\n    this.startX = null;\r\n    this.startY = null;\r\n    this.lastX = null;\r\n    this.lastY = null;\r\n    this.isPanning = false;\r\n\r\n    // Callbacks\r\n    this.onStart = options.onStart || null;\r\n    this.onUpdate = options.onUpdate || null;\r\n    this.onEnd = options.onEnd || null;\r\n  }\r\n\r\n  handleEvent(eventType, event) {\r\n    if (this.disposed) return;\r\n\r\n    switch (eventType) {\r\n      case 'pointerdown':\r\n      case 'mousedown':\r\n      case 'touchstart':\r\n        this.handleDown(event);\r\n        break;\r\n\r\n      case 'pointermove':\r\n      case 'mousemove':\r\n      case 'touchmove':\r\n        this.handleMove(event);\r\n        break;\r\n\r\n      case 'pointerup':\r\n      case 'mouseup':\r\n      case 'touchend':\r\n        this.handleUp(event);\r\n        break;\r\n\r\n      case 'pointercancel':\r\n      case 'touchcancel':\r\n        this.handleCancel();\r\n        break;\r\n    }\r\n  }\r\n\r\n  handleDown(event) {\r\n    this.state = 'possible';\r\n    this.startX = this.getX(event);\r\n    this.startY = this.getY(event);\r\n    this.lastX = this.startX;\r\n    this.lastY = this.startY;\r\n    this.isPanning = false;\r\n  }\r\n\r\n  handleMove(event) {\r\n    if (this.state === 'failed') return;\r\n\r\n    const x = this.getX(event);\r\n    const y = this.getY(event);\r\n\r\n    const dx = x - this.startX;\r\n    const dy = y - this.startY;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Check if pan started\r\n    if (!this.isPanning && distance >= this.minDistance) {\r\n      // Check direction constraint\r\n      if (this.direction === 'horizontal' && Math.abs(dy) > Math.abs(dx)) {\r\n        this.fail();\r\n        return;\r\n      }\r\n\r\n      if (this.direction === 'vertical' && Math.abs(dx) > Math.abs(dy)) {\r\n        this.fail();\r\n        return;\r\n      }\r\n\r\n      this.isPanning = true;\r\n      this.state = 'recognized';\r\n\r\n      // Call onStart\r\n      if (this.onStart) {\r\n        try {\r\n          this.onStart({\r\n            type: 'panstart',\r\n            position: { x, y },\r\n            nativeEvent: event\r\n          });\r\n        } catch (error) {\r\n          console.error('[PanRecognizer] onStart error:', error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update during pan\r\n    if (this.isPanning) {\r\n      const deltaX = x - this.lastX;\r\n      const deltaY = y - this.lastY;\r\n\r\n      this.lastX = x;\r\n      this.lastY = y;\r\n\r\n      // Call onUpdate\r\n      if (this.onUpdate) {\r\n        try {\r\n          this.onUpdate({\r\n            type: 'panupdate',\r\n            position: { x, y },\r\n            delta: { dx: deltaX, dy: deltaY },\r\n            totalDelta: { dx, dy },\r\n            nativeEvent: event\r\n          });\r\n        } catch (error) {\r\n          console.error('[PanRecognizer] onUpdate error:', error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleUp(event) {\r\n    if (this.isPanning) {\r\n      const x = this.getX(event);\r\n      const y = this.getY(event);\r\n\r\n      const dx = x - this.startX;\r\n      const dy = y - this.startY;\r\n\r\n      // Call onEnd first\r\n      if (this.onEnd) {\r\n        try {\r\n          this.onEnd({\r\n            type: 'panend',\r\n            position: { x, y },\r\n            totalDelta: { dx, dy },\r\n            nativeEvent: event\r\n          });\r\n        } catch (error) {\r\n          console.error('[PanRecognizer] onEnd error:', error);\r\n        }\r\n      }\r\n\r\n      // Then call main callback via recognize()\r\n      this.recognize({\r\n        type: 'pan',\r\n        start: { x: this.startX, y: this.startY },\r\n        end: { x, y },\r\n        delta: { dx, dy },\r\n        nativeEvent: event\r\n      });\r\n    }\r\n\r\n    this.reset();\r\n    this.isPanning = false;\r\n  }\r\n  handleCancel() {\r\n    if (this.isPanning && this.onEnd) {\r\n      try {\r\n        this.onEnd({\r\n          type: 'pancancel',\r\n          position: { x: this.lastX, y: this.lastY }\r\n        });\r\n      } catch (error) {\r\n        console.error('[PanRecognizer] onEnd (cancel) error:', error);\r\n      }\r\n    }\r\n\r\n    this.fail();\r\n    this.reset();\r\n    this.isPanning = false;\r\n  }\r\n\r\n  getX(event) {\r\n    return event.clientX || event.touches?.[0]?.clientX || 0;\r\n  }\r\n\r\n  getY(event) {\r\n    return event.clientY || event.touches?.[0]?.clientY || 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Scale (Pinch) Gesture Recognizer\r\n * \r\n * Detects pinch-to-zoom gestures (two-finger)\r\n */\r\nclass ScaleRecognizer extends GestureRecognizer {\r\n  constructor(callback, options = {}) {\r\n    super(callback, options);\r\n\r\n    // Configuration\r\n    this.minScale = options.minScale || 0.5;\r\n    this.maxScale = options.maxScale || 2.0;\r\n\r\n    // State\r\n    this.initialDistance = null;\r\n    this.currentDistance = null;\r\n    this.isScaling = false;\r\n\r\n    // Callbacks\r\n    this.onStart = options.onStart || null;\r\n    this.onUpdate = options.onUpdate || null;\r\n    this.onEnd = options.onEnd || null;\r\n  }\r\n\r\n  handleEvent(eventType, event) {\r\n    if (this.disposed) return;\r\n\r\n    // Only handle touch events (requires 2 touches)\r\n    if (!event.touches || event.touches.length < 2) {\r\n      if (this.isScaling) {\r\n        this.handleEnd(event);\r\n      }\r\n      return;\r\n    }\r\n\r\n    switch (eventType) {\r\n      case 'touchstart':\r\n        this.handleStart(event);\r\n        break;\r\n\r\n      case 'touchmove':\r\n        this.handleMove(event);\r\n        break;\r\n\r\n      case 'touchend':\r\n      case 'touchcancel':\r\n        this.handleEnd(event);\r\n        break;\r\n    }\r\n  }\r\n\r\n  handleStart(event) {\r\n    if (event.touches.length !== 2) return;\r\n\r\n    this.state = 'possible';\r\n    this.initialDistance = this.getDistance(event.touches[0], event.touches[1]);\r\n    this.currentDistance = this.initialDistance;\r\n    this.isScaling = true;\r\n\r\n    // Call onStart\r\n    if (this.onStart) {\r\n      try {\r\n        this.onStart({\r\n          type: 'scalestart',\r\n          scale: 1.0,\r\n          nativeEvent: event\r\n        });\r\n      } catch (error) {\r\n        console.error('[ScaleRecognizer] onStart error:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMove(event) {\r\n    if (!this.isScaling || event.touches.length !== 2) return;\r\n\r\n    this.state = 'recognized';\r\n\r\n    const distance = this.getDistance(event.touches[0], event.touches[1]);\r\n    this.currentDistance = distance;\r\n\r\n    const scale = distance / this.initialDistance;\r\n\r\n    // Clamp scale\r\n    const clampedScale = Math.max(this.minScale, Math.min(this.maxScale, scale));\r\n\r\n    // Call onUpdate\r\n    if (this.onUpdate) {\r\n      try {\r\n        this.onUpdate({\r\n          type: 'scaleupdate',\r\n          scale: clampedScale,\r\n          rawScale: scale,\r\n          nativeEvent: event\r\n        });\r\n      } catch (error) {\r\n        console.error('[ScaleRecognizer] onUpdate error:', error);\r\n      }\r\n    }\r\n  }\r\n  handleEnd(event) {\r\n    if (!this.isScaling) return;\r\n\r\n    const scale = this.currentDistance / this.initialDistance;\r\n    const clampedScale = Math.max(this.minScale, Math.min(this.maxScale, scale));\r\n\r\n    // Call onEnd first\r\n    if (this.onEnd) {\r\n      try {\r\n        this.onEnd({\r\n          type: 'scaleend',\r\n          scale: clampedScale,\r\n          rawScale: scale,\r\n          nativeEvent: event\r\n        });\r\n      } catch (error) {\r\n        console.error('[ScaleRecognizer] onEnd error:', error);\r\n      }\r\n    }\r\n\r\n    // Then call main callback via recognize()\r\n    this.recognize({\r\n      type: 'scale',\r\n      scale: clampedScale,\r\n      rawScale: scale,\r\n      nativeEvent: event\r\n    });\r\n\r\n    this.reset();\r\n    this.isScaling = false;\r\n    this.initialDistance = null;\r\n    this.currentDistance = null;\r\n  }\r\n\r\n  getDistance(touch1, touch2) {\r\n    const dx = touch2.clientX - touch1.clientX;\r\n    const dy = touch2.clientY - touch1.clientY;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n}\r\n\r\n/**\r\n * Gesture Arena\r\n * \r\n * Manages multiple gesture recognizers and resolves conflicts\r\n */\r\nclass GestureArena {\r\n  constructor() {\r\n    this.recognizers = new Map(); // elementId -> recognizer[]\r\n  }\r\n\r\n  /**\r\n   * Register recognizer for element\r\n   */\r\n  register(elementId, recognizer) {\r\n    if (!this.recognizers.has(elementId)) {\r\n      this.recognizers.set(elementId, []);\r\n    }\r\n\r\n    this.recognizers.get(elementId).push(recognizer);\r\n  }\r\n\r\n  /**\r\n   * Unregister all recognizers for element\r\n   */\r\n  unregister(elementId) {\r\n    const recognizers = this.recognizers.get(elementId);\r\n    if (recognizers) {\r\n      recognizers.forEach(r => r.dispose());\r\n      this.recognizers.delete(elementId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle event for element\r\n   */\r\n  handleEvent(elementId, eventType, event) {\r\n    const recognizers = this.recognizers.get(elementId);\r\n    if (!recognizers) return;\r\n\r\n    // Pass event to all active recognizers\r\n    recognizers.forEach(recognizer => {\r\n      if (!recognizer.isDisposed && recognizer.state !== 'failed') {\r\n        recognizer.handleEvent(eventType, event);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get recognizers for element\r\n   */\r\n  getRecognizers(elementId) {\r\n    return this.recognizers.get(elementId) || [];\r\n  }\r\n\r\n  /**\r\n   * Clear all recognizers\r\n   */\r\n  clear() {\r\n    this.recognizers.forEach((recognizers) => {\r\n      recognizers.forEach(r => r.dispose());\r\n    });\r\n    this.recognizers.clear();\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  getStats() {\r\n    let totalRecognizers = 0;\r\n    this.recognizers.forEach(recognizers => {\r\n      totalRecognizers += recognizers.length;\r\n    });\r\n\r\n    return {\r\n      elements: this.recognizers.size,\r\n      totalRecognizers: totalRecognizers\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Main Gesture Manager\r\n * \r\n * Central system for managing all gestures in the application\r\n */\r\nclass GestureManager {\r\n  constructor() {\r\n    this.arena = new GestureArena();\r\n  }\r\n\r\n  /**\r\n   * Register tap gesture\r\n   */\r\n  registerTap(elementId, callback, options = {}) {\r\n    const recognizer = new TapRecognizer(callback, options);\r\n    this.arena.register(elementId, recognizer);\r\n    return recognizer;\r\n  }\r\n\r\n  /**\r\n   * Register double tap gesture\r\n   */\r\n  registerDoubleTap(elementId, callback, options = {}) {\r\n    const recognizer = new TapRecognizer(callback, {\r\n      ...options,\r\n      minTaps: 2,\r\n      maxTaps: 2\r\n    });\r\n    this.arena.register(elementId, recognizer);\r\n    return recognizer;\r\n  }\r\n\r\n  /**\r\n   * Register long press gesture\r\n   */\r\n  registerLongPress(elementId, callback, options = {}) {\r\n    const recognizer = new LongPressRecognizer(callback, options);\r\n    this.arena.register(elementId, recognizer);\r\n    return recognizer;\r\n  }\r\n\r\n  /**\r\n   * Register swipe gesture\r\n   */\r\n  registerSwipe(elementId, callback, options = {}) {\r\n    const recognizer = new SwipeRecognizer(callback, options);\r\n    this.arena.register(elementId, recognizer);\r\n    return recognizer;\r\n  }\r\n\r\n  /**\r\n   * Register pan gesture\r\n   */\r\n  registerPan(elementId, callback, options = {}) {\r\n    const recognizer = new PanRecognizer(callback, options);\r\n    this.arena.register(elementId, recognizer);\r\n    return recognizer;\r\n  }\r\n\r\n  /**\r\n   * Register scale (pinch) gesture\r\n   */\r\n  registerScale(elementId, callback, options = {}) {\r\n    const recognizer = new ScaleRecognizer(callback, options);\r\n    this.arena.register(elementId, recognizer);\r\n    return recognizer;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer/touch event\r\n   */\r\n  handleEvent(elementId, eventType, event) {\r\n    this.arena.handleEvent(elementId, eventType, event);\r\n  }\r\n\r\n  /**\r\n   * Unregister all gestures for element\r\n   */\r\n  unregisterAll(elementId) {\r\n    this.arena.unregister(elementId);\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  getStats() {\r\n    return this.arena.getStats();\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  dispose() {\r\n    this.arena.clear();\r\n  }\r\n}\r\n\r\nexport {\r\n  GestureRecognizer,\r\n  TapRecognizer,\r\n  LongPressRecognizer,\r\n  SwipeRecognizer,\r\n  PanRecognizer,\r\n  ScaleRecognizer,\r\n  GestureArena,\r\n  GestureManager\r\n};"],
  "mappings": "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",
  "names": ["GestureRecognizer", "callback", "options", "eventType", "event", "error", "TapRecognizer", "x", "y", "dx", "dy", "duration", "movement", "now", "LongPressRecognizer", "SwipeRecognizer", "endX", "endY", "distance", "swipeDirection", "angle", "PanRecognizer", "deltaX", "deltaY", "ScaleRecognizer", "scale", "clampedScale", "touch1", "touch2", "GestureArena", "elementId", "recognizer", "recognizers", "r", "totalRecognizers", "GestureManager"]
}
