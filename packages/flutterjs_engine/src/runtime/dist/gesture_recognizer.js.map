{
  "version": 3,
  "sources": ["../src/gesture_recognizer.js"],
  "sourcesContent": ["/**\n * FlutterJS Gesture Recognizer System\n * \n * Handles complex gestures like tap, long-press, swipe, pinch, and pan.\n * Provides Flutter-style gesture recognition for touch and mouse interactions.\n * \n * Key Features:\n * - Multi-touch support\n * - Gesture conflict resolution\n * - Customizable thresholds\n * - Performance optimized\n * - Memory efficient cleanup\n */\n\n/**\n * Base Gesture Recognizer\n * \n * Abstract class that all specific recognizers extend\n */\nclass GestureRecognizer {\n  constructor(callback, options = {}) {\n    if (!callback || typeof callback !== 'function') {\n      throw new Error('Gesture recognizer requires a callback function');\n    }\n\n    this.callback = callback;\n    this.options = options;\n    this.state = 'ready'; // ready, possible, recognized, failed\n    this.disposed = false;\n  }\n\n  /**\n   * Handle pointer/touch event\n   * Subclasses must implement this\n   */\n  handleEvent(eventType, event) {\n    throw new Error('handleEvent() must be implemented by subclass');\n  }\n\n  /**\n   * Reset recognizer state\n   */\n  reset() {\n    this.state = 'ready';\n  }\n\n  /**\n   * Mark gesture as recognized\n   */\n  recognize(event) {\n    if (this.disposed) return;\n\n    // Remove the state === 'recognized' check - allow calling recognize multiple times\n    this.state = 'recognized';\n\n    try {\n      this.callback(event);\n    } catch (error) {\n      console.error('[GestureRecognizer] Callback error:', error);\n    }\n  }\n\n  /**\n   * Mark gesture as failed\n   */\n  fail() {\n    this.state = 'failed';\n  }\n\n  /**\n   * Cleanup and dispose\n   */\n  dispose() {\n    this.disposed = true;\n    this.callback = null;\n    this.options = null;\n    this.state = 'ready';\n  }\n\n  /**\n   * Check if disposed\n   */\n  get isDisposed() {\n    return this.disposed;\n  }\n}\n\n/**\n * Tap Gesture Recognizer\n * \n * Detects simple tap/click gestures\n */\nclass TapRecognizer extends GestureRecognizer {\n  constructor(callback, options = {}) {\n    super(callback, options);\n\n    // Configuration\n    this.maxDuration = options.maxDuration || 300; // ms\n    this.maxMovement = options.maxMovement || 10; // px\n    this.minTaps = options.minTaps || 1;\n    this.maxTaps = options.maxTaps || 1;\n\n    // State\n    this.startTime = null;\n    this.startX = null;\n    this.startY = null;\n    this.tapCount = 0;\n    this.lastTapTime = 0;\n    this.tapTimeout = null;\n  }\n\n  handleEvent(eventType, event) {\n    if (this.disposed) return;\n\n    switch (eventType) {\n      case 'pointerdown':\n      case 'mousedown':\n      case 'touchstart':\n        this.handleDown(event);\n        break;\n\n      case 'pointermove':\n      case 'mousemove':\n      case 'touchmove':\n        this.handleMove(event);\n        break;\n\n      case 'pointerup':\n      case 'mouseup':\n      case 'touchend':\n        this.handleUp(event);\n        break;\n\n      case 'pointercancel':\n      case 'touchcancel':\n        this.handleCancel();\n        break;\n    }\n  }\n\n  handleDown(event) {\n    this.state = 'possible';\n    this.startTime = Date.now();\n    this.startX = this.getX(event);\n    this.startY = this.getY(event);\n  }\n\n  handleMove(event) {\n    if (this.state !== 'possible') return;\n\n    const x = this.getX(event);\n    const y = this.getY(event);\n\n    const dx = Math.abs(x - this.startX);\n    const dy = Math.abs(y - this.startY);\n    const movement = Math.sqrt(dx * dx + dy * dy);\n\n    // Too much movement - fail\n    if (movement > this.maxMovement) {\n      this.fail();\n    }\n  }\n\n  handleUp(event) {\n    if (this.state !== 'possible') return;\n\n    const duration = Date.now() - this.startTime;\n    const x = this.getX(event);\n    const y = this.getY(event);\n\n    const dx = Math.abs(x - this.startX);\n    const dy = Math.abs(y - this.startY);\n    const movement = Math.sqrt(dx * dx + dy * dy);\n\n    // Check if valid tap\n    if (duration <= this.maxDuration && movement <= this.maxMovement) {\n      this.handleTap(event);\n    } else {\n      this.fail();\n    }\n\n    this.reset();\n  }\n\n  handleTap(event) {\n    const now = Date.now();\n    const timeSinceLastTap = now - this.lastTapTime;\n\n    // Check if double/triple tap\n    if (timeSinceLastTap < 300) {\n      this.tapCount++;\n    } else {\n      this.tapCount = 1;\n    }\n\n    this.lastTapTime = now;\n\n    // Clear previous timeout\n    if (this.tapTimeout) {\n      clearTimeout(this.tapTimeout);\n      this.tapTimeout = null;\n    }\n\n    // If we've reached max taps, recognize immediately\n    if (this.tapCount >= this.maxTaps) {\n      this.recognize({\n        type: 'tap',\n        tapCount: this.tapCount,\n        position: { x: this.startX, y: this.startY },\n        nativeEvent: event\n      });\n      this.tapCount = 0;\n    }\n    // Otherwise wait for potential additional taps\n    else if (this.tapCount >= this.minTaps) {\n      this.tapTimeout = setTimeout(() => {\n        this.recognize({\n          type: 'tap',\n          tapCount: this.tapCount,\n          position: { x: this.startX, y: this.startY },\n          nativeEvent: event\n        });\n        this.tapCount = 0;\n      }, 300);\n    }\n  }\n\n  handleCancel() {\n    this.fail();\n    // Don't call reset() here - it overwrites the 'failed' state\n  }\n  getX(event) {\n    if (event.clientX !== undefined && event.clientX !== 0) {\n      return event.clientX;\n    }\n    if (event.touches && event.touches.length > 0) {\n      return event.touches[0].clientX;\n    }\n    if (event.changedTouches && event.changedTouches.length > 0) {\n      return event.changedTouches[0].clientX;\n    }\n    return 0;\n  }\n\n  getY(event) {\n    if (event.clientY !== undefined && event.clientY !== 0) {\n      return event.clientY;\n    }\n    if (event.touches && event.touches.length > 0) {\n      return event.touches[0].clientY;\n    }\n    if (event.changedTouches && event.changedTouches.length > 0) {\n      return event.changedTouches[0].clientY;\n    }\n    return 0;\n  }\n\n  dispose() {\n    if (this.tapTimeout) {\n      clearTimeout(this.tapTimeout);\n      this.tapTimeout = null;\n    }\n    super.dispose();\n  }\n}\n\n/**\n * Long Press Gesture Recognizer\n * \n * Detects long press / hold gestures\n */\nclass LongPressRecognizer extends GestureRecognizer {\n  constructor(callback, options = {}) {\n    super(callback, options);\n\n    // Configuration\n    this.duration = options.duration || 500; // ms\n    this.maxMovement = options.maxMovement || 10; // px\n\n    // State\n    this.timer = null;\n    this.startX = null;\n    this.startY = null;\n    this.recognized = false;\n  }\n\n  handleEvent(eventType, event) {\n    if (this.disposed) return;\n\n    switch (eventType) {\n      case 'pointerdown':\n      case 'mousedown':\n      case 'touchstart':\n        this.handleDown(event);\n        break;\n\n      case 'pointermove':\n      case 'mousemove':\n      case 'touchmove':\n        this.handleMove(event);\n        break;\n\n      case 'pointerup':\n      case 'mouseup':\n      case 'touchend':\n      case 'pointercancel':\n      case 'touchcancel':\n        this.handleEnd(event);\n        break;\n    }\n  }\n\n  handleDown(event) {\n    this.state = 'possible';\n    this.startX = this.getX(event);\n    this.startY = this.getY(event);\n    this.recognized = false;\n\n    // Start timer\n    this.timer = setTimeout(() => {\n      if (this.state === 'possible') {\n        this.recognized = true;\n        this.recognize({\n          type: 'longpress',\n          position: { x: this.startX, y: this.startY },\n          nativeEvent: event\n        });\n      }\n      this.timer = null;\n    }, this.duration);\n  }\n\n  handleMove(event) {\n    if (this.state !== 'possible' || this.recognized) return;\n\n    const x = this.getX(event);\n    const y = this.getY(event);\n\n    const dx = Math.abs(x - this.startX);\n    const dy = Math.abs(y - this.startY);\n    const movement = Math.sqrt(dx * dx + dy * dy);\n\n    // Too much movement - cancel\n    if (movement > this.maxMovement) {\n      this.cancel();\n    }\n  }\n\n  handleEnd(event) {\n    this.cancel();\n    this.reset();\n  }\n\n  cancel() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    this.fail();\n  }\n\n  getX(event) {\n    return event.clientX || event.touches?.[0]?.clientX || 0;\n  }\n\n  getY(event) {\n    return event.clientY || event.touches?.[0]?.clientY || 0;\n  }\n\n  dispose() {\n    this.cancel();\n    super.dispose();\n  }\n}\n\n/**\n * Swipe Gesture Recognizer\n * \n * Detects directional swipe gestures\n */\nclass SwipeRecognizer extends GestureRecognizer {\n  constructor(callback, options = {}) {\n    super(callback, options);\n\n    // Configuration\n    this.minDistance = options.minDistance || 50; // px\n    this.maxDuration = options.maxDuration || 300; // ms\n    this.direction = options.direction || null; // 'horizontal', 'vertical', null (any)\n\n    // State\n    this.startTime = null;\n    this.startX = null;\n    this.startY = null;\n  }\n\n  handleEvent(eventType, event) {\n    if (this.disposed) return;\n\n    switch (eventType) {\n      case 'pointerdown':\n      case 'mousedown':\n      case 'touchstart':\n        this.handleDown(event);\n        break;\n\n      case 'pointerup':\n      case 'mouseup':\n      case 'touchend':\n        this.handleUp(event);\n        break;\n\n      case 'pointercancel':\n      case 'touchcancel':\n        this.handleCancel();\n        break;\n    }\n  }\n\n  handleDown(event) {\n    this.state = 'possible';\n    this.startTime = Date.now();\n    this.startX = this.getX(event);\n    this.startY = this.getY(event);\n  }\n\n  handleUp(event) {\n    if (this.state !== 'possible') return;\n\n    const duration = Date.now() - this.startTime;\n    const endX = this.getX(event);\n    const endY = this.getY(event);\n\n    const dx = endX - this.startX;\n    const dy = endY - this.startY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Check if valid swipe\n    if (duration <= this.maxDuration && distance >= this.minDistance) {\n      const swipeDirection = this.getDirection(dx, dy);\n\n      // Check direction constraint\n      if (this.direction === 'horizontal' &&\n        (swipeDirection === 'up' || swipeDirection === 'down')) {\n        this.fail();\n        this.reset();\n        return;\n      }\n\n      if (this.direction === 'vertical' &&\n        (swipeDirection === 'left' || swipeDirection === 'right')) {\n        this.fail();\n        this.reset();\n        return;\n      }\n\n      this.recognize({\n        type: 'swipe',\n        direction: swipeDirection,\n        distance: distance,\n        velocity: distance / duration, // px/ms\n        delta: { dx, dy },\n        start: { x: this.startX, y: this.startY },\n        end: { x: endX, y: endY },\n        nativeEvent: event\n      });\n    } else {\n      this.fail();\n    }\n\n    this.reset();\n  }\n\n  handleCancel() {\n    this.fail();\n    this.reset();\n  }\n\n  getDirection(dx, dy) {\n    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n\n    // Determine primary direction\n    if (angle >= -45 && angle < 45) return 'right';\n    if (angle >= 45 && angle < 135) return 'down';\n    if (angle >= -135 && angle < -45) return 'up';\n    return 'left';\n  }\n\n  getX(event) {\n    if (event.clientX !== undefined && event.clientX !== 0) {\n      return event.clientX;\n    }\n    if (event.touches && event.touches.length > 0) {\n      return event.touches[0].clientX;\n    }\n    if (event.changedTouches && event.changedTouches.length > 0) {\n      return event.changedTouches[0].clientX;\n    }\n    return 0;\n  }\n\n  getY(event) {\n    if (event.clientY !== undefined && event.clientY !== 0) {\n      return event.clientY;\n    }\n    if (event.touches && event.touches.length > 0) {\n      return event.touches[0].clientY;\n    }\n    if (event.changedTouches && event.changedTouches.length > 0) {\n      return event.changedTouches[0].clientY;\n    }\n    return 0;\n  }\n}\n\n/**\n * Pan Gesture Recognizer\n * \n * Detects continuous drag/pan gestures\n */\nclass PanRecognizer extends GestureRecognizer {\n  constructor(callback, options = {}) {\n    super(callback, options);\n\n    // Configuration\n    this.minDistance = options.minDistance || 10; // px to start\n    this.direction = options.direction || null; // 'horizontal', 'vertical', null\n\n    // State\n    this.startX = null;\n    this.startY = null;\n    this.lastX = null;\n    this.lastY = null;\n    this.isPanning = false;\n\n    // Callbacks\n    this.onStart = options.onStart || null;\n    this.onUpdate = options.onUpdate || null;\n    this.onEnd = options.onEnd || null;\n  }\n\n  handleEvent(eventType, event) {\n    if (this.disposed) return;\n\n    switch (eventType) {\n      case 'pointerdown':\n      case 'mousedown':\n      case 'touchstart':\n        this.handleDown(event);\n        break;\n\n      case 'pointermove':\n      case 'mousemove':\n      case 'touchmove':\n        this.handleMove(event);\n        break;\n\n      case 'pointerup':\n      case 'mouseup':\n      case 'touchend':\n        this.handleUp(event);\n        break;\n\n      case 'pointercancel':\n      case 'touchcancel':\n        this.handleCancel();\n        break;\n    }\n  }\n\n  handleDown(event) {\n    this.state = 'possible';\n    this.startX = this.getX(event);\n    this.startY = this.getY(event);\n    this.lastX = this.startX;\n    this.lastY = this.startY;\n    this.isPanning = false;\n  }\n\n  handleMove(event) {\n    if (this.state === 'failed') return;\n\n    const x = this.getX(event);\n    const y = this.getY(event);\n\n    const dx = x - this.startX;\n    const dy = y - this.startY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Check if pan started\n    if (!this.isPanning && distance >= this.minDistance) {\n      // Check direction constraint\n      if (this.direction === 'horizontal' && Math.abs(dy) > Math.abs(dx)) {\n        this.fail();\n        return;\n      }\n\n      if (this.direction === 'vertical' && Math.abs(dx) > Math.abs(dy)) {\n        this.fail();\n        return;\n      }\n\n      this.isPanning = true;\n      this.state = 'recognized';\n\n      // Call onStart\n      if (this.onStart) {\n        try {\n          this.onStart({\n            type: 'panstart',\n            position: { x, y },\n            nativeEvent: event\n          });\n        } catch (error) {\n          console.error('[PanRecognizer] onStart error:', error);\n        }\n      }\n    }\n\n    // Update during pan\n    if (this.isPanning) {\n      const deltaX = x - this.lastX;\n      const deltaY = y - this.lastY;\n\n      this.lastX = x;\n      this.lastY = y;\n\n      // Call onUpdate\n      if (this.onUpdate) {\n        try {\n          this.onUpdate({\n            type: 'panupdate',\n            position: { x, y },\n            delta: { dx: deltaX, dy: deltaY },\n            totalDelta: { dx, dy },\n            nativeEvent: event\n          });\n        } catch (error) {\n          console.error('[PanRecognizer] onUpdate error:', error);\n        }\n      }\n    }\n  }\n\n  handleUp(event) {\n    if (this.isPanning) {\n      const x = this.getX(event);\n      const y = this.getY(event);\n\n      const dx = x - this.startX;\n      const dy = y - this.startY;\n\n      // Call onEnd first\n      if (this.onEnd) {\n        try {\n          this.onEnd({\n            type: 'panend',\n            position: { x, y },\n            totalDelta: { dx, dy },\n            nativeEvent: event\n          });\n        } catch (error) {\n          console.error('[PanRecognizer] onEnd error:', error);\n        }\n      }\n\n      // Then call main callback via recognize()\n      this.recognize({\n        type: 'pan',\n        start: { x: this.startX, y: this.startY },\n        end: { x, y },\n        delta: { dx, dy },\n        nativeEvent: event\n      });\n    }\n\n    this.reset();\n    this.isPanning = false;\n  }\n  handleCancel() {\n    if (this.isPanning && this.onEnd) {\n      try {\n        this.onEnd({\n          type: 'pancancel',\n          position: { x: this.lastX, y: this.lastY }\n        });\n      } catch (error) {\n        console.error('[PanRecognizer] onEnd (cancel) error:', error);\n      }\n    }\n\n    this.fail();\n    this.reset();\n    this.isPanning = false;\n  }\n\n  getX(event) {\n    return event.clientX || event.touches?.[0]?.clientX || 0;\n  }\n\n  getY(event) {\n    return event.clientY || event.touches?.[0]?.clientY || 0;\n  }\n}\n\n/**\n * Scale (Pinch) Gesture Recognizer\n * \n * Detects pinch-to-zoom gestures (two-finger)\n */\nclass ScaleRecognizer extends GestureRecognizer {\n  constructor(callback, options = {}) {\n    super(callback, options);\n\n    // Configuration\n    this.minScale = options.minScale || 0.5;\n    this.maxScale = options.maxScale || 2.0;\n\n    // State\n    this.initialDistance = null;\n    this.currentDistance = null;\n    this.isScaling = false;\n\n    // Callbacks\n    this.onStart = options.onStart || null;\n    this.onUpdate = options.onUpdate || null;\n    this.onEnd = options.onEnd || null;\n  }\n\n  handleEvent(eventType, event) {\n    if (this.disposed) return;\n\n    // Only handle touch events (requires 2 touches)\n    if (!event.touches || event.touches.length < 2) {\n      if (this.isScaling) {\n        this.handleEnd(event);\n      }\n      return;\n    }\n\n    switch (eventType) {\n      case 'touchstart':\n        this.handleStart(event);\n        break;\n\n      case 'touchmove':\n        this.handleMove(event);\n        break;\n\n      case 'touchend':\n      case 'touchcancel':\n        this.handleEnd(event);\n        break;\n    }\n  }\n\n  handleStart(event) {\n    if (event.touches.length !== 2) return;\n\n    this.state = 'possible';\n    this.initialDistance = this.getDistance(event.touches[0], event.touches[1]);\n    this.currentDistance = this.initialDistance;\n    this.isScaling = true;\n\n    // Call onStart\n    if (this.onStart) {\n      try {\n        this.onStart({\n          type: 'scalestart',\n          scale: 1.0,\n          nativeEvent: event\n        });\n      } catch (error) {\n        console.error('[ScaleRecognizer] onStart error:', error);\n      }\n    }\n  }\n\n  handleMove(event) {\n    if (!this.isScaling || event.touches.length !== 2) return;\n\n    this.state = 'recognized';\n\n    const distance = this.getDistance(event.touches[0], event.touches[1]);\n    this.currentDistance = distance;\n\n    const scale = distance / this.initialDistance;\n\n    // Clamp scale\n    const clampedScale = Math.max(this.minScale, Math.min(this.maxScale, scale));\n\n    // Call onUpdate\n    if (this.onUpdate) {\n      try {\n        this.onUpdate({\n          type: 'scaleupdate',\n          scale: clampedScale,\n          rawScale: scale,\n          nativeEvent: event\n        });\n      } catch (error) {\n        console.error('[ScaleRecognizer] onUpdate error:', error);\n      }\n    }\n  }\n  handleEnd(event) {\n    if (!this.isScaling) return;\n\n    const scale = this.currentDistance / this.initialDistance;\n    const clampedScale = Math.max(this.minScale, Math.min(this.maxScale, scale));\n\n    // Call onEnd first\n    if (this.onEnd) {\n      try {\n        this.onEnd({\n          type: 'scaleend',\n          scale: clampedScale,\n          rawScale: scale,\n          nativeEvent: event\n        });\n      } catch (error) {\n        console.error('[ScaleRecognizer] onEnd error:', error);\n      }\n    }\n\n    // Then call main callback via recognize()\n    this.recognize({\n      type: 'scale',\n      scale: clampedScale,\n      rawScale: scale,\n      nativeEvent: event\n    });\n\n    this.reset();\n    this.isScaling = false;\n    this.initialDistance = null;\n    this.currentDistance = null;\n  }\n\n  getDistance(touch1, touch2) {\n    const dx = touch2.clientX - touch1.clientX;\n    const dy = touch2.clientY - touch1.clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}\n\n/**\n * Gesture Arena\n * \n * Manages multiple gesture recognizers and resolves conflicts\n */\nclass GestureArena {\n  constructor() {\n    this.recognizers = new Map(); // elementId -> recognizer[]\n  }\n\n  /**\n   * Register recognizer for element\n   */\n  register(elementId, recognizer) {\n    if (!this.recognizers.has(elementId)) {\n      this.recognizers.set(elementId, []);\n    }\n\n    this.recognizers.get(elementId).push(recognizer);\n  }\n\n  /**\n   * Unregister all recognizers for element\n   */\n  unregister(elementId) {\n    const recognizers = this.recognizers.get(elementId);\n    if (recognizers) {\n      recognizers.forEach(r => r.dispose());\n      this.recognizers.delete(elementId);\n    }\n  }\n\n  /**\n   * Handle event for element\n   */\n  handleEvent(elementId, eventType, event) {\n    const recognizers = this.recognizers.get(elementId);\n    if (!recognizers) return;\n\n    // Pass event to all active recognizers\n    recognizers.forEach(recognizer => {\n      if (!recognizer.isDisposed && recognizer.state !== 'failed') {\n        recognizer.handleEvent(eventType, event);\n      }\n    });\n  }\n\n  /**\n   * Get recognizers for element\n   */\n  getRecognizers(elementId) {\n    return this.recognizers.get(elementId) || [];\n  }\n\n  /**\n   * Clear all recognizers\n   */\n  clear() {\n    this.recognizers.forEach((recognizers) => {\n      recognizers.forEach(r => r.dispose());\n    });\n    this.recognizers.clear();\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    let totalRecognizers = 0;\n    this.recognizers.forEach(recognizers => {\n      totalRecognizers += recognizers.length;\n    });\n\n    return {\n      elements: this.recognizers.size,\n      totalRecognizers: totalRecognizers\n    };\n  }\n}\n\n/**\n * Main Gesture Manager\n * \n * Central system for managing all gestures in the application\n */\nclass GestureManager {\n  constructor() {\n    this.arena = new GestureArena();\n  }\n\n  /**\n   * Register tap gesture\n   */\n  registerTap(elementId, callback, options = {}) {\n    const recognizer = new TapRecognizer(callback, options);\n    this.arena.register(elementId, recognizer);\n    return recognizer;\n  }\n\n  /**\n   * Register double tap gesture\n   */\n  registerDoubleTap(elementId, callback, options = {}) {\n    const recognizer = new TapRecognizer(callback, {\n      ...options,\n      minTaps: 2,\n      maxTaps: 2\n    });\n    this.arena.register(elementId, recognizer);\n    return recognizer;\n  }\n\n  /**\n   * Register long press gesture\n   */\n  registerLongPress(elementId, callback, options = {}) {\n    const recognizer = new LongPressRecognizer(callback, options);\n    this.arena.register(elementId, recognizer);\n    return recognizer;\n  }\n\n  /**\n   * Register swipe gesture\n   */\n  registerSwipe(elementId, callback, options = {}) {\n    const recognizer = new SwipeRecognizer(callback, options);\n    this.arena.register(elementId, recognizer);\n    return recognizer;\n  }\n\n  /**\n   * Register pan gesture\n   */\n  registerPan(elementId, callback, options = {}) {\n    const recognizer = new PanRecognizer(callback, options);\n    this.arena.register(elementId, recognizer);\n    return recognizer;\n  }\n\n  /**\n   * Register scale (pinch) gesture\n   */\n  registerScale(elementId, callback, options = {}) {\n    const recognizer = new ScaleRecognizer(callback, options);\n    this.arena.register(elementId, recognizer);\n    return recognizer;\n  }\n\n  /**\n   * Handle pointer/touch event\n   */\n  handleEvent(elementId, eventType, event) {\n    this.arena.handleEvent(elementId, eventType, event);\n  }\n\n  /**\n   * Unregister all gestures for element\n   */\n  unregisterAll(elementId) {\n    this.arena.unregister(elementId);\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    return this.arena.getStats();\n  }\n\n  /**\n   * Cleanup\n   */\n  dispose() {\n    this.arena.clear();\n  }\n}\n\nexport {\n  GestureRecognizer,\n  TapRecognizer,\n  LongPressRecognizer,\n  SwipeRecognizer,\n  PanRecognizer,\n  ScaleRecognizer,\n  GestureArena,\n  GestureManager\n};"],
  "mappings": "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",
  "names": ["GestureRecognizer", "callback", "options", "eventType", "event", "error", "TapRecognizer", "x", "y", "dx", "dy", "duration", "movement", "now", "LongPressRecognizer", "SwipeRecognizer", "endX", "endY", "distance", "swipeDirection", "angle", "PanRecognizer", "deltaX", "deltaY", "ScaleRecognizer", "scale", "clampedScale", "touch1", "touch2", "GestureArena", "elementId", "recognizer", "recognizers", "r", "totalRecognizers", "GestureManager"]
}
