class o{constructor(t){if(!t)throw new Error("Runtime instance is required for UpdateBatcher");this.runtime=t,this.pendingUpdates=new Map,this.updateScheduled=!1,this.config={enableBatching:!0,flushOnMicrotask:!0,maxBatchSize:100,debugMode:!1},this.stats={totalBatches:0,totalUpdates:0,updatesInLastBatch:0,averageUpdatesPerBatch:0,batchesSinceStart:0,largestBatchSize:0,flushScheduledCount:0},this.lastFlushTime=0,this.lastFlushDuration=0}queueUpdate(t,e){if(!t)throw new Error("Element is required for queueUpdate");if(typeof e!="function")throw new Error("Update function must be a function");if(!this.config.enableBatching){try{e.call(t.state)}catch(i){console.error("[UpdateBatcher] Immediate update failed:",i)}t.markNeedsBuild();return}this.pendingUpdates.has(t)||this.pendingUpdates.set(t,[]);const s=this.pendingUpdates.get(t);s.length>=this.config.maxBatchSize&&this.config.debugMode&&console.warn(`[UpdateBatcher] Max batch size (${this.config.maxBatchSize}) reached for element ${t.id}`),s.push(e),this.updateScheduled||this.scheduleFlush(),this.config.debugMode&&console.log(`[UpdateBatcher] Queued update for ${t.id} (${s.length} pending)`)}scheduleFlush(){this.updateScheduled||(this.updateScheduled=!0,this.stats.flushScheduledCount++,Promise.resolve().then(()=>{this.flush()}),this.config.debugMode&&console.log("[UpdateBatcher] Flush scheduled"))}flush(){if(!this.updateScheduled)return;this.updateScheduled=!1;const t=performance.now();try{const e=Array.from(this.pendingUpdates.entries());if(e.length===0){this.config.debugMode&&console.log("[UpdateBatcher] Flush called but no pending updates");return}let s=0;for(const[a,d]of e){if(!a.mounted){this.config.debugMode&&console.warn(`[UpdateBatcher] Skipping unmounted element ${a.id}`),this.pendingUpdates.delete(a);continue}if(!a.state){this.config.debugMode&&console.warn(`[UpdateBatcher] Skipping element without state: ${a.id}`),this.pendingUpdates.delete(a);continue}for(const h of d)try{h.call(a.state),s++}catch(n){console.error(`[UpdateBatcher] Update function failed for ${a.id}:`,n)}a.dirty||a.markNeedsBuild()}this.pendingUpdates.clear(),this.recordFlush(s,e.length);const i=performance.now()-t;this.lastFlushDuration=i,this.lastFlushTime=Date.now(),this.config.debugMode&&console.log(`[UpdateBatcher] Flushed ${s} updates (${e.length} elements) in ${i.toFixed(2)}ms`),i>16.67&&console.warn(`[UpdateBatcher] Slow flush: ${i.toFixed(2)}ms (${s} updates, ${e.length} elements)`)}catch(e){console.error("[UpdateBatcher] Flush failed:",e)}}recordFlush(t,e){this.stats.totalBatches++,this.stats.batchesSinceStart++,this.stats.totalUpdates+=t,this.stats.updatesInLastBatch=t,t>this.stats.largestBatchSize&&(this.stats.largestBatchSize=t),this.stats.totalBatches>0&&(this.stats.averageUpdatesPerBatch=this.stats.totalUpdates/this.stats.totalBatches)}clear(t){if(t)this.pendingUpdates.delete(t),this.config.debugMode&&console.log(`[UpdateBatcher] Cleared updates for ${t.id}`);else{const e=this.pendingUpdates.size;this.pendingUpdates.clear(),this.config.debugMode&&console.log(`[UpdateBatcher] Cleared all pending updates (${e})`)}}getPendingCount(t){if(t){const s=this.pendingUpdates.get(t);return s?s.length:0}let e=0;return this.pendingUpdates.forEach(s=>{e+=s.length}),e}isScheduled(){return this.updateScheduled}getBatchedElements(){return Array.from(this.pendingUpdates.keys())}forceFlush(){this.config.debugMode&&console.log("[UpdateBatcher] Force flush triggered"),this.flush()}setBatchingEnabled(t){this.config.enableBatching=t,!t&&this.updateScheduled&&this.forceFlush()}setDebugMode(t){this.config.debugMode=t}getStats(){return{...this.stats,pendingElements:this.pendingUpdates.size,totalPendingUpdates:this.getPendingCount(),updateScheduled:this.updateScheduled,lastFlushTime:this.lastFlushTime,lastFlushDuration:this.lastFlushDuration}}getDetailedReport(){const e=this.getBatchedElements().map(s=>({id:s.id,type:s.constructor.name,pendingUpdates:this.getPendingCount(s),mounted:s.mounted,depth:s.depth}));return{stats:this.getStats(),batchedElements:e,config:this.config,timestamp:Date.now()}}resetStats(){this.stats={totalBatches:0,totalUpdates:0,updatesInLastBatch:0,averageUpdatesPerBatch:0,batchesSinceStart:0,largestBatchSize:0,flushScheduledCount:0}}dispose(){this.updateScheduled&&this.forceFlush(),this.clear(),this.runtime=null,this.config.debugMode&&console.log("[UpdateBatcher] Disposed")}}export{o as UpdateBatcher};
//# sourceMappingURL=update_batcher.js.map
