{
  "version": 3,
  "sources": ["../src/state.js"],
  "sourcesContent": ["/**\n * ============================================================================\n * Flutter-Style Typed State System\n * ============================================================================\n * \n * Implements State<T> pattern from Flutter where:\n * - State<MyHomePage> gives you access to this.widget as MyHomePage\n * - Automatic type inference through context\n * - Works just like Flutter without user-side workarounds\n * \n * USAGE:\n * class _MyHomePageState extends State {\n *   build(context) {\n *     return Text(this.widget.title);  // \u2705 this.widget is MyHomePage\n *   }\n * }\n */\n\nimport { UpdateBatcher } from \"./update_batcher.js\";\nimport { StateTracker } from \"./state_tracker.js\";\n\n// ============================================================================\n// STATE CLASS - WITH FLUTTER-STYLE GENERIC SUPPORT\n// ============================================================================\n\n/**\n * Base State class with generic widget type support\n * \n * In Flutter: class _MyState extends State<MyWidget>\n * In FlutterJS: class _MyState extends State\n * \n * The generic type is handled automatically through the widget-state connection\n */\nclass State {\n  constructor() {\n    // Internal references (set by framework)\n    this._element = null;           // Owning StatefulElement\n    this._widget = null;            // Current widget configuration - MUST BE SET\n    this._mounted = false;          // Is state mounted?\n    this._updateQueued = false;     // Update scheduled?\n    this._building = false;         // Currently building?\n\n    // Lifecycle tracking\n    this._initStateCalled = false;\n    this._disposeCalled = false;\n    this._didInitState = false;\n    this._didMount = false;\n    this._isActive = false;\n\n    // Performance tracking\n    this._buildCount = 0;\n    this._lastBuildTime = 0;\n  }\n\n  /**\n   * Build widget tree - MUST be implemented by subclass\n   * @param {BuildContext} context - Build context\n   * @returns {Widget} Widget tree\n   */\n  build(context) {\n    throw new Error(`${this.constructor.name}.build() must be implemented`);\n  }\n\n  // ============================================================================\n  // LIFECYCLE METHODS\n  // ============================================================================\n\n  /**\n   * Called once when state is first created\n   * Override to initialize state\n   */\n  initState() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when widget configuration changes\n   * @param {Widget} oldWidget - Previous widget\n   */\n  didUpdateWidget(oldWidget) {\n    // Override in subclass\n  }\n\n  /**\n   * Called when inherited dependencies change\n   */\n  didChangeDependencies() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is about to be permanently removed\n   * Override to cleanup resources (timers, listeners, etc.)\n   */\n  dispose() {\n    // Override in subclass\n  }\n\n  /**\n   * Called after first build completes\n   */\n  didMount() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is reactivated (after deactivate)\n   */\n  activate() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is deactivated (but not disposed)\n   */\n  deactivate() {\n    // Override in subclass\n  }\n\n  /**\n   * Called during hot reload\n   */\n  reassemble() {\n    // Override in subclass\n  }\n\n  // ============================================================================\n  // STATE UPDATE METHOD - FLUTTER API\n  // ============================================================================\n\n  /**\n   * Update state and schedule rebuild\n   * @param {Function|Object} updateFn - Update function or object\n   */\n  setState(updateFn) {\n    // Check if mounted\n    if (!this.mounted) {\n      console.warn(`[State] setState called on unmounted state (${this.constructor.name})`);\n      return;\n    }\n\n    // Check if building\n    if (this._building) {\n      console.warn(`[State] setState called during build in ${this.constructor.name}`);\n    }\n\n    // Apply state update\n    if (typeof updateFn === 'function') {\n      try {\n        updateFn.call(this);\n      } catch (error) {\n        console.error(`[State] setState update function failed:`, error);\n        throw error;\n      }\n    } else if (typeof updateFn === 'object' && updateFn !== null) {\n      // Direct object merge\n      Object.assign(this, updateFn);\n    } else if (updateFn !== undefined && updateFn !== null) {\n      throw new Error('setState accepts function or object');\n    }\n\n    // Mark element for rebuild\n    if (this._element && this._element.markNeedsBuild) {\n      this._element.markNeedsBuild();\n    }\n  }\n\n  // ============================================================================\n  // FLUTTER-STYLE GETTERS\n  // ============================================================================\n\n  /**\n   * Get BuildContext\n   * @returns {BuildContext|null}\n   */\n  get context() {\n    return this._element ? this._element.context : null;\n  }\n\n  /**\n   * Check if state is mounted\n   * @returns {boolean}\n   */\n  get mounted() {\n    return this._mounted && this._element && this._element._mounted;\n  }\n\n  /**\n   * \u2705 CRITICAL GETTER: Get current widget (typed as T in State<T>)\n   * This is THE key to accessing widget properties in Flutter style\n   * \n   * Example:\n   * class _MyState extends State {\n   *   build(context) {\n   *     return Text(this.widget.title);  // \u2705 Works!\n   *   }\n   * }\n   * \n   * @returns {StatefulWidget} The widget that created this state\n   */\n  get widget() {\n    if (!this._widget) {\n      // \u2705 FALLBACK: Try to get widget from element if not set\n      if (this._element && this._element.widget) {\n        console.warn(\n          `[State] this._widget was null, recovering from element. ` +\n          `This indicates _mount() was not called properly.`\n        );\n        this._widget = this._element.widget;\n      } else {\n        console.error(\n          `[State] Cannot access this.widget - state not properly mounted. ` +\n          `Element: ${!!this._element}, Element.widget: ${!!this._element?.widget}`\n        );\n        return null;\n      }\n    }\n    return this._widget;\n  }\n\n  /**\n   * Mark state as building\n   * @private\n   */\n  _markBuilding(building) {\n    this._building = building;\n  }\n\n  // ============================================================================\n  // INTERNAL LIFECYCLE METHODS - CALLED BY FRAMEWORK\n  // ============================================================================\n\n  /**\n   * \u2705 CRITICAL METHOD: Internal mount - called by StatefulElement.mount()\n   * This is where this._widget gets set!\n   * \n   * @param {StatefulElement} element - The element that owns this state\n   */\n  _mount(element) {\n    console.log('\uD83D\uDD27 State._mount() called for:', this.constructor.name);\n    \n    if (this._mounted) {\n      console.warn('\u26A0\uFE0F State already mounted');\n      return;\n    }\n\n    // \u2705 SET THE ELEMENT REFERENCE\n    this._element = element;\n    \n    // \u2705 CRITICAL: SET THE WIDGET REFERENCE\n    // This makes this.widget.title work!\n    this._widget = element.widget;\n    \n    console.log('\u2705 State._mount() set widget:', {\n      widgetType: this._widget?.constructor?.name,\n      widgetTitle: this._widget?.title,\n      widgetProps: Object.keys(this._widget || {})\n    });\n    \n    // \u2705 MARK AS MOUNTED\n    this._mounted = true;\n    this._isActive = true;\n\n    // Call initState if not already called\n    if (!this._didInitState) {\n      this._didInitState = true;\n      console.log('\uD83C\uDFAC Calling initState()');\n      try {\n        this.initState();\n      } catch (error) {\n        console.error(`[State] initState failed:`, error);\n        throw error;\n      }\n    }\n\n    // Call didChangeDependencies\n    console.log('\uD83D\uDD17 Calling didChangeDependencies()');\n    try {\n      this.didChangeDependencies();\n    } catch (error) {\n      console.error(`[State] didChangeDependencies failed:`, error);\n    }\n\n    // Call didMount after first build\n    if (!this._didMount) {\n      this._didMount = true;\n      console.log('\uD83C\uDF89 Calling didMount()');\n      try {\n        this.didMount();\n      } catch (error) {\n        console.error(`[State] didMount failed:`, error);\n      }\n    }\n    \n    console.log('\u2705 State._mount() complete');\n  }\n\n  /**\n   * Internal: Unmount the state\n   * Called by StatefulElement.unmount()\n   */\n  _unmount() {\n    if (!this._mounted) {\n      return;\n    }\n\n    this._isActive = false;\n    this._mounted = false;\n  }\n\n  /**\n   * Internal: Reactivate the state\n   */\n  _reactivate() {\n    if (this._isActive) {\n      return;\n    }\n\n    this._isActive = true;\n\n    try {\n      this.activate();\n    } catch (error) {\n      console.error(`[State] activate failed:`, error);\n    }\n  }\n\n  /**\n   * Internal: Deactivate the state\n   */\n  _deactivate() {\n    if (!this._isActive) {\n      return;\n    }\n\n    this._isActive = false;\n\n    try {\n      this.deactivate();\n    } catch (error) {\n      console.error(`[State] deactivate failed:`, error);\n    }\n  }\n\n  /**\n   * \u2705 CRITICAL METHOD: Update widget reference when widget rebuilds\n   * Called by StatefulElement.updateWidget()\n   * \n   * @param {Widget} newWidget - New widget configuration\n   */\n  _updateWidget(newWidget) {\n    console.log('\uD83D\uDD04 State._updateWidget() called');\n    console.log('  Old widget:', this._widget?.constructor?.name);\n    console.log('  New widget:', newWidget?.constructor?.name);\n    \n    const oldWidget = this._widget;\n    \n    // \u2705 UPDATE THE WIDGET REFERENCE\n    this._widget = newWidget;\n    \n    // Call user's didUpdateWidget lifecycle\n    if (this.didUpdateWidget && typeof this.didUpdateWidget === 'function') {\n      try {\n        this.didUpdateWidget(oldWidget);\n      } catch (error) {\n        console.error(`[State] didUpdateWidget failed:`, error);\n      }\n    }\n    \n    console.log('\u2705 Widget updated');\n  }\n\n  /**\n   * Internal: Dispose state\n   */\n  _dispose() {\n    if (this._disposeCalled) {\n      return;\n    }\n\n    this._disposeCalled = true;\n    this._mounted = false;\n    this._isActive = false;\n\n    try {\n      this.dispose();\n    } catch (error) {\n      console.error(`[State] dispose failed:`, error);\n    }\n\n    // Clear references\n    this._element = null;\n    this._widget = null;\n  }\n\n  /**\n   * Get state statistics\n   */\n  getStats() {\n    return {\n      mounted: this.mounted,\n      buildCount: this._buildCount,\n      lastBuildTime: this._lastBuildTime,\n      initStateCalled: this._initStateCalled,\n      disposeCalled: this._disposeCalled,\n      isActive: this._isActive,\n      hasWidget: !!this._widget,\n      widgetType: this._widget?.constructor?.name || 'none'\n    };\n  }\n}\n\n// ============================================================================\n// ENHANCED STATE WITH TYPE CHECKING (Optional)\n// ============================================================================\n\n/**\n * TypedState - Optional enhanced state with runtime type checking\n * \n * Usage:\n * class _MyState extends TypedState {\n *   static widgetType = MyHomePage;\n *   \n *   build(context) {\n *     // TypedState ensures this.widget is MyHomePage\n *     return Text(this.widget.title);\n *   }\n * }\n */\nclass TypedState extends State {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Override _mount to add type checking\n   */\n  _mount(element) {\n    // Call parent mount\n    super._mount(element);\n\n    // Optional: Check widget type matches\n    const expectedType = this.constructor.widgetType;\n    if (expectedType && !(this._widget instanceof expectedType)) {\n      console.warn(\n        `[TypedState] Type mismatch: expected ${expectedType.name}, ` +\n        `got ${this._widget?.constructor?.name}`\n      );\n    }\n  }\n\n  /**\n   * Type-safe widget getter with fallback\n   */\n  get widget() {\n    const widget = super.widget;\n    \n    if (!widget) {\n      throw new Error(\n        `[TypedState] this.widget is null. State may not be properly mounted. ` +\n        `Ensure StatefulElement calls state._mount(this) during mount.`\n      );\n    }\n    \n    return widget;\n  }\n}\n\n// ============================================================================\n// CONTEXT BUILDER - PROVIDES WIDGET THROUGH CONTEXT\n// ============================================================================\n\n/**\n * Enhanced BuildContext that provides widget access\n */\nclass EnhancedBuildContext {\n  constructor(element, runtime, state = null) {\n    this._element = element;\n    this._runtime = runtime;\n    this._state = state;\n  }\n\n  /**\n   * Get the widget that created this context\n   * For StatefulWidgets, this is the StatefulWidget instance\n   */\n  get widget() {\n    if (this._state && this._state._widget) {\n      return this._state._widget;\n    }\n    return this._element?.widget || null;\n  }\n\n  /**\n   * Get the state object (if this is a StatefulWidget)\n   */\n  get state() {\n    return this._state;\n  }\n\n  /**\n   * Get the element\n   */\n  get element() {\n    return this._element;\n  }\n\n  /**\n   * Get the runtime\n   */\n  get runtime() {\n    return this._runtime;\n  }\n\n  /**\n   * Find ancestor widget of type T\n   */\n  findAncestorWidgetOfExactType(Type) {\n    let current = this._element?._parent;\n    \n    while (current) {\n      if (current.widget instanceof Type) {\n        return current.widget;\n      }\n      current = current._parent;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Find ancestor state of type T\n   */\n  findAncestorStateOfType(Type) {\n    let current = this._element?._parent;\n    \n    while (current) {\n      if (current.state && current.state instanceof Type) {\n        return current.state;\n      }\n      current = current._parent;\n    }\n    \n    return null;\n  }\n}\n\n// ============================================================================\n// STATE MANAGER - MANAGES STATE LIFECYCLE\n// ============================================================================\n\nclass StateManager {\n  constructor(runtime) {\n    this.runtime = runtime;\n\n    // State registry\n    this.states = new Map();              // stateId \u2192 state\n    this.stateElements = new WeakMap();   // state \u2192 element\n\n    // Update batching\n    this.updateBatcher = new UpdateBatcher(this);\n\n    // State tracking\n    this.stateTracker = new StateTracker();\n\n    // Configuration\n    this.config = {\n      enableBatching: true,\n      enableTracking: true,\n      warnOnSetStateDuringBuild: true,\n      debugMode: false\n    };\n\n    // Statistics\n    this.stats = {\n      statesCreated: 0,\n      statesDisposed: 0,\n      setStateCalls: 0,\n      batchedUpdates: 0\n    };\n  }\n\n  /**\n   * Register a state with proper widget linking\n   * @param {State} state - State to register\n   * @param {StatefulElement} element - Owning element\n   */\n  register(state, element) {\n    if (!state || !element) {\n      throw new Error('State and element are required');\n    }\n\n    const stateId = this.generateStateId(state);\n\n    this.states.set(stateId, state);\n    this.stateElements.set(state, element);\n\n    // \u2705 CRITICAL: Ensure widget reference is set\n    // This should be done in state._mount() but we double-check here\n    if (!state._widget && element.widget) {\n      console.warn(\n        `[StateManager] State widget not set, setting from element. ` +\n        `This indicates _mount() was not called.`\n      );\n      state._widget = element.widget;\n    }\n\n    this.stats.statesCreated++;\n\n    if (this.config.debugMode) {\n      console.log(`[StateManager] Registered state ${stateId}`);\n      console.log(`  Widget type: ${state._widget?.constructor?.name}`);\n      console.log(`  Widget props:`, Object.keys(state._widget || {}));\n    }\n  }\n\n  /**\n   * Unregister a state\n   * @param {State} state - State to unregister\n   */\n  unregister(state) {\n    if (!state) {\n      return;\n    }\n\n    const stateId = this.generateStateId(state);\n\n    // Dispose state\n    if (!state._disposeCalled) {\n      state._dispose();\n    }\n\n    // Clear references\n    this.states.delete(stateId);\n    this.stateElements.delete(state);\n\n    state._element = null;\n    state._widget = null;\n\n    this.stats.statesDisposed++;\n\n    if (this.config.debugMode) {\n      console.log(`[StateManager] Unregistered state ${stateId}`);\n    }\n  }\n\n  /**\n   * Handle setState call\n   * @param {State} state - State being updated\n   * @param {Function} updateFn - Update function\n   */\n  handleSetState(state, updateFn) {\n    if (!state || !state.mounted) {\n      return;\n    }\n\n    this.stats.setStateCalls++;\n\n    if (this.config.enableBatching) {\n      this.updateBatcher.queueUpdate(state._element, updateFn);\n    } else {\n      // Immediate update\n      updateFn();\n      state._element.markNeedsBuild();\n    }\n  }\n\n  /**\n   * Generate unique state ID\n   */\n  generateStateId(state) {\n    if (!state._stateId) {\n      state._stateId = `state_${++StateManager._stateIdCounter}`;\n    }\n    return state._stateId;\n  }\n\n  /**\n   * Get element for state\n   */\n  getElement(state) {\n    return this.stateElements.get(state);\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      currentStates: this.states.size,\n      batcher: this.updateBatcher.getStats(),\n      tracker: this.stateTracker.getStats()\n    };\n  }\n\n  /**\n   * Clear all states\n   */\n  clear() {\n    this.states.forEach(state => {\n      if (!state._disposeCalled) {\n        state._dispose();\n      }\n    });\n\n    this.states.clear();\n    this.updateBatcher.clear();\n    this.stateTracker.clear();\n  }\n\n  /**\n   * Dispose state manager\n   */\n  dispose() {\n    this.clear();\n  }\n}\n\nStateManager._stateIdCounter = 0;\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport {\n  State,\n  TypedState,\n  StateManager,\n  EnhancedBuildContext,\n};"],
  "mappings": "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",
  "names": ["UpdateBatcher", "StateTracker", "State", "context", "oldWidget", "updateFn", "error", "building", "element", "newWidget", "TypedState", "expectedType", "widget", "EnhancedBuildContext", "runtime", "state", "Type", "current", "StateManager", "stateId"]
}
