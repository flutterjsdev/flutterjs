{
  "version": 3,
  "sources": ["../src/state.js"],
  "sourcesContent": ["/**\n * FlutterJS State Management System - FIXED\n * \n * Provides reactive state management for StatefulWidget.\n * Added missing lifecycle methods: _mount, _unmount, _reactivate, _deactivate, _updateWidget\n */\n\nimport { UpdateBatcher } from \"./update_batcher.js\";\nimport { StateTracker } from \"./state_tracker.js\";\n\nclass State {\n  constructor() {\n    // Internal references (set by framework)\n    this._element = null;           // Owning StatefulElement\n    this._widget = null;            // Current widget configuration\n    this._mounted = false;          // Is state mounted?\n    this._updateQueued = false;     // Update scheduled?\n    this._building = false;         // Currently building?\n\n    // Lifecycle tracking\n    this._initStateCalled = false;\n    this._disposeCalled = false;\n    this._didInitState = false;\n    this._didMount = false;\n    this._isActive = false;\n\n    // Performance tracking\n    this._buildCount = 0;\n    this._lastBuildTime = 0;\n\n    // State properties (defined by subclass)\n    // Example: this.count = 0;\n  }\n\n  /**\n   * Build widget tree\n   * Must be implemented by subclass\n   * @param {BuildContext} context - Build context\n   * @returns {Widget} - Widget tree\n   */\n  build(context) {\n    throw new Error(`${this.constructor.name}.build() must be implemented`);\n  }\n\n  /**\n   * Called once when state is first created\n   * Override to initialize state\n   */\n  initState() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when widget configuration changes\n   * @param {Widget} oldWidget - Previous widget\n   */\n  didUpdateWidget(oldWidget) {\n    // Override in subclass\n  }\n\n  /**\n   * Called when inherited dependencies change\n   */\n  didChangeDependencies() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is about to be permanently removed\n   * Override to cleanup resources (timers, listeners, etc.)\n   */\n  dispose() {\n    // Override in subclass\n  }\n\n  /**\n   * Called after first build completes\n   */\n  didMount() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is reactivated (after deactivate)\n   */\n  activate() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is deactivated (but not disposed)\n   */\n  deactivate() {\n    // Override in subclass\n  }\n\n  /**\n   * Called during hot reload\n   */\n  reassemble() {\n    // Override in subclass\n  }\n\n  /**\n   * Update state and schedule rebuild\n   * @param {Function|Object} updateFn - Update function or object\n   */\n  setState(updateFn) {\n    // Check if mounted\n    if (!this.mounted) {\n      console.warn(`[State] setState called on unmounted state (${this.constructor.name})`);\n      return;\n    }\n\n    // Check if building\n    if (this._building) {\n      console.warn(`[State] setState called during build in ${this.constructor.name}`);\n    }\n\n    // Apply state update\n    if (typeof updateFn === 'function') {\n      try {\n        updateFn.call(this);\n      } catch (error) {\n        console.error(`[State] setState update function failed:`, error);\n        throw error;\n      }\n    } else if (typeof updateFn === 'object' && updateFn !== null) {\n      // Direct object merge\n      Object.assign(this, updateFn);\n    } else if (updateFn !== undefined && updateFn !== null) {\n      throw new Error('setState accepts function or object');\n    }\n\n    // Mark element for rebuild\n    if (this._element && this._element.markNeedsBuild) {\n      this._element.markNeedsBuild();\n    }\n  }\n\n  /**\n   * Get BuildContext\n   * @returns {BuildContext|null}\n   */\n  get context() {\n    return this._element ? this._element.context : null;\n  }\n\n  /**\n   * Check if state is mounted\n   * @returns {boolean}\n   */\n  get mounted() {\n    return this._mounted && this._element && this._element._mounted;\n  }\n\n  /**\n   * Get current widget\n   * @returns {Widget|null}\n   */\n  get widget() {\n    return this._widget;\n  }\n\n  /**\n   * Mark state as building\n   */\n  _markBuilding(building) {\n    this._building = building;\n  }\n\n  // ============================================================================\n  // INTERNAL LIFECYCLE METHODS\n  // ============================================================================\n\n  /**\n   * Internal: Mount the state\n   * Called by StatefulElement.mount()\n   */\n  _mount(element) {\n    if (this._mounted) {\n      return;\n    }\n\n    this._element = element;\n    this._widget = element.widget;\n    this._mounted = true;\n    this._isActive = true;\n\n    // Call initState\n    if (!this._didInitState) {\n      this._didInitState = true;\n      try {\n        this.initState();\n      } catch (error) {\n        console.error(`[State] initState failed:`, error);\n        throw error;\n      }\n    }\n\n    // Call didChangeDependencies\n    try {\n      this.didChangeDependencies();\n    } catch (error) {\n      console.error(`[State] didChangeDependencies failed:`, error);\n    }\n\n    // Call didMount\n    if (!this._didMount) {\n      this._didMount = true;\n      try {\n        this.didMount();\n      } catch (error) {\n        console.error(`[State] didMount failed:`, error);\n      }\n    }\n  }\n\n  /**\n   * Internal: Unmount the state\n   * Called by StatefulElement.unmount()\n   */\n  _unmount() {\n    if (!this._mounted) {\n      return;\n    }\n\n    this._isActive = false;\n    this._mounted = false;\n\n    // Dispose is called separately, so don't call it here\n  }\n\n  /**\n   * Internal: Reactivate the state\n   * Called by StatefulElement.activate()\n   */\n  _reactivate() {\n    if (this._isActive) {\n      return;\n    }\n\n    this._isActive = true;\n\n    try {\n      this.activate();\n    } catch (error) {\n      console.error(`[State] activate failed:`, error);\n    }\n  }\n\n  /**\n   * Internal: Deactivate the state\n   * Called by StatefulElement.deactivate()\n   */\n  _deactivate() {\n    if (!this._isActive) {\n      return;\n    }\n\n    this._isActive = false;\n\n    try {\n      this.deactivate();\n    } catch (error) {\n      console.error(`[State] deactivate failed:`, error);\n    }\n  }\n\n  /**\n   * Internal: Update widget reference\n   * Called by StatefulElement.updateWidget()\n   */\n  _updateWidget(newWidget) {\n    this._widget = newWidget;\n  }\n\n  /**\n   * Internal: Initialize state\n   */\n  _init() {\n    if (this._initStateCalled) {\n      return;\n    }\n\n    this._initStateCalled = true;\n    this._mounted = true;\n\n    try {\n      this.initState();\n    } catch (error) {\n      console.error(`[State] initState failed:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Internal: Dispose state\n   */\n  _dispose() {\n    if (this._disposeCalled) {\n      return;\n    }\n\n    this._disposeCalled = true;\n    this._mounted = false;\n    this._isActive = false;\n\n    try {\n      this.dispose();\n    } catch (error) {\n      console.error(`[State] dispose failed:`, error);\n    }\n  }\n\n  /**\n   * Get state statistics\n   */\n  getStats() {\n    return {\n      mounted: this.mounted,\n      buildCount: this._buildCount,\n      lastBuildTime: this._lastBuildTime,\n      initStateCalled: this._initStateCalled,\n      disposeCalled: this._disposeCalled,\n      isActive: this._isActive\n    };\n  }\n}\n\n/**\n * StateManager\n * \n * Manages state lifecycle and coordinates updates\n */\nclass StateManager {\n  constructor(runtime) {\n    this.runtime = runtime;\n\n    // State registry\n    this.states = new Map();              // stateId \u2192 state\n    this.stateElements = new WeakMap();   // state \u2192 element\n\n    // Update batching\n    this.updateBatcher = new UpdateBatcher(this);\n\n    // State tracking\n    this.stateTracker = new StateTracker();\n\n    // Configuration\n    this.config = {\n      enableBatching: true,\n      enableTracking: true,\n      warnOnSetStateDuringBuild: true,\n      debugMode: false\n    };\n\n    // Statistics\n    this.stats = {\n      statesCreated: 0,\n      statesDisposed: 0,\n      setStateCalls: 0,\n      batchedUpdates: 0\n    };\n  }\n\n  /**\n   * Register a state\n   * @param {State} state - State to register\n   * @param {Element} element - Owning element\n   */\n  register(state, element) {\n    if (!state || !element) {\n      throw new Error('State and element are required');\n    }\n\n    const stateId = this.generateStateId(state);\n\n    this.states.set(stateId, state);\n    this.stateElements.set(state, element);\n\n    // Link state to element\n    state._element = element;\n\n    this.stats.statesCreated++;\n\n    if (this.config.debugMode) {\n      console.log(`[StateManager] Registered state ${stateId}`);\n    }\n  }\n\n  /**\n   * Unregister a state\n   * @param {State} state - State to unregister\n   */\n  unregister(state) {\n    if (!state) {\n      return;\n    }\n\n    const stateId = this.generateStateId(state);\n\n    // Dispose state\n    if (!state._disposeCalled) {\n      state._dispose();\n    }\n\n    // Clear references\n    this.states.delete(stateId);\n    this.stateElements.delete(state);\n\n    state._element = null;\n    state._widget = null;\n\n    this.stats.statesDisposed++;\n\n    if (this.config.debugMode) {\n      console.log(`[StateManager] Unregistered state ${stateId}`);\n    }\n  }\n\n  /**\n   * Handle setState call\n   * @param {State} state - State being updated\n   * @param {Function} updateFn - Update function\n   */\n  handleSetState(state, updateFn) {\n    if (!state || !state.mounted) {\n      return;\n    }\n\n    this.stats.setStateCalls++;\n\n    if (this.config.enableBatching) {\n      this.updateBatcher.queueUpdate(state._element, updateFn);\n    } else {\n      // Immediate update\n      updateFn();\n      state._element.markNeedsBuild();\n    }\n  }\n\n  /**\n   * Generate unique state ID\n   */\n  generateStateId(state) {\n    if (!state._stateId) {\n      state._stateId = `state_${++StateManager._stateIdCounter}`;\n    }\n    return state._stateId;\n  }\n\n  /**\n   * Get element for state\n   */\n  getElement(state) {\n    return this.stateElements.get(state);\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      currentStates: this.states.size,\n      batcher: this.updateBatcher.getStats(),\n      tracker: this.stateTracker.getStats()\n    };\n  }\n\n  /**\n   * Clear all states\n   */\n  clear() {\n    this.states.forEach(state => {\n      if (!state._disposeCalled) {\n        state._dispose();\n      }\n    });\n\n    this.states.clear();\n    this.updateBatcher.clear();\n    this.stateTracker.clear();\n  }\n\n  /**\n   * Dispose state manager\n   */\n  dispose() {\n    this.clear();\n  }\n}\n\nStateManager._stateIdCounter = 0;\n\n/**\n * ReactiveState\n * \n * Enhanced state with automatic property tracking\n * (Optional extension of State)\n */\nclass ReactiveState extends State {\n  constructor() {\n    super();\n    this._reactiveProperties = new Set();\n    this._propertyValues = new Map();\n  }\n\n  /**\n   * Make property reactive\n   * @param {string} property - Property name\n   * @param {*} initialValue - Initial value\n   */\n  makeReactive(property, initialValue) {\n    const key = `_${property}`;\n    this._propertyValues.set(property, initialValue);\n\n    Object.defineProperty(this, property, {\n      get() {\n        // Track access if tracking enabled\n        if (this._element && this._element.runtime) {\n          const stateManager = this._element.runtime.stateManager;\n          if (stateManager && stateManager.stateTracker.tracking) {\n            stateManager.stateTracker.recordDependency(this, property);\n          }\n        }\n\n        return this._propertyValues.get(property);\n      },\n      set(value) {\n        const oldValue = this._propertyValues.get(property);\n\n        if (oldValue !== value) {\n          this._propertyValues.set(property, value);\n\n          // Trigger update for this property's dependents\n          if (this._element && this._element.runtime) {\n            const stateManager = this._element.runtime.stateManager;\n            if (stateManager) {\n              const dependents = stateManager.stateTracker.getDependents(this, property);\n              dependents.forEach(el => {\n                if (el._mounted) {\n                  el.markNeedsBuild();\n                }\n              });\n            }\n          }\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    this._reactiveProperties.add(property);\n  }\n\n  /**\n   * Get reactive property value\n   */\n  getValue(property) {\n    return this._propertyValues.get(property);\n  }\n\n  /**\n   * Set reactive property value\n   */\n  setValue(property, value) {\n    this[property] = value;\n  }\n}\n\n/**\n * StateObserver\n * \n * Observes state changes for debugging/logging\n */\nclass StateObserver {\n  constructor() {\n    this.observers = new Map();    // stateId \u2192 callbacks[]\n  }\n\n  /**\n   * Observe state\n   * @param {State} state - State to observe\n   * @param {Function} callback - Callback on state change\n   */\n  observe(state, callback) {\n    if (!state || typeof callback !== 'function') {\n      return;\n    }\n\n    const stateId = state._stateId || 'unknown';\n\n    if (!this.observers.has(stateId)) {\n      this.observers.set(stateId, []);\n    }\n\n    this.observers.get(stateId).push(callback);\n  }\n\n  /**\n   * Notify observers of state change\n   * @param {State} state - State that changed\n   * @param {string} property - Property that changed\n   * @param {*} oldValue - Old value\n   * @param {*} newValue - New value\n   */\n  notify(state, property, oldValue, newValue) {\n    const stateId = state._stateId || 'unknown';\n    const callbacks = this.observers.get(stateId);\n\n    if (!callbacks) {\n      return;\n    }\n\n    callbacks.forEach(callback => {\n      try {\n        callback(state, property, oldValue, newValue);\n      } catch (error) {\n        console.error('[StateObserver] Observer callback failed:', error);\n      }\n    });\n  }\n\n  /**\n   * Stop observing state\n   */\n  unobserve(state, callback) {\n    const stateId = state._stateId || 'unknown';\n    const callbacks = this.observers.get(stateId);\n\n    if (!callbacks) {\n      return;\n    }\n\n    if (callback) {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n    } else {\n      this.observers.delete(stateId);\n    }\n  }\n\n  /**\n   * Clear all observers\n   */\n  clear() {\n    this.observers.clear();\n  }\n}\n\nexport {\n  State,\n  StateManager,\n  ReactiveState,\n  StateObserver\n};"],
  "mappings": "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",
  "names": ["UpdateBatcher", "StateTracker", "State", "context", "oldWidget", "updateFn", "error", "building", "element", "newWidget", "StateManager", "runtime", "state", "stateId", "ReactiveState", "property", "initialValue", "key", "stateManager", "value", "el", "StateObserver", "callback", "oldValue", "newValue", "callbacks", "index"]
}
