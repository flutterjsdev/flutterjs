{
  "version": 3,
  "sources": ["../src/state.js"],
  "sourcesContent": ["/**\n * FlutterJS State Management System\n * \n * Provides reactive state management for StatefulWidget.\n * \n * Key Components:\n * - State: Base class for widget state\n * - StateManager: Coordinates state updates and rebuilds\n * - StateTracker: Tracks dependencies and reactivity\n * - UpdateBatcher: Batches multiple setState calls\n * \n * Lifecycle:\n * 1. initState() - Called once on creation\n * 2. didChangeDependencies() - When inherited values change\n * 3. build() - Build widget tree\n * 4. didUpdateWidget() - When parent widget changes\n * 5. setState() - Trigger rebuild\n * 6. dispose() - Cleanup\n */\n\n/**\n * State Base Class\n * \n * Base class for all stateful widget state.\n * Subclasses must implement build() method.\n */\nimport { UpdateBatcher } from \"./update_batcher.js\";\nimport { StateTracker } from \"./state_tracker.js\";\n\nclass State {\n  constructor() {\n    // Internal references (set by framework)\n    this._element = null;           // Owning StatefulElement\n    this._widget = null;            // Current widget configuration\n    this._mounted = false;          // Is state mounted?\n    this._updateQueued = false;     // Update scheduled?\n    this._building = false;         // Currently building?\n\n    // Lifecycle tracking\n    this._initStateCalled = false;\n    this._disposeCalled = false;\n\n    // Performance tracking\n    this._buildCount = 0;\n    this._lastBuildTime = 0;\n\n    // State properties (defined by subclass)\n    // Example: this.count = 0;\n  }\n\n  /**\n   * Build widget tree\n   * Must be implemented by subclass\n   * @param {BuildContext} context - Build context\n   * @returns {Widget} - Widget tree\n   */\n  build(context) {\n    throw new Error(`${this.constructor.name}.build() must be implemented`);\n  }\n\n  /**\n   * Called once when state is first created\n   * Override to initialize state\n   */\n  initState() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when widget configuration changes\n   * @param {Widget} oldWidget - Previous widget\n   */\n  didUpdateWidget(oldWidget) {\n    // Override in subclass\n  }\n\n  /**\n   * Called when inherited dependencies change\n   */\n  didChangeDependencies() {\n    // Override in subclass\n  }\n\n  /**\n   * Called when state is about to be permanently removed\n   * Override to cleanup resources (timers, listeners, etc.)\n   */\n  dispose() {\n    // Override in subclass\n  }\n\n  /**\n   * Called after first build completes\n   */\n  didMount() {\n    // Override in subclass\n  }\n\n  /**\n   * Update state and schedule rebuild\n   * @param {Function|Object} updateFn - Update function or object\n   */\n  setState(updateFn) {\n    // Check if mounted\n    if (!this.mounted) {\n      console.warn(`[State] setState called on unmounted state (${this.constructor.name})`);\n      return;\n    }\n\n    // Check if building\n    if (this._building) {\n      console.warn(`[State] setState called during build in ${this.constructor.name}`);\n    }\n\n    // Apply state update\n    if (typeof updateFn === 'function') {\n      try {\n        updateFn.call(this);\n      } catch (error) {\n        console.error(`[State] setState update function failed:`, error);\n        throw error;\n      }\n    } else if (typeof updateFn === 'object' && updateFn !== null) {\n      // Direct object merge\n      Object.assign(this, updateFn);\n    } else if (updateFn !== undefined && updateFn !== null) {\n      throw new Error('setState accepts function or object');\n    }\n\n    // Mark element for rebuild\n    if (this._element && this._element.markNeedsBuild) {\n      this._element.markNeedsBuild();\n    }\n  }\n\n  /**\n   * Get BuildContext\n   * @returns {BuildContext|null}\n   */\n  get context() {\n    return this._element ? this._element.buildContext() : null;\n  }\n\n  /**\n   * Check if state is mounted\n   * @returns {boolean}\n   */\n  get mounted() {\n    return this._mounted && this._element && this._element.mounted;\n  }\n\n  /**\n   * Get current widget\n   * @returns {Widget|null}\n   */\n  get widget() {\n    return this._widget;\n  }\n\n  /**\n   * Mark state as building\n   */\n  _markBuilding(building) {\n    this._building = building;\n  }\n\n  /**\n   * Internal: Initialize state\n   */\n  _init() {\n    if (this._initStateCalled) {\n      return;\n    }\n\n    this._initStateCalled = true;\n    this._mounted = true;\n\n    try {\n      this.initState();\n    } catch (error) {\n      console.error(`[State] initState failed:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Internal: Dispose state\n   */\n  _dispose() {\n    if (this._disposeCalled) {\n      return;\n    }\n\n    this._disposeCalled = true;\n    this._mounted = false;\n\n    try {\n      this.dispose();\n    } catch (error) {\n      console.error(`[State] dispose failed:`, error);\n    }\n  }\n\n  /**\n   * Get state statistics\n   */\n  getStats() {\n    return {\n      mounted: this.mounted,\n      buildCount: this._buildCount,\n      lastBuildTime: this._lastBuildTime,\n      initStateCalled: this._initStateCalled,\n      disposeCalled: this._disposeCalled\n    };\n  }\n}\n\n/**\n * StateManager\n * \n * Manages state lifecycle and coordinates updates\n */\nclass StateManager {\n  constructor(runtime) {\n    this.runtime = runtime;\n\n    // State registry\n    this.states = new Map();              // stateId \u2192 state\n    this.stateElements = new WeakMap();   // state \u2192 element\n\n    // Update batching\n    this.updateBatcher = new UpdateBatcher(this);\n\n    // State tracking\n    this.stateTracker = new StateTracker();\n\n    // Configuration\n    this.config = {\n      enableBatching: true,\n      enableTracking: true,\n      warnOnSetStateDuringBuild: true,\n      debugMode: false\n    };\n\n    // Statistics\n    this.stats = {\n      statesCreated: 0,\n      statesDisposed: 0,\n      setStateCalls: 0,\n      batchedUpdates: 0\n    };\n  }\n\n  /**\n   * Register a state\n   * @param {State} state - State to register\n   * @param {Element} element - Owning element\n   */\n  register(state, element) {\n    if (!state || !element) {\n      throw new Error('State and element are required');\n    }\n\n    const stateId = this.generateStateId(state);\n\n    this.states.set(stateId, state);\n    this.stateElements.set(state, element);\n\n    // Link state to element\n    state._element = element;\n\n    this.stats.statesCreated++;\n\n    if (this.config.debugMode) {\n      console.log(`[StateManager] Registered state ${stateId}`);\n    }\n  }\n\n  /**\n   * Unregister a state\n   * @param {State} state - State to unregister\n   */\n  unregister(state) {\n    if (!state) {\n      return;\n    }\n\n    const stateId = this.generateStateId(state);\n\n    // Dispose state\n    if (!state._disposeCalled) {\n      state._dispose();\n    }\n\n    // Clear references\n    this.states.delete(stateId);\n    this.stateElements.delete(state);\n\n    state._element = null;\n    state._widget = null;\n\n    this.stats.statesDisposed++;\n\n    if (this.config.debugMode) {\n      console.log(`[StateManager] Unregistered state ${stateId}`);\n    }\n  }\n\n  /**\n   * Handle setState call\n   * @param {State} state - State being updated\n   * @param {Function} updateFn - Update function\n   */\n  handleSetState(state, updateFn) {\n    if (!state || !state.mounted) {\n      return;\n    }\n\n    this.stats.setStateCalls++;\n\n    if (this.config.enableBatching) {\n      this.updateBatcher.queueUpdate(state._element, updateFn);\n    } else {\n      // Immediate update\n      updateFn();\n      state._element.markNeedsBuild();\n    }\n  }\n\n  /**\n   * Generate unique state ID\n   */\n  generateStateId(state) {\n    if (!state._stateId) {\n      state._stateId = `state_${++StateManager._stateIdCounter}`;\n    }\n    return state._stateId;\n  }\n\n  /**\n   * Get element for state\n   */\n  getElement(state) {\n    return this.stateElements.get(state);\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      currentStates: this.states.size,\n      batcher: this.updateBatcher.getStats(),\n      tracker: this.stateTracker.getStats()\n    };\n  }\n\n  /**\n   * Clear all states\n   */\n  clear() {\n    this.states.forEach(state => {\n      if (!state._disposeCalled) {\n        state._dispose();\n      }\n    });\n\n    this.states.clear();\n    this.updateBatcher.clear();\n    this.stateTracker.clear();\n  }\n\n  /**\n   * Dispose state manager\n   */\n  dispose() {\n    this.clear();\n  }\n}\n\nStateManager._stateIdCounter = 0;\n\n\n\n\n/**\n * ReactiveState\n * \n * Enhanced state with automatic property tracking\n * (Optional extension of State)\n */\nclass ReactiveState extends State {\n  constructor() {\n    super();\n    this._reactiveProperties = new Set();\n    this._propertyValues = new Map();\n  }\n\n  /**\n   * Make property reactive\n   * @param {string} property - Property name\n   * @param {*} initialValue - Initial value\n   */\n  makeReactive(property, initialValue) {\n    const key = `_${property}`;\n    this._propertyValues.set(property, initialValue);\n\n    Object.defineProperty(this, property, {\n      get() {\n        // Track access if tracking enabled\n        if (this._element && this._element.runtime) {\n          const stateManager = this._element.runtime.stateManager;\n          if (stateManager && stateManager.stateTracker.tracking) {\n            stateManager.stateTracker.recordDependency(this, property);\n          }\n        }\n\n        return this._propertyValues.get(property);\n      },\n      set(value) {\n        const oldValue = this._propertyValues.get(property);\n\n        if (oldValue !== value) {\n          this._propertyValues.set(property, value);\n\n          // Trigger update for this property's dependents\n          if (this._element && this._element.runtime) {\n            const stateManager = this._element.runtime.stateManager;\n            if (stateManager) {\n              const dependents = stateManager.stateTracker.getDependents(this, property);\n              dependents.forEach(el => {\n                if (el.mounted) {\n                  el.markNeedsBuild();\n                }\n              });\n            }\n          }\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    this._reactiveProperties.add(property);\n  }\n\n  /**\n   * Get reactive property value\n   */\n  getValue(property) {\n    return this._propertyValues.get(property);\n  }\n\n  /**\n   * Set reactive property value\n   */\n  setValue(property, value) {\n    this[property] = value;\n  }\n}\n\n/**\n * StateObserver\n * \n * Observes state changes for debugging/logging\n */\nclass StateObserver {\n  constructor() {\n    this.observers = new Map();    // stateId \u2192 callbacks[]\n  }\n\n  /**\n   * Observe state\n   * @param {State} state - State to observe\n   * @param {Function} callback - Callback on state change\n   */\n  observe(state, callback) {\n    if (!state || typeof callback !== 'function') {\n      return;\n    }\n\n    const stateId = state._stateId || 'unknown';\n\n    if (!this.observers.has(stateId)) {\n      this.observers.set(stateId, []);\n    }\n\n    this.observers.get(stateId).push(callback);\n  }\n\n  /**\n   * Notify observers of state change\n   * @param {State} state - State that changed\n   * @param {string} property - Property that changed\n   * @param {*} oldValue - Old value\n   * @param {*} newValue - New value\n   */\n  notify(state, property, oldValue, newValue) {\n    const stateId = state._stateId || 'unknown';\n    const callbacks = this.observers.get(stateId);\n\n    if (!callbacks) {\n      return;\n    }\n\n    callbacks.forEach(callback => {\n      try {\n        callback(state, property, oldValue, newValue);\n      } catch (error) {\n        console.error('[StateObserver] Observer callback failed:', error);\n      }\n    });\n  }\n\n  /**\n   * Stop observing state\n   */\n  unobserve(state, callback) {\n    const stateId = state._stateId || 'unknown';\n    const callbacks = this.observers.get(stateId);\n\n    if (!callbacks) {\n      return;\n    }\n\n    if (callback) {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n    } else {\n      this.observers.delete(stateId);\n    }\n  }\n\n  /**\n   * Clear all observers\n   */\n  clear() {\n    this.observers.clear();\n  }\n}\n\n\nexport {\n  State,\n  StateManager,\n\n  ReactiveState,\n  StateObserver\n};"],
  "mappings": "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",
  "names": ["UpdateBatcher", "StateTracker", "State", "context", "oldWidget", "updateFn", "error", "building", "StateManager", "runtime", "state", "element", "stateId", "ReactiveState", "property", "initialValue", "key", "stateManager", "value", "el", "StateObserver", "callback", "oldValue", "newValue", "callbacks", "index"]
}
