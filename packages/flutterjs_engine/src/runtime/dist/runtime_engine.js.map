{
  "version": 3,
  "sources": ["../src/runtime_engine.js"],
  "sourcesContent": ["/**\n * FlutterJS Runtime Engine\n * \n * Core runtime that manages widget lifecycle, element tree, and coordinates\n * all system operations. This is the heart of the FlutterJS framework.\n * \n * Responsibilities:\n * - Mount and unmount applications\n * - Create and manage element tree\n * - Schedule and perform updates\n * - Track dirty elements\n * - Coordinate with service registry\n * - Memory management\n */\n\n// Import Element classes from element.js\nimport {\n  Element,\n  StatelessElement,\n  StatefulElement,\n\n  ComponentElement\n} from \"../src/element.js\";\n\nimport {  InheritedElement,} from \"../src/inherited_element.js\";\n\nclass RuntimeEngine {\n  constructor() {\n    // Root references\n    this.rootElement = null;           // Root DOM element\n    this.rootWidget = null;            // Root widget (e.g., MyApp)\n    this.elementTree = null;           // Root element instance\n    \n    // Update management\n    this.dirtyElements = new Set();    // Elements needing rebuild\n    this.updateScheduled = false;      // Update queued?\n    this.isUpdating = false;           // Currently performing update?\n    \n    // Context and services\n    this.buildContext = null;          // Global context\n    this.serviceRegistry = new Map();  // Framework services\n    \n    // Performance tracking\n    this.frameCounter = 0;\n    this.buildTime = 0;\n    this.renderTime = 0;\n    this.lastUpdateTime = 0;\n    \n    // State\n    this.mounted = false;\n    this.disposed = false;\n    \n    // Configuration\n    this.config = {\n      batchUpdates: true,\n      debugMode: false,\n      performanceMonitoring: true\n    };\n  }\n  \n  /**\n   * Initialize and mount application\n   * @param {Widget} rootWidget - Root widget of the application\n   * @param {HTMLElement} containerElement - DOM container to mount into\n   * @returns {RuntimeEngine} this instance for chaining\n   */\n  mount(rootWidget, containerElement) {\n    if (this.mounted) {\n      throw new Error('Runtime already mounted. Call unmount() first.');\n    }\n    \n    if (!rootWidget) {\n      throw new Error('Root widget is required');\n    }\n    \n    if (!containerElement || !(containerElement instanceof HTMLElement)) {\n      throw new Error('Valid container element is required');\n    }\n    \n    try {\n      this.rootWidget = rootWidget;\n      this.rootElement = containerElement;\n      \n      // Create root element from widget\n      this.elementTree = this.createElement(rootWidget, null);\n      \n      if (!this.elementTree) {\n        throw new Error('Failed to create root element');\n      }\n      \n      // Build initial VNode tree\n      const startBuild = performance.now();\n      const vnode = this.elementTree.build();\n      this.buildTime = performance.now() - startBuild;\n      \n      if (!vnode) {\n        throw new Error('Root element build() returned null');\n      }\n      \n      // Render to DOM\n      const startRender = performance.now();\n      this.renderVNode(vnode, containerElement);\n      this.renderTime = performance.now() - startRender;\n      \n      // Store DOM reference in element\n      this.elementTree.domNode = containerElement.firstChild;\n      \n      // Mount element tree (calls lifecycle hooks)\n      this.elementTree.mount();\n      \n      this.mounted = true;\n      \n      if (this.config.debugMode) {\n        console.log(`[RuntimeEngine] Mounted in ${(this.buildTime + this.renderTime).toFixed(2)}ms`);\n        console.log(`  - Build: ${this.buildTime.toFixed(2)}ms`);\n        console.log(`  - Render: ${this.renderTime.toFixed(2)}ms`);\n      }\n      \n      return this;\n    } catch (error) {\n      this.cleanup();\n      throw new Error(`Failed to mount application: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Create element from widget\n   * @param {Widget} widget - Widget to create element for\n   * @param {Element|null} parent - Parent element\n   * @returns {Element} Created element instance\n   */\n  createElement(widget, parent) {\n    if (!widget) {\n      throw new Error('Widget is required');\n    }\n    \n    // Check if widget has custom element creation\n    if (typeof widget.createElement === 'function') {\n      return widget.createElement(parent, this);\n    }\n    \n    // Determine element type based on widget class name\n    const widgetType = widget.constructor.name;\n    \n    // Check for StatelessWidget\n    if (this.isStatelessWidget(widget)) {\n      return new StatelessElement(widget, parent, this);\n    }\n    \n    // Check for StatefulWidget\n    if (this.isStatefulWidget(widget)) {\n      return new StatefulElement(widget, parent, this);\n    }\n    \n    // Check for InheritedWidget\n    if (this.isInheritedWidget(widget)) {\n      return new InheritedElement(widget, parent, this);\n    }\n    \n    // Check for custom component\n    if (this.isComponentWidget(widget)) {\n      return new ComponentElement(widget, parent, this);\n    }\n    \n    throw new Error(`Unknown widget type: ${widgetType}. Widget must extend StatelessWidget, StatefulWidget, InheritedWidget, or have render/build method.`);\n  }\n  \n  /**\n   * Check if widget is StatelessWidget\n   */\n  isStatelessWidget(widget) {\n    return widget.constructor.name === 'StatelessWidget' || \n           (widget.constructor.prototype && \n            widget.constructor.prototype.constructor.name === 'StatelessWidget') ||\n           (typeof widget.build === 'function' && !widget.createState && !widget.child);\n  }\n  \n  /**\n   * Check if widget is StatefulWidget\n   */\n  isStatefulWidget(widget) {\n    return widget.constructor.name === 'StatefulWidget' ||\n           (widget.constructor.prototype && \n            widget.constructor.prototype.constructor.name === 'StatefulWidget') ||\n           (typeof widget.createState === 'function');\n  }\n  \n  /**\n   * Check if widget is InheritedWidget\n   */\n  isInheritedWidget(widget) {\n    return widget.constructor.name === 'InheritedWidget' ||\n           (widget.constructor.prototype && \n            widget.constructor.prototype.constructor.name === 'InheritedWidget') ||\n           (widget.child !== undefined && typeof widget.updateShouldNotify === 'function');\n  }\n  \n  /**\n   * Check if widget is a custom component\n   */\n  isComponentWidget(widget) {\n    return typeof widget.render === 'function' || \n           (typeof widget.build === 'function' && \n            typeof widget.createState !== 'function');\n  }\n  \n  /**\n   * Render VNode to DOM (simple implementation)\n   */\n  renderVNode(vnode, container) {\n    if (!vnode) return;\n    \n    if (typeof vnode === 'string') {\n      container.textContent = vnode;\n      return;\n    }\n    \n    const element = document.createElement(vnode.tag || 'div');\n    \n    // Apply props\n    if (vnode.props) {\n      Object.entries(vnode.props).forEach(([key, value]) => {\n        if (key === 'className') {\n          element.className = value;\n        } else if (key === 'style' && typeof value === 'object') {\n          Object.assign(element.style, value);\n        } else if (!key.startsWith('data-')) {\n          element.setAttribute(key, value);\n        } else {\n          element.setAttribute(key, value);\n        }\n      });\n    }\n    \n    // Apply inline style\n    if (vnode.style) {\n      Object.assign(element.style, vnode.style);\n    }\n    \n    // Render children\n    if (vnode.children) {\n      vnode.children.forEach(child => {\n        if (typeof child === 'string') {\n          element.appendChild(document.createTextNode(child));\n        } else if (child) {\n          const childContainer = document.createElement('div');\n          this.renderVNode(child, childContainer);\n          if (childContainer.firstChild) {\n            element.appendChild(childContainer.firstChild);\n          }\n        }\n      });\n    }\n    \n    container.appendChild(element);\n  }\n  \n  /**\n   * Schedule element for rebuild\n   * @param {Element} element - Element that needs rebuild\n   */\n  markNeedsBuild(element) {\n    if (!element) {\n      console.warn('[RuntimeEngine] markNeedsBuild called with null element');\n      return;\n    }\n    \n    if (!this.mounted) {\n      if (this.config.debugMode) {\n        console.warn('[RuntimeEngine] markNeedsBuild called but runtime not mounted');\n      }\n      return;\n    }\n    \n    this.dirtyElements.add(element);\n    this.scheduleUpdate();\n  }\n  \n  /**\n   * Schedule update on next frame\n   */\n  scheduleUpdate() {\n    if (this.updateScheduled) return;\n    if (this.disposed) return;\n    \n    this.updateScheduled = true;\n    \n    requestAnimationFrame(() => {\n      this.performUpdate();\n    });\n  }\n  \n  /**\n   * Perform update - rebuild dirty elements\n   */\n  performUpdate() {\n    if (this.disposed) return;\n    if (this.isUpdating) {\n      // Already updating, reschedule\n      this.updateScheduled = true;\n      return;\n    }\n    \n    this.updateScheduled = false;\n    this.isUpdating = true;\n    \n    try {\n      const startTime = performance.now();\n      \n      // Get elements to rebuild\n      const elements = Array.from(this.dirtyElements);\n      \n      if (elements.length === 0) {\n        this.isUpdating = false;\n        return;\n      }\n      \n      // Sort by depth (parents before children)\n      elements.sort((a, b) => a.depth - b.depth);\n      \n      // Rebuild each dirty element\n      for (const element of elements) {\n        if (element.mounted && this.dirtyElements.has(element)) {\n          try {\n            element.rebuild();\n          } catch (error) {\n            console.error(`[RuntimeEngine] Error rebuilding element:`, error);\n            // Continue with other elements\n          }\n        }\n      }\n      \n      // Clear dirty elements\n      this.dirtyElements.clear();\n      \n      // Track performance\n      this.buildTime = performance.now() - startTime;\n      this.lastUpdateTime = Date.now();\n      this.frameCounter++;\n      \n      if (this.config.performanceMonitoring && this.buildTime > 16) {\n        console.warn(`[RuntimeEngine] Slow update: ${this.buildTime.toFixed(2)}ms (${elements.length} elements)`);\n      }\n      \n      if (this.config.debugMode) {\n        console.log(`[RuntimeEngine] Updated ${elements.length} elements in ${this.buildTime.toFixed(2)}ms`);\n      }\n    } finally {\n      this.isUpdating = false;\n      \n      // If more updates were scheduled during update, process them\n      if (this.updateScheduled && this.dirtyElements.size > 0) {\n        this.scheduleUpdate();\n      }\n    }\n  }\n  \n  /**\n   * Unmount entire application\n   */\n  unmount() {\n    if (!this.mounted) {\n      console.warn('[RuntimeEngine] unmount called but not mounted');\n      return;\n    }\n    \n    try {\n      if (this.elementTree) {\n        this.elementTree.unmount();\n        this.elementTree = null;\n      }\n      \n      this.cleanup();\n      \n      if (this.config.debugMode) {\n        console.log('[RuntimeEngine] Unmounted');\n      }\n    } catch (error) {\n      console.error('[RuntimeEngine] Error during unmount:', error);\n    }\n  }\n  \n  /**\n   * Cleanup internal state\n   */\n  cleanup() {\n    this.dirtyElements.clear();\n    this.serviceRegistry.clear();\n    this.mounted = false;\n    this.updateScheduled = false;\n    this.isUpdating = false;\n  }\n  \n  /**\n   * Dispose runtime (cannot be used after this)\n   */\n  dispose() {\n    if (this.disposed) return;\n    \n    this.unmount();\n    \n    this.rootElement = null;\n    this.rootWidget = null;\n    this.buildContext = null;\n    \n    this.disposed = true;\n    \n    if (this.config.debugMode) {\n      console.log('[RuntimeEngine] Disposed');\n    }\n  }\n  \n  /**\n   * Get performance statistics\n   */\n  getStats() {\n    return {\n      mounted: this.mounted,\n      frameCount: this.frameCounter,\n      buildTime: this.buildTime,\n      renderTime: this.renderTime,\n      lastUpdateTime: this.lastUpdateTime,\n      dirtyElements: this.dirtyElements.size,\n      updateScheduled: this.updateScheduled\n    };\n  }\n  \n  /**\n   * Register a service\n   */\n  registerService(name, service) {\n    this.serviceRegistry.set(name, service);\n  }\n  \n  /**\n   * Get a service\n   */\n  getService(name) {\n    return this.serviceRegistry.get(name);\n  }\n  \n  /**\n   * Enable/disable debug mode\n   */\n  setDebugMode(enabled) {\n    this.config.debugMode = enabled;\n  }\n}\n\n\n\nexport { RuntimeEngine\n    };"],
  "mappings": "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",
  "names": ["StatelessElement", "StatefulElement", "ComponentElement", "InheritedElement", "RuntimeEngine", "rootWidget", "containerElement", "startBuild", "vnode", "startRender", "error", "widget", "parent", "widgetType", "container", "element", "key", "value", "child", "childContainer", "startTime", "elements", "a", "b", "name", "service", "enabled"]
}
