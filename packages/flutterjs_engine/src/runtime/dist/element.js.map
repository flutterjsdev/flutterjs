{
  "version": 3,
  "sources": ["../src/element.js"],
  "sourcesContent": ["/**\n * FlutterJS Element System\n * \n * Elements are the live instances that bridge widgets and DOM.\n * They manage the lifecycle, state, and rendering of widgets.\n * \n * Element Hierarchy:\n * - Element (base class)\n *   - StatelessElement (for StatelessWidget)\n *   - StatefulElement (for StatefulWidget)\n *   - InheritedElement (for InheritedWidget)\n *   - ComponentElement (for custom components)\n * \n * Key Concepts:\n * - Widgets are immutable configuration objects\n * - Elements are mutable live instances\n * - Elements own the DOM references and state\n */\n\n// Import BuildContext\nimport { BuildContext } from './build_context.js';\n\n\n\n// ============================================================================\n// DIAGNOSTIC LEVELS - Mirror Dart's DiagnosticLevel\n// ============================================================================\n\nconst DiagnosticLevel = {\n  hidden: 'hidden',\n  fine: 'fine',\n  debug: 'debug',\n  info: 'info',\n  warning: 'warning',\n  hint: 'hint',\n  summary: 'summary',\n  error: 'error',\n  off: 'off'\n};\n\nconst DiagnosticsTreeStyle = {\n  none: 'none',\n  sparse: 'sparse',\n  offstage: 'offstage',\n  dense: 'dense',\n  transition: 'transition',\n  error: 'error',\n  whitespace: 'whitespace',\n  flat: 'flat',\n  singleLine: 'singleLine',\n  errorProperty: 'errorProperty',\n  shallow: 'shallow',\n  truncateChildren: 'truncateChildren'\n};\n\n// ============================================================================\n// DIAGNOSTICABLE MIXIN - Minimal debug support\n// ============================================================================\n\nexport class Diagnosticable {\n  /**\n   * Short one-line description of the object\n   * Usually: ClassName(key: keyValue) or ClassName(unkeyed)\n   */\n  toStringShort() {\n    return `${this.constructor.name}${this.key ? `(key: ${this.key})` : '(unkeyed)'}`;\n  }\n\n  /**\n   * Get diagnostics node for this object\n   * Used by debugging tools and toStringDeep\n   */\n  toDiagnosticsNode(name = null, style = DiagnosticsTreeStyle.sparse) {\n    return {\n      name: name || this.constructor.name,\n      value: this,\n      style: style,\n      toString: () => this.toStringShort()\n    };\n  }\n\n  /**\n   * Fill in properties for debugging\n   * Override in subclasses to add custom properties\n   * \n   * Example:\n   * debugFillProperties(props) {\n   *   props.push({ name: 'enabled', value: this.enabled });\n   *   props.push({ name: 'count', value: this.count });\n   * }\n   */\n  debugFillProperties(properties) {\n    // Base implementation: add key if present\n    if (this.key !== null && this.key !== undefined) {\n      properties.push({ name: 'key', value: this.key });\n    }\n  }\n\n  /**\n   * Get all debug info for this object\n   * Returns: { type, key, properties, style }\n   */\n  debugInfo() {\n    const properties = [];\n    this.debugFillProperties(properties);\n\n    return {\n      type: this.constructor.name,\n      key: this.key || null,\n      properties: properties,\n      style: this.style || DiagnosticsTreeStyle.sparse,\n      description: this.toStringShort()\n    };\n  }\n\n  /**\n   * Development-only string representation\n   * In production (NODE_ENV !== 'development'), returns short version\n   */\n  toString() {\n    if (process.env.NODE_ENV === 'development') {\n      const info = this.debugInfo();\n      if (info.properties.length === 0) {\n        return this.toStringShort();\n      }\n      const propsStr = info.properties\n        .map(p => `${p.name}: ${p.value}`)\n        .join(', ');\n      return `${this.toStringShort()} { ${propsStr} }`;\n    }\n    return this.toStringShort();\n  }\n}\n\n\n\n/**\n * Base Element Class\n * \n * Represents a node in the element tree. Elements are created from widgets\n * and manage the actual rendering and lifecycle.\n */\nclass Element  extends Diagnosticable{\n  constructor(widget, parent, runtime) {\n    if (!widget) {\n      throw new Error('Widget is required for Element creation');\n    }\n    \n    if (!runtime) {\n      throw new Error('Runtime is required for Element creation');\n    }\n    \n    this.widget = widget;              // Widget configuration (immutable)\n    this.parent = parent;              // Parent element\n    this.runtime = runtime;            // Runtime engine reference\n    \n    // Element tree structure\n    this.children = [];                // Child elements\n    this.childMap = new Map();         // key \u2192 child element mapping\n    \n    // Rendering state\n    this.vnode = null;                 // Current virtual node\n    this.domNode = null;               // DOM reference\n    \n    // Lifecycle state\n    this.mounted = false;              // Is element mounted?\n    this.dirty = false;                // Needs rebuild?\n    this.building = false;             // Currently building?\n    \n    // Tree position\n    this.depth = parent ? parent.depth + 1 : 0;\n    \n    // Identity\n    this.key = widget.key;             // For reconciliation\n    this.id = Element.generateId();    // Unique ID\n    \n    // Metadata\n    this.buildCount = 0;               // Number of times built\n    this.lastBuildTime = 0;            // Last build timestamp\n    this.lastBuildDuration = 0;        // Last build duration (ms)\n  }\n  \n  /**\n   * Build VNode from widget\n   * Subclasses must override this method\n   */\n  build() {\n    throw new Error(`${this.constructor.name}.build() must be implemented by subclass`);\n  }\n  \n  /**\n   * Mount element (first time attachment to tree)\n   * Called when element is first added to the tree\n   */\n  mount() {\n    if (this.mounted) {\n      console.warn(`[Element] ${this.id} already mounted`);\n      return;\n    }\n    \n    try {\n      // Mark as mounted\n      this.mounted = true;\n      \n      // Build initial VNode\n      this.vnode = this.performBuild();\n      \n      // Mount children\n      this.children.forEach(child => {\n        if (!child.mounted) {\n          child.mount();\n        }\n      });\n      \n      // Call didMount lifecycle hook\n      this.didMount();\n    } catch (error) {\n      this.mounted = false;\n      throw new Error(`Failed to mount ${this.constructor.name}: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Update element with new widget\n   * Called when parent rebuilds with new widget configuration\n   */\n  update(newWidget) {\n    if (!newWidget) {\n      throw new Error('New widget is required for update');\n    }\n    \n    const oldWidget = this.widget;\n    \n    // Update widget reference\n    this.widget = newWidget;\n    \n    // Check if rebuild needed\n    if (this.shouldRebuild(oldWidget, newWidget)) {\n      this.markNeedsBuild();\n    }\n    \n    // Call lifecycle hook\n    this.didUpdateWidget(oldWidget, newWidget);\n  }\n  \n  /**\n   * Rebuild element\n   * Called when element is marked dirty\n   */\n  rebuild() {\n    if (!this.mounted) {\n      console.warn(`[Element] Cannot rebuild unmounted element ${this.id}`);\n      return;\n    }\n    \n    if (this.building) {\n      console.warn(`[Element] Recursive rebuild detected for ${this.id}`);\n      return;\n    }\n    \n    try {\n      this.building = true;\n      \n      const oldVNode = this.vnode;\n      \n      // Perform build\n      this.vnode = this.performBuild();\n      \n      // Apply changes (diffing happens here in full implementation)\n      this.applyChanges(oldVNode, this.vnode);\n      \n      // Clear dirty flag\n      this.dirty = false;\n    } catch (error) {\n      console.error(`[Element] Rebuild failed for ${this.id}:`, error);\n      throw error;\n    } finally {\n      this.building = false;\n    }\n  }\n  \n  /**\n   * Perform build with timing and error handling\n   */\n  performBuild() {\n    const startTime = performance.now();\n    \n    try {\n      const vnode = this.build();\n      \n      if (!vnode) {\n        throw new Error('build() returned null or undefined');\n      }\n      \n      this.buildCount++;\n      this.lastBuildTime = Date.now();\n      this.lastBuildDuration = performance.now() - startTime;\n      \n      return vnode;\n    } catch (error) {\n      throw new Error(`Build failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Apply changes from VNode diff\n   * (Simplified for now, full diffing in Phase 5.2)\n   */\n  applyChanges(oldVNode, newVNode) {\n    // In full implementation, this would:\n    // 1. Diff oldVNode vs newVNode\n    // 2. Generate patches\n    // 3. Apply patches to DOM\n    \n    // For now, just track the change\n    if (this.runtime.config && this.runtime.config.debugMode) {\n      console.log(`[Element] Applied changes to ${this.id}`);\n    }\n  }\n  \n  /**\n   * Mark element as needing rebuild\n   */\n  markNeedsBuild() {\n    if (this.dirty) {\n      return; // Already marked\n    }\n    \n    if (!this.mounted) {\n      console.warn(`[Element] Cannot mark unmounted element ${this.id} dirty`);\n      return;\n    }\n    \n    this.dirty = true;\n    \n    // Notify runtime\n    if (this.runtime && this.runtime.markNeedsBuild) {\n      this.runtime.markNeedsBuild(this);\n    }\n  }\n  \n  /**\n   * Unmount element\n   * Called when element is removed from tree\n   */\n  unmount() {\n    if (!this.mounted) {\n      return;\n    }\n    \n    try {\n      // Call lifecycle hook\n      this.willUnmount();\n      \n      // Unmount children first\n      this.children.forEach(child => {\n        if (child.mounted) {\n          child.unmount();\n        }\n      });\n      \n      // Clear references\n      this.children = [];\n      this.childMap.clear();\n      this.vnode = null;\n      this.domNode = null;\n      \n      // Mark as unmounted\n      this.mounted = false;\n      this.dirty = false;\n      \n      // Call lifecycle hook\n      this.didUnmount();\n    } catch (error) {\n      console.error(`[Element] Unmount failed for ${this.id}:`, error);\n    }\n  }\n  \n  /**\n   * Determine if widget update should trigger rebuild\n   */\n  shouldRebuild(oldWidget, newWidget) {\n    // If same reference, no rebuild needed\n    if (oldWidget === newWidget) {\n      return false;\n    }\n    \n    // If different types, rebuild needed\n    if (oldWidget.constructor !== newWidget.constructor) {\n      return true;\n    }\n    \n    // Deep comparison of widget properties\n    return !this.areWidgetsEqual(oldWidget, newWidget);\n  }\n  \n  /**\n   * Compare two widgets for equality\n   */\n  areWidgetsEqual(w1, w2) {\n    // Check constructor\n    if (w1.constructor !== w2.constructor) {\n      return false;\n    }\n    \n    // Get all enumerable properties\n    const keys1 = Object.keys(w1);\n    const keys2 = Object.keys(w2);\n    \n    // Check property count\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    \n    // Compare each property\n    return keys1.every(key => {\n      const val1 = w1[key];\n      const val2 = w2[key];\n      \n      // Skip functions (they're usually event handlers)\n      if (typeof val1 === 'function' && typeof val2 === 'function') {\n        return true;\n      }\n      \n      // Deep comparison for objects\n      if (typeof val1 === 'object' && typeof val2 === 'object') {\n        return JSON.stringify(val1) === JSON.stringify(val2);\n      }\n      \n      // Primitive comparison\n      return val1 === val2;\n    });\n  }\n  \n  /**\n   * Add child element\n   */\n  addChild(child) {\n    if (!child) {\n      throw new Error('Child element is required');\n    }\n    \n    this.children.push(child);\n    \n    // Track by key if available\n    if (child.key) {\n      this.childMap.set(child.key, child);\n    }\n    \n    child.parent = this;\n  }\n  \n  /**\n   * Remove child element\n   */\n  removeChild(child) {\n    const index = this.children.indexOf(child);\n    \n    if (index !== -1) {\n      this.children.splice(index, 1);\n    }\n    \n    if (child.key) {\n      this.childMap.delete(child.key);\n    }\n    \n    child.parent = null;\n  }\n  \n  /**\n   * Find child by key\n   */\n  findChildByKey(key) {\n    return this.childMap.get(key);\n  }\n  \n  /**\n   * Get ancestor element of specific type\n   */\n  findAncestorOfType(ElementType) {\n    let current = this.parent;\n    \n    while (current) {\n      if (current instanceof ElementType) {\n        return current;\n      }\n      current = current.parent;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Visit all ancestors\n   */\n  visitAncestors(visitor) {\n    let current = this.parent;\n    \n    while (current) {\n      const shouldContinue = visitor(current);\n      if (shouldContinue === false) {\n        break;\n      }\n      current = current.parent;\n    }\n  }\n  \n  // Lifecycle Hooks (override in subclasses)\n  \n  didMount() {\n    // Called after first mount\n  }\n  \n  didUpdateWidget(oldWidget, newWidget) {\n    // Called after widget update\n  }\n  \n  willUnmount() {\n    // Called before unmount\n  }\n  \n  didUnmount() {\n    // Called after unmount\n  }\n  \n  /**\n   * Get element statistics\n   */\n  getStats() {\n    return {\n      id: this.id,\n      type: this.constructor.name,\n      mounted: this.mounted,\n      dirty: this.dirty,\n      depth: this.depth,\n      childCount: this.children.length,\n      buildCount: this.buildCount,\n      lastBuildDuration: this.lastBuildDuration,\n      hasKey: !!this.key\n    };\n  }\n  \n  /**\n   * Generate unique element ID\n   */\n  static generateId() {\n    return `el_${++Element._counter}`;\n  }\n  \n  /**\n   * Reset ID counter (for testing)\n   */\n  static resetCounter() {\n    Element._counter = 0;\n  }\n}\n\n// Initialize counter\nElement._counter = 0;\n\n/**\n * StatelessElement\n * \n * Element for StatelessWidget. These elements don't have state,\n * they just build based on their widget's configuration.\n */\nclass StatelessElement extends Element {\n  constructor(widget, parent, runtime) {\n    super(widget, parent, runtime);\n  }\n  \n  build() {\n    // Call widget's build method\n    const context = this.buildContext();\n    \n    try {\n      const result = this.widget.build(context);\n      \n      if (!result) {\n        throw new Error('StatelessWidget.build() returned null');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(`StatelessWidget build failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Create BuildContext for this element\n   */\n  buildContext() {\n    return new BuildContext(this, this.runtime);\n  }\n}\n\n/**\n * StatefulElement\n * \n * Element for StatefulWidget. These elements own a State object\n * that persists across rebuilds.\n */\nclass StatefulElement extends Element {\n  constructor(widget, parent, runtime) {\n    super(widget, parent, runtime);\n    \n    // Create state instance\n    if (!widget.createState || typeof widget.createState !== 'function') {\n      throw new Error('StatefulWidget must implement createState()');\n    }\n    \n    this.state = widget.createState();\n    \n    if (!this.state) {\n      throw new Error('createState() returned null or undefined');\n    }\n    \n    // Link state to element and widget\n    this.state._element = this;\n    this.state._widget = widget;\n    this.state._mounted = false;\n  }\n  \n  build() {\n    // Call state's build method\n    const context = this.buildContext();\n    \n    try {\n      if (!this.state.build || typeof this.state.build !== 'function') {\n        throw new Error('State must implement build() method');\n      }\n      \n      const result = this.state.build(context);\n      \n      if (!result) {\n        throw new Error('State.build() returned null');\n      }\n      \n      return result;\n    } catch (error) {\n      throw new Error(`StatefulWidget build failed: ${error.message}`);\n    }\n  }\n  \n  mount() {\n    // Call state's initState\n    if (this.state.initState && typeof this.state.initState === 'function') {\n      try {\n        this.state.initState();\n      } catch (error) {\n        console.error(`[StatefulElement] initState failed:`, error);\n      }\n    }\n    \n    // Mark state as mounted\n    this.state._mounted = true;\n    \n    // Call parent mount\n    super.mount();\n  }\n  \n  update(newWidget) {\n    const oldWidget = this.widget;\n    \n    // Update widget reference\n    this.widget = newWidget;\n    this.state._widget = newWidget;\n    \n    // Call state's didUpdateWidget\n    if (this.state.didUpdateWidget && typeof this.state.didUpdateWidget === 'function') {\n      try {\n        this.state.didUpdateWidget(oldWidget);\n      } catch (error) {\n        console.error(`[StatefulElement] didUpdateWidget failed:`, error);\n      }\n    }\n    \n    // Check if rebuild needed\n    if (this.shouldRebuild(oldWidget, newWidget)) {\n      this.markNeedsBuild();\n    }\n  }\n  \n  unmount() {\n    // Call state's dispose\n    if (this.state.dispose && typeof this.state.dispose === 'function') {\n      try {\n        this.state.dispose();\n      } catch (error) {\n        console.error(`[StatefulElement] dispose failed:`, error);\n      }\n    }\n    \n    // Mark state as unmounted\n    this.state._mounted = false;\n    \n    // Call parent unmount\n    super.unmount();\n  }\n  \n  /**\n   * Create BuildContext for this element\n   */\n  buildContext() {\n    return new BuildContext(this, this.runtime, this.state);\n  }\n  \n  /**\n   * Get state statistics\n   */\n  getStats() {\n    const stats = super.getStats();\n    return {\n      ...stats,\n      hasState: !!this.state,\n      stateMounted: this.state ? this.state._mounted : false\n    };\n  }\n}\n\n/**\n * InheritedElement\n * \n * Element for InheritedWidget. These elements provide values\n * down the tree and notify dependents when values change.\n */\nclass InheritedElement extends Element {\n  constructor(widget, parent, runtime) {\n    super(widget, parent, runtime);\n    \n    // Track dependent elements\n    this.dependents = new Set();\n  }\n  \n  build() {\n    // InheritedWidget typically wraps a child\n    if (!this.widget.child) {\n      throw new Error('InheritedWidget must have a child');\n    }\n    \n    // For now, just return a simple representation\n    // In full implementation, this would build the child\n    return {\n      tag: 'div',\n      props: {\n        'data-widget': 'InheritedWidget',\n        'data-type': this.widget.constructor.name\n      },\n      children: []\n    };\n  }\n  \n  /**\n   * Register dependent element\n   */\n  addDependent(element) {\n    if (!element) {\n      throw new Error('Element is required');\n    }\n    \n    this.dependents.add(element);\n  }\n  \n  /**\n   * Unregister dependent element\n   */\n  removeDependent(element) {\n    this.dependents.delete(element);\n  }\n  \n  /**\n   * Check if has dependent\n   */\n  hasDependent(element) {\n    return this.dependents.has(element);\n  }\n  \n  update(newWidget) {\n    const oldWidget = this.widget;\n    \n    // Update widget\n    super.update(newWidget);\n    \n    // Check if should notify dependents\n    if (this.widget.updateShouldNotify && \n        typeof this.widget.updateShouldNotify === 'function') {\n      try {\n        const shouldNotify = this.widget.updateShouldNotify(oldWidget);\n        \n        if (shouldNotify) {\n          this.notifyDependents();\n        }\n      } catch (error) {\n        console.error(`[InheritedElement] updateShouldNotify failed:`, error);\n      }\n    }\n  }\n  \n  /**\n   * Notify all dependents to rebuild\n   */\n  notifyDependents() {\n    this.dependents.forEach(element => {\n      if (element.mounted && !element.dirty) {\n        element.markNeedsBuild();\n      }\n    });\n  }\n  \n  unmount() {\n    // Clear dependents\n    this.dependents.clear();\n    \n    // Call parent unmount\n    super.unmount();\n  }\n  \n  /**\n   * Get statistics\n   */\n  getStats() {\n    const stats = super.getStats();\n    return {\n      ...stats,\n      dependentCount: this.dependents.size\n    };\n  }\n}\n\n/**\n * ComponentElement\n * \n * Generic element for custom components that don't fit\n * the standard widget patterns.\n */\nclass ComponentElement extends Element {\n  constructor(widget, parent, runtime) {\n    super(widget, parent, runtime);\n    \n    this.componentState = {};\n  }\n  \n  build() {\n    // Call widget's render or build method\n    const method = this.widget.render || this.widget.build;\n    \n    if (!method || typeof method !== 'function') {\n      throw new Error('ComponentElement widget must have render() or build() method');\n    }\n    \n    const context = this.buildContext();\n    \n    try {\n      return method.call(this.widget, context);\n    } catch (error) {\n      throw new Error(`Component build failed: ${error.message}`);\n    }\n  }\n  \n  buildContext() {\n    return {\n      element: this,\n      runtime: this.runtime,\n      widget: this.widget,\n      state: this.componentState,\n      \n      setState: (updates) => {\n        Object.assign(this.componentState, updates);\n        this.markNeedsBuild();\n      }\n    };\n  }\n}\n\n\n\nexport {\n    Element,\n    StatelessElement,\n    StatefulElement,\n    InheritedElement,\n    ComponentElement,\n    DiagnosticLevel\n};"],
  "mappings": "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",
  "names": ["BuildContext", "DiagnosticLevel", "DiagnosticsTreeStyle", "Diagnosticable", "name", "style", "properties", "Element", "widget", "parent", "runtime", "child", "error", "newWidget", "oldWidget", "oldVNode", "startTime", "vnode", "newVNode", "w1", "w2", "keys1", "keys2", "key", "val1", "val2", "index", "ElementType", "current", "visitor", "StatelessElement", "context", "result", "StatefulElement", "InheritedElement", "element", "ComponentElement", "method", "updates"]
}
