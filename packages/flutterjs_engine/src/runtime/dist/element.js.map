{
  "version": 3,
  "sources": ["../src/element.js"],
  "sourcesContent": ["/**\r\n * FlutterJS Element System - FIXED VERSION\r\n * \r\n * \u2705 CRITICAL FIX: StatefulElement.mount() now calls state._mount()\r\n * This ensures this.widget is properly initialized in State\r\n * \r\n * Elements are the live instances that bridge widgets and DOM.\r\n * They manage the lifecycle, state, and rendering of widgets.\r\n */\r\n\r\nimport { BuildContext } from './build_context.js';\r\nimport { VNodeDiffer } from '@flutterjs/vdom/vnode_differ';\r\nimport { PatchApplier } from '@flutterjs/vdom/patch_applier';\r\n// NOTE: InheritedElement is NOT imported here to avoid circular dependency.\r\n// InheritedWidget provides its own createElement() method that returns InheritedElement.\r\n\r\n// ============================================================================\r\n// DIAGNOSTIC LEVELS\r\n// ============================================================================\r\n\r\nconst DiagnosticLevel = {\r\n  hidden: 'hidden',\r\n  fine: 'fine',\r\n  debug: 'debug',\r\n  info: 'info',\r\n  warning: 'warning',\r\n  hint: 'hint',\r\n  summary: 'summary',\r\n  error: 'error',\r\n  off: 'off'\r\n};\r\n\r\nconst DiagnosticsTreeStyle = {\r\n  none: 'none',\r\n  sparse: 'sparse',\r\n  offstage: 'offstage',\r\n  dense: 'dense',\r\n  transition: 'transition',\r\n  error: 'error',\r\n  whitespace: 'whitespace',\r\n  flat: 'flat',\r\n  singleLine: 'singleLine',\r\n  errorProperty: 'errorProperty',\r\n  shallow: 'shallow',\r\n  truncateChildren: 'truncateChildren'\r\n};\r\n\r\n// ============================================================================\r\n// DIAGNOSTICABLE MIXIN\r\n// ============================================================================\r\n\r\nexport class Diagnosticable {\r\n  toStringShort() {\r\n    return `${this.constructor.name}${this.key ? `(key: ${this.key})` : '(unkeyed)'}`;\r\n  }\r\n\r\n  toDiagnosticsNode(name = null, style = DiagnosticsTreeStyle.sparse) {\r\n    return {\r\n      name: name || this.constructor.name,\r\n      value: this,\r\n      style: style,\r\n      toString: () => this.toStringShort()\r\n    };\r\n  }\r\n\r\n  debugFillProperties(properties) {\r\n    if (this.key !== null && this.key !== undefined) {\r\n      properties.push({ name: 'key', value: this.key });\r\n    }\r\n  }\r\n\r\n  debugInfo() {\r\n    const properties = [];\r\n    this.debugFillProperties(properties);\r\n\r\n    return {\r\n      type: this.constructor.name,\r\n      key: this.key || null,\r\n      properties: properties,\r\n      style: this.style || DiagnosticsTreeStyle.sparse,\r\n      description: this.toStringShort()\r\n    };\r\n  }\r\n\r\n  toString() {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      const info = this.debugInfo();\r\n      if (info.properties.length === 0) {\r\n        return this.toStringShort();\r\n      }\r\n      const propsStr = info.properties\r\n        .map(p => `${p.name}: ${p.value}`)\r\n        .join(', ');\r\n      return `${this.toStringShort()} { ${propsStr} }`;\r\n    }\r\n    return this.toStringShort();\r\n  }\r\n}\r\n\r\n\r\n// \u2705 Helper function to check if something is a REAL VNode\r\nfunction isRealVNode(obj) {\r\n  if (!obj || typeof obj !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  // Check for VNode properties AND structure\r\n  const hasTag = typeof obj.tag === 'string';  // \u2705 tag must be STRING (HTML tag name)\r\n  const hasChildren = Array.isArray(obj.children) || obj.children === null || obj.children === undefined;\r\n  const hasProps = obj.props === null || obj.props === undefined || typeof obj.props === 'object';\r\n\r\n  // VNode should NOT have build() or createState() methods\r\n  const isNotWidget = typeof obj.build !== 'function' && typeof obj.createState !== 'function';\r\n\r\n  // All conditions must be true\r\n  return hasTag && hasChildren && hasProps && isNotWidget;\r\n}\r\n\r\n// \u2705 Helper function to check if something is a Widget\r\nfunction isWidget(obj) {\r\n  if (!obj || typeof obj !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  return (\r\n    typeof obj.build === 'function' ||\r\n    typeof obj.createState === 'function' ||\r\n    typeof obj.render === 'function'\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * Base Element Class\r\n */\r\nclass Element extends Diagnosticable {\r\n  constructor(widget, parent = null, runtime = null) {\r\n    super();\r\n\r\n    if (!widget) {\r\n      throw new Error('Widget is required for Element creation');\r\n    }\r\n\r\n    if (!runtime) {\r\n      throw new Error('RUNTIME IS UNDEFINED! Runtime is required for Element creation');\r\n    }\r\n\r\n    this._widget = widget;\r\n    this._parent = parent;\r\n    this.runtime = runtime;\r\n\r\n    this._children = [];\r\n    this._childMap = new Map();\r\n\r\n    this._vnode = null;\r\n    this._domNode = null;\r\n\r\n    this._mounted = false;\r\n    this._dirty = false;\r\n    this._building = false;\r\n    this._shouldPatch = true; // Default to true, subclasses/build will disable if delegating\r\n\r\n    this._depth = parent ? (parent._depth || 0) + 1 : 0;\r\n\r\n    this.key = widget.key;\r\n    this._id = `el_${Element._nextId++}`;\r\n    console.log(`[Element] \uD83C\uDD95 Created ${this._id} for ${widget?.constructor?.name}`);\r\n\r\n    this._buildCount = 0;\r\n    this._lastBuildTime = 0;\r\n    this._lastBuildDuration = 0;\r\n\r\n    this._context = null;\r\n  }\r\n\r\n  // ============================================================================\r\n  // PROPERTIES\r\n  // ============================================================================\r\n\r\n  get widget() {\r\n    return this._widget;\r\n  }\r\n\r\n  set widget(newWidget) {\r\n    this._widget = newWidget;\r\n  }\r\n\r\n  get parent() {\r\n    return this._parent;\r\n  }\r\n\r\n  set parent(p) {\r\n    this._parent = p;\r\n  }\r\n\r\n  get children() {\r\n    return this._children;\r\n  }\r\n\r\n  get depth() {\r\n    return this._depth;\r\n  }\r\n\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  get mounted() {\r\n    return this._mounted;\r\n  }\r\n\r\n  get dirty() {\r\n    return this._dirty;\r\n  }\r\n\r\n  get building() {\r\n    return this._building;\r\n  }\r\n\r\n  get vnode() {\r\n    return this._vnode;\r\n  }\r\n\r\n  set vnode(v) {\r\n    this._vnode = v;\r\n  }\r\n\r\n  get domNode() {\r\n    return this._domNode;\r\n  }\r\n\r\n  set domNode(d) {\r\n    this._domNode = d;\r\n  }\r\n\r\n  get context() {\r\n    if (!this._context) {\r\n      this._context = new BuildContext(this, this.runtime);\r\n    }\r\n    return this._context;\r\n  }\r\n\r\n  // ============================================================================\r\n  // CORE METHODS\r\n  // ============================================================================\r\n\r\n  getElementId() {\r\n    return this._id;\r\n  }\r\n\r\n  getWidgetPath() {\r\n    if (this._widgetPath) return this._widgetPath;\r\n\r\n    const name = this.widget?.constructor?.name || 'Unknown';\r\n    const parentPath = this.parent?.getWidgetPath ? this.parent.getWidgetPath() : '';\r\n\r\n    this._widgetPath = parentPath ? `${parentPath}/${name}` : name;\r\n    return this._widgetPath;\r\n  }\r\n\r\n  getIdentificationStrategy() {\r\n    return this.key ? 'key' : 'id';\r\n  }\r\n\r\n  performRebuild() {\r\n    throw new Error(`${this.constructor.name}.performRebuild() must be implemented by subclass`);\r\n  }\r\n\r\n  mount(parent = null) {\r\n    if (this._mounted) {\r\n      console.warn(`[Element] ${this._id} already mounted`);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this._mounted = true;\r\n\r\n      if (parent) {\r\n        this._parent = parent;\r\n        this._depth = (parent._depth || 0) + 1;\r\n      }\r\n\r\n      this._vnode = this.performRebuild();\r\n\r\n      this._children.forEach(child => {\r\n        if (!child._mounted) {\r\n          child.mount(this);\r\n        }\r\n      });\r\n\r\n      this.didMount();\r\n\r\n      // Mark that initial mount is complete\r\n      // This prevents applyChanges from running on the first rebuild after mount\r\n      this._initialMountComplete = true;\r\n    } catch (error) {\r\n      this._mounted = false;\r\n      throw new Error(`Failed to mount ${this.constructor.name}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  rebuild() {\r\n    if (!this._mounted) {\r\n      console.warn(`[Element] Cannot rebuild unmounted element ${this._id}`);\r\n      return;\r\n    }\r\n\r\n    if (this._building) {\r\n      console.warn(`[Element] Recursive rebuild detected for ${this._id}`);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this._building = true;\r\n\r\n      console.log(`\uD83D\uDD04 [Element.rebuild] START for ${this._id} (${this.widget?.constructor?.name})`);\r\n      console.log(`   _shouldPatch BEFORE performRebuild:`, this._shouldPatch);\r\n\r\n      const oldVNode = this._vnode;\r\n      console.log(`   oldVNode:`, oldVNode?.tag, oldVNode?._element);\r\n\r\n      this._vnode = this.performRebuild();\r\n\r\n      console.log(`   newVNode:`, this._vnode?.tag, this._vnode?._element);\r\n      console.log(`   _shouldPatch AFTER performRebuild:`, this._shouldPatch);\r\n\r\n      // Only apply changes if this element is responsible for patching\r\n      // AND this is not the first rebuild after mount\r\n      if (this._shouldPatch && this._initialMountComplete) {\r\n        console.log(`\u2705 [Element.rebuild] Calling applyChanges for ${this._id}`);\r\n        this.applyChanges(oldVNode, this._vnode);\r\n      } else {\r\n        if (!this._initialMountComplete) {\r\n          console.log(`\u23ED\uFE0F [Element.rebuild] Skipping applyChanges for ${this._id} (first rebuild after mount)`);\r\n        } else if (!oldVNode) {\r\n          console.log(`\u23ED\uFE0F [Element.rebuild] Skipping applyChanges for ${this._id} (initial mount, oldVNode is null)`);\r\n        } else {\r\n          console.log(`\u23ED\uFE0F [Element.rebuild] Skipping applyChanges for ${this._id} (_shouldPatch = false)`);\r\n        }\r\n        // If delegating, we still need to update our DOM reference from the child's result\r\n        if (this._vnode && this._vnode._element) {\r\n          this._domNode = this._vnode._element;\r\n        }\r\n      }\r\n\r\n      this._dirty = false; // Mark clean regardless\r\n    } catch (error) {\r\n      console.error(`[Element] Rebuild failed for ${this._id}:`, error);\r\n      throw error;\r\n    } finally {\r\n      this._building = false;\r\n    }\r\n  }\r\n\r\n  applyChanges(oldVNode, newVNode) {\r\n    console.log(`[Element.applyChanges] START for ${this._id} (${this.widget?.constructor.name})`);\r\n    console.log(`  oldVNode:`, {\r\n      tag: oldVNode?.tag,\r\n      hasElement: !!oldVNode?._element,\r\n      element: oldVNode?._element?.tagName\r\n    });\r\n    console.log(`  newVNode:`, {\r\n      tag: newVNode?.tag,\r\n      hasElement: !!newVNode?._element,\r\n      element: newVNode?._element?.tagName\r\n    });\r\n\r\n    if (this.runtime.config && this.runtime.config.debugMode) {\r\n      console.log(`[Element] Applied changes to ${this._id}`);\r\n    }\r\n\r\n    // \u2705 CRITICAL FIX: Handle case where BOTH VNodes have no DOM elements\r\n    // This happens with Navigator - the VNodes are wrappers without real DOM\r\n    // IMPORTANT: Only do this AFTER the first applyChanges (not during initial render)\r\n    if (this._hasAppliedChanges && oldVNode && newVNode && !oldVNode?._element && !newVNode?._element && this.runtime.renderer) {\r\n      // Check if VNodes are actually different (children changed)\r\n      const oldChildren = oldVNode.children || [];\r\n      const newChildren = newVNode.children || [];\r\n      const childrenChanged = oldChildren.length !== newChildren.length ||\r\n        JSON.stringify(oldChildren) !== JSON.stringify(newChildren);\r\n\r\n      if (childrenChanged) {\r\n        console.log(`[Element] \uD83D\uDD04 Both VNodes have no DOM but children changed - forcing full re-render`);\r\n\r\n        try {\r\n          // Find the root DOM node from this element or parent\r\n          let targetElement = this._domNode;\r\n\r\n          if (!targetElement && this._parent) {\r\n            // Try to get parent's DOM node\r\n            targetElement = this._parent._domNode;\r\n          }\r\n\r\n          if (!targetElement) {\r\n            // Last resort: find from document\r\n            const rootElement = document.getElementById('root');\r\n            if (rootElement && rootElement.firstChild) {\r\n              targetElement = rootElement.firstChild;\r\n            }\r\n          }\r\n\r\n          if (targetElement) {\r\n            console.log(`[Element] \uD83C\uDFA8 Found target element, rendering new VNode`);\r\n\r\n            // Clear the target and render new VNode\r\n            targetElement.innerHTML = '';\r\n            this.runtime.renderer.render(newVNode, targetElement);\r\n\r\n            // Update VNode reference\r\n            newVNode._element = targetElement.firstChild;\r\n            if (newVNode._element) {\r\n              newVNode._element._vnode = newVNode;\r\n              this._domNode = newVNode._element;\r\n            }\r\n\r\n            console.log(`[Element] \u2705 Successfully re-rendered for VNode change`);\r\n            return;\r\n          } else {\r\n            console.warn(`[Element] \u26A0\uFE0F Could not find target element for re-render`);\r\n          }\r\n        } catch (error) {\r\n          console.error(`[Element] \u274C Failed to re-render:`, error);\r\n        }\r\n      } else {\r\n        console.log(`[Element] \u2139\uFE0F Both VNodes have no DOM but children unchanged - skipping re-render`);\r\n      }\r\n    }\r\n\r\n    // \u2705 CRITICAL FIX: Handle case where new VNode has no DOM element\r\n    // This happens when widget type changes (e.g., HomeScreen \u2192 DetailsScreen)\r\n    // IMPORTANT: Only apply during navigation (when mounted), NOT during initial mount\r\n    if (this._mounted && oldVNode && oldVNode._element && !newVNode._element && this.runtime.renderer) {\r\n      console.log(`[Element] \uD83D\uDD04 Widget type changed - rendering new VNode and replacing DOM`);\r\n\r\n      try {\r\n        const oldDomNode = oldVNode._element;\r\n        const parentNode = oldDomNode.parentNode;\r\n\r\n        if (parentNode) {\r\n          // Create temporary container to render new VNode\r\n          const tempContainer = document.createElement('div');\r\n\r\n          // Render new VNode to temp container\r\n          this.runtime.renderer.render(newVNode, tempContainer);\r\n\r\n          // Get the rendered DOM node\r\n          const newDomNode = tempContainer.firstChild;\r\n\r\n          if (newDomNode) {\r\n            // Replace old DOM with new DOM\r\n            parentNode.replaceChild(newDomNode, oldDomNode);\r\n\r\n            // Update VNode's DOM reference\r\n            newVNode._element = newDomNode;\r\n            newDomNode._vnode = newVNode;\r\n\r\n            // Update element's DOM reference\r\n            if (this._domNode === oldDomNode) {\r\n              this._domNode = newDomNode;\r\n            }\r\n\r\n            console.log(`[Element] \u2705 Successfully replaced DOM for widget type change`);\r\n            return;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`[Element] \u274C Failed to replace DOM for widget type change:`, error);\r\n      }\r\n    } else if (oldVNode && oldVNode._element && newVNode._element) {\r\n      console.log(`[Element] \u2139\uFE0F Both VNodes have DOM elements - using normal patching`);\r\n    }\r\n\r\n    // \u2705 DIRECT DOM PATCHING to preserve state\r\n    if (oldVNode && oldVNode._element && this.runtime.renderer) {\r\n\r\n      // \u2705 TRY DIFFING FIRST (Fine-grained updates)\r\n      if (oldVNode._element.parentNode) {\r\n        try {\r\n          const domNode = oldVNode._element;\r\n          const parent = domNode.parentNode;\r\n          // Find index of current node\r\n          const index = Array.from(parent.childNodes).indexOf(domNode);\r\n\r\n          if (index !== -1) {\r\n            if (this.runtime.config && this.runtime.config.debugMode) {\r\n              console.log(`[Element] Diffing at index ${index}`);\r\n            }\r\n\r\n            // Generate patches\r\n            const patches = VNodeDiffer.diff(oldVNode, newVNode, index);\r\n\r\n            if (patches.length > 0) {\r\n              console.log(`[Element] Applying ${patches.length} patches to ${this._id} (${this.widget?.constructor.name})`);\r\n              patches.forEach(p => console.log(`   - Patch: ${p.type} at index ${p.index}, content:`, p.content));\r\n\r\n              // Apply patches\r\n              const result = PatchApplier.apply(parent, patches);\r\n              if (!result.success) {\r\n                console.error('[Element] PatchApplier failed:', result.errors);\r\n              } else {\r\n                console.log('[Element] Patches applied successfully');\r\n              }\r\n\r\n              // \u2705 CRITICAL FIX: Ensure newVNode gets the DOM reference\r\n              if (!newVNode._element) {\r\n                newVNode._element = oldVNode._element;\r\n              }\r\n\r\n              // Update local DOM reference if the root node was replaced or just carried over\r\n              if (this._domNode === domNode) {\r\n                this._domNode = newVNode._element;\r\n              }\r\n            } else {\r\n              console.log(`[Element] No patches generated for ${this._id} (${this.widget?.constructor.name})`);\r\n              // No changes, but ensure new VNode has element reference\r\n              newVNode._element = oldVNode._element;\r\n              if (newVNode._element) {\r\n                newVNode._element._vnode = newVNode;\r\n              }\r\n            }\r\n            return; // \u2705 Success, skip fallback\r\n          }\r\n        } catch (e) {\r\n          console.warn('[Element] Diffing failed, falling back to replace', e);\r\n        }\r\n      }\r\n\r\n      // \u26A0\uFE0F FALLBACK: Coarse-grained update (Full Replacement)\r\n      // This happens if diffing fails or element has no parent\r\n      if (this.runtime.config && this.runtime.config.debugMode) {\r\n        console.log(`[Element] Fallback: Replacing DOM for ${this._id}`);\r\n      }\r\n\r\n      try {\r\n        const newDomNode = this.runtime.renderer.replaceElement(oldVNode._element, newVNode);\r\n\r\n        if (this._domNode === oldVNode._element) {\r\n          this._domNode = newDomNode;\r\n        }\r\n      } catch (e) {\r\n        console.error(`[Element] Failed to patch DOM for ${this._id}:`, e);\r\n      }\r\n    }\r\n\r\n    // Mark that applyChanges has been called at least once\r\n    this._hasAppliedChanges = true;\r\n  }\r\n\r\n  markNeedsBuild() {\r\n    if (this._dirty) {\r\n      return;\r\n    }\r\n\r\n    if (!this._mounted) {\r\n      console.warn(`[Element] Cannot mark unmounted element ${this._id} dirty`);\r\n      return;\r\n    }\r\n\r\n    this._dirty = true;\r\n\r\n    console.log(`\uD83D\uDD0D [Element.markNeedsBuild] Called for ${this._id} (${this.widget?.constructor?.name})`);\r\n    console.trace('Call stack:');\r\n\r\n    if (this.runtime && this.runtime.markNeedsBuild) {\r\n      this.runtime.markNeedsBuild(this);\r\n    }\r\n  }\r\n\r\n  unmount() {\r\n    if (!this._mounted) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.willUnmount();\r\n\r\n      this._children.forEach(child => {\r\n        if (child._mounted) {\r\n          child.unmount();\r\n        }\r\n      });\r\n\r\n      this._children = [];\r\n      this._childMap.clear();\r\n      this._vnode = null;\r\n      this._domNode = null;\r\n\r\n      this._mounted = false;\r\n      this._dirty = false;\r\n\r\n      this.didUnmount();\r\n    } catch (error) {\r\n      console.error(`[Element] Unmount failed for ${this._id}:`, error);\r\n    }\r\n  }\r\n\r\n  updateWidget(newWidget) {\r\n    if (!newWidget) {\r\n      throw new Error('New widget is required for update');\r\n    }\r\n\r\n    const oldWidget = this._widget;\r\n    this.widget = newWidget;\r\n\r\n    if (this.shouldRebuild(oldWidget, newWidget)) {\r\n      this.markNeedsBuild();\r\n    }\r\n\r\n    this.didUpdateWidget(oldWidget, newWidget);\r\n  }\r\n\r\n  shouldRebuild(oldWidget, newWidget) {\r\n    if (oldWidget === newWidget) {\r\n      return false;\r\n    }\r\n\r\n    if (oldWidget.constructor !== newWidget.constructor) {\r\n      return true;\r\n    }\r\n\r\n    return !this.areWidgetsEqual(oldWidget, newWidget);\r\n  }\r\n\r\n  areWidgetsEqual(w1, w2) {\r\n    if (w1.constructor !== w2.constructor) {\r\n      return false;\r\n    }\r\n\r\n    const keys1 = Object.keys(w1);\r\n    const keys2 = Object.keys(w2);\r\n\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    return keys1.every(key => {\r\n      const val1 = w1[key];\r\n      const val2 = w2[key];\r\n\r\n      if (typeof val1 === 'function' && typeof val2 === 'function') {\r\n        return true;\r\n      }\r\n\r\n      if (typeof val1 === 'object' && typeof val2 === 'object') {\r\n        try {\r\n          return JSON.stringify(val1) === JSON.stringify(val2);\r\n        } catch {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return val1 === val2;\r\n    });\r\n  }\r\n\r\n  addChild(child) {\r\n    if (!child) {\r\n      throw new Error('Child element is required');\r\n    }\r\n\r\n    this._children.push(child);\r\n\r\n    if (child.key) {\r\n      this._childMap.set(child.key, child);\r\n    }\r\n\r\n    child.parent = this;\r\n  }\r\n\r\n  removeChild(child) {\r\n    const index = this._children.indexOf(child);\r\n\r\n    if (index !== -1) {\r\n      this._children.splice(index, 1);\r\n    }\r\n\r\n    if (child.key) {\r\n      this._childMap.delete(child.key);\r\n    }\r\n\r\n    child.parent = null;\r\n  }\r\n\r\n  findChildByKey(key) {\r\n    return this._childMap.get(key);\r\n  }\r\n\r\n  findAncestorOfType(ElementType) {\r\n    let current = this._parent;\r\n\r\n    while (current) {\r\n      if (current instanceof ElementType) {\r\n        return current;\r\n      }\r\n      current = current._parent;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  visitAncestors(visitor) {\r\n    let current = this._parent;\r\n\r\n    while (current) {\r\n      const shouldContinue = visitor(current);\r\n      if (shouldContinue === false) {\r\n        break;\r\n      }\r\n      current = current._parent;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // LIFECYCLE HOOKS\r\n  // ============================================================================\r\n\r\n  didMount() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  didUpdateWidget(oldWidget, newWidget) {\r\n    // Override in subclasses\r\n  }\r\n\r\n  willUnmount() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  didUnmount() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  reassemble() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  activate() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  deactivate() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  didChangeDependencies() {\r\n    // Override in subclasses\r\n  }\r\n\r\n  // ============================================================================\r\n  // UTILITIES\r\n  // ============================================================================\r\n\r\n  getStats() {\r\n    return {\r\n      id: this._id,\r\n      type: this.constructor.name,\r\n      mounted: this._mounted,\r\n      dirty: this._dirty,\r\n      depth: this._depth,\r\n      childCount: this._children.length,\r\n      buildCount: this._buildCount,\r\n      lastBuildDuration: this._lastBuildDuration,\r\n      hasKey: !!this.key\r\n    };\r\n  }\r\n\r\n  static generateId() {\r\n    return `el_${++Element._counter}`;\r\n  }\r\n\r\n  static resetCounter() {\r\n    Element._counter = 0;\r\n  }\r\n}\r\n\r\nElement._counter = 0;\r\n\r\n/**\r\n * StatelessElement - FIXED VERSION\r\n * \r\n * \u2705 KEY FIX: Returns result from widget.build(), NOT the Element\r\n */\r\nclass StatelessElement extends Element {\r\n  constructor(widget, parent, runtime) {\r\n    super(widget, parent, runtime);\r\n  }\r\n\r\n  /**\r\n   * Build the widget and return the result\r\n   * \u2705 CRITICAL: Use strict VNode detection\r\n   */\r\n  build() {\r\n    console.log('\uD83D\uDCE6 StatelessElement.build() START', {\r\n      widgetType: this.widget?.constructor.name,\r\n      widgetInstance: this.widget\r\n    });\r\n\r\n    const context = this.buildContext();\r\n\r\n    try {\r\n      // STEP 1: Call widget's build method\r\n      console.log('\uD83D\uDD28 Calling widget.build(context)...');\r\n      const result = this.widget.build(context);\r\n\r\n      console.log('\u2713 widget.build() returned:', {\r\n        resultType: typeof result,\r\n        resultConstructor: result?.constructor?.name,\r\n        hasTag: result?.tag !== undefined,\r\n        isString: typeof result === 'string',\r\n        isNull: result === null,\r\n      });\r\n\r\n      if (!result) {\r\n        console.warn('\u26A0\uFE0F Result is null/undefined');\r\n        throw new Error('StatelessWidget.build() returned null');\r\n      }\r\n\r\n      // \u2705 STRICT CHECK: Use isRealVNode() instead of just checking .tag\r\n      if (isRealVNode(result)) {\r\n        console.log('\u2705 Result is a REAL VNode, returning it directly');\r\n        this._shouldPatch = true; // We own this VNode\r\n        return result;\r\n      }\r\n\r\n      // \u2705 Check if it's a string/number/primitive\r\n      if (typeof result === 'string' || typeof result === 'number' || typeof result === 'boolean') {\r\n        console.log('\u2705 Result is a primitive:', result);\r\n        this._shouldPatch = true; // We own this primitive\r\n        return result;\r\n      }\r\n\r\n      // \u2705 Check if it's a Widget (has build method or createState)\r\n      if (isWidget(result)) {\r\n        console.log('\uD83D\uDD04 Result is a Widget, need to build recursively:', result.constructor.name);\r\n\r\n        let childElement = this._children[0];\r\n\r\n        // \u2705 RECONCILIATION: Check if we can reuse the existing element\r\n        if (childElement && childElement.widget.constructor === result.constructor && childElement.widget.key === result.key) {\r\n          console.log('\u267B\uFE0F Reusing existing child element for:', result.constructor.name);\r\n\r\n          // \u2705 CRITICAL FIX: Only rebuild if widget actually changed\r\n          const oldWidget = childElement.widget;\r\n          childElement.widget = result; // Update widget reference\r\n\r\n          // Check if rebuild is needed\r\n          if (childElement.shouldRebuild(oldWidget, result)) {\r\n            console.log('\uD83D\uDD04 Widget changed, rebuilding child element');\r\n            childElement.rebuild();\r\n          } else {\r\n            console.log('\u2705 Widget unchanged, reusing existing vnode');\r\n          }\r\n\r\n          // Return existing vnode (either updated or reused)\r\n          return childElement.vnode;\r\n        }\r\n\r\n        // \u274C Cannot reuse: Unmount old child if exists\r\n        if (childElement) {\r\n          console.log('\uD83D\uDDD1\uFE0F Unmounting old child element:', childElement.constructor.name);\r\n          childElement.unmount();\r\n          this._children = [];\r\n        }\r\n\r\n        // \u2705 CRITICAL FIX: We need to patch the DOM because we're replacing the child\r\n        this._shouldPatch = true;\r\n\r\n        // Create element for this widget\r\n        childElement = this._createElementForWidget(result);\r\n\r\n        console.log('\u2705 Created child element:', childElement.constructor.name);\r\n\r\n        // \u2705 Add to children array so unmount() works\r\n        this._children = [childElement];\r\n\r\n        // \u2705 CRITICAL: Use mount() to properly initialize the child element\r\n        // This handles parent ref, depth, context, and state initialization\r\n        childElement.mount(this);\r\n\r\n        const childVNode = childElement.vnode;\r\n\r\n        if (!childVNode) {\r\n          throw new Error('Child element.build() returned null');\r\n        }\r\n\r\n        console.log('\u2705 Built new child widget, applyChanges will update DOM');\r\n        return childVNode;\r\n      }\r\n\r\n      // If we get here, it's an unknown type\r\n      console.warn('\u26A0\uFE0F Unknown result type from build():', result);\r\n      console.warn('   Constructor:', result?.constructor?.name);\r\n      console.warn('   Type:', typeof result);\r\n      console.warn('   Has .tag:', result?.tag);\r\n      console.warn('   Has .build:', typeof result?.build);\r\n\r\n      throw new Error(\r\n        `Invalid build() return type from ${this.widget.constructor.name}. ` +\r\n        `Expected: Widget, VNode, string, number, or null. ` +\r\n        `Got: ${result?.constructor?.name} with tag=\"${result?.tag}\"`\r\n      );\r\n\r\n    } catch (error) {\r\n      console.error('\u274C Build error:', error.message);\r\n      console.error('   Widget:', this.widget?.constructor.name);\r\n      throw new Error(`StatelessWidget build failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to create appropriate element type for a widget\r\n   * @private\r\n   */\r\n  _createElementForWidget(widget) {\r\n    // \u2705 Use widget's createElement if available (InheritedWidget uses this)\r\n    // This avoids circular dependency with InheritedElement\r\n    if (widget && typeof widget.createElement === 'function') {\r\n      console.log('  Using widget.createElement() for:', widget.constructor.name);\r\n      return widget.createElement(this, this.runtime);\r\n    }\r\n\r\n    if (typeof widget.createState === 'function') {\r\n      console.log('  Creating StatefulElement for:', widget.constructor.name);\r\n      return new StatefulElement(widget, this, this.runtime);\r\n    } else if (widget.updateShouldNotify && typeof widget.updateShouldNotify === 'function') {\r\n      // InheritedWidget should have createElement defined, so this branch \r\n      // is a fallback. The widget MUST provide createElement for InheritedWidget.\r\n      console.error('  \u26A0\uFE0F InheritedWidget without createElement():', widget.constructor.name);\r\n      throw new Error(\r\n        `InheritedWidget \"${widget.constructor.name}\" must define createElement() method. ` +\r\n        `Extend InheritedWidget class properly.`\r\n      );\r\n    } else {\r\n      console.log('  Creating StatelessElement for:', widget.constructor.name);\r\n      return new StatelessElement(widget, this, this.runtime);\r\n    }\r\n  }\r\n\r\n  buildContext() {\r\n    return new BuildContext(this, this.runtime);\r\n  }\r\n\r\n  /**\r\n   * \u2705 CRITICAL: Implement performRebuild() to satisfy Element.mount() contract\r\n   * This method is called by Element.mount() and must return a VNode\r\n   */\r\n  performRebuild() {\r\n    return this.build();\r\n  }\r\n}\r\n\r\n/**\r\n * StatefulElement - FIXED VERSION\r\n * \r\n * \u2705 CRITICAL FIX: mount() now calls state._mount(this)\r\n * This properly initializes state._widget so this.widget works\r\n */\r\nclass StatefulElement extends Element {\r\n  constructor(widget, parent, runtime) {\r\n    super(widget, parent, runtime);\r\n\r\n    if (!widget.createState || typeof widget.createState !== 'function') {\r\n      throw new Error('StatefulWidget must implement createState()');\r\n    }\r\n\r\n    this.state = widget.createState();\r\n\r\n    if (!this.state) {\r\n      throw new Error('createState() returned null or undefined');\r\n    }\r\n\r\n    // \u2705 Set initial references (but _mount will do the proper initialization)\r\n    this.state._element = this;\r\n    this.state._widget = widget;\r\n    this.state._mounted = false;\r\n  }\r\n\r\n  build() {\r\n    console.log('\uD83D\uDCE6 StatefulElement.build() START', {\r\n      widgetType: this.widget?.constructor.name,\r\n      stateType: this.state?.constructor.name\r\n    });\r\n\r\n    const context = this.buildContext();\r\n\r\n    try {\r\n      if (!this.state.build || typeof this.state.build !== 'function') {\r\n        throw new Error('State must implement build() method');\r\n      }\r\n\r\n      console.log('\uD83D\uDD28 Calling state.build(context)...');\r\n      const result = this.state.build(context);\r\n\r\n      console.log('\u2713 state.build() returned:', {\r\n        resultType: typeof result,\r\n        resultConstructor: result?.constructor?.name,\r\n        isVNode: result?.tag !== undefined\r\n      });\r\n\r\n      if (!result) {\r\n        throw new Error('State.build() returned null');\r\n      }\r\n\r\n      // \u2705 STRICT CHECK: Use isRealVNode()\r\n      if (isRealVNode(result)) {\r\n        console.log('\u2705 Result is a REAL VNode, returning');\r\n        this._shouldPatch = true; // We own this VNode\r\n        return result;\r\n      }\r\n\r\n      // \u2705 Check if it's a primitive\r\n      if (typeof result === 'string' || typeof result === 'number' || typeof result === 'boolean') {\r\n        console.log('\u2705 Result is a primitive');\r\n        this._shouldPatch = true; // We own this primitive\r\n        return result;\r\n      }\r\n\r\n      // \u2705 Check if it's a widget and build recursively\r\n      let childElement = this._children[0];\r\n\r\n      if (isWidget(result)) {\r\n        console.log('\uD83D\uDD04 State.build() returned a Widget, building recursively:', result.constructor.name);\r\n\r\n        // \u2705 RECONCILIATION: Check if we can reuse the existing element\r\n        if (childElement && childElement.widget.constructor === result.constructor && childElement.widget.key === result.key) {\r\n          console.log('\u267B\uFE0F Reusing existing child element for:', result.constructor.name);\r\n\r\n          // \u2705 CRITICAL FIX: Only rebuild if widget actually changed\r\n          const oldWidget = childElement.widget;\r\n          childElement.widget = result; // Update widget reference\r\n\r\n          // Check if rebuild is needed\r\n          if (childElement.shouldRebuild(oldWidget, result)) {\r\n            console.log('\uD83D\uDD04 Widget changed, rebuilding child element');\r\n            childElement.rebuild();\r\n          } else {\r\n            console.log('\u2705 Widget unchanged, reusing existing vnode');\r\n          }\r\n\r\n          this._shouldPatch = false; // Child handled patching\r\n          return childElement.vnode;\r\n        }\r\n\r\n        // \u274C Cannot reuse: Unmount old child if exists\r\n        if (childElement) {\r\n          console.log('\uD83D\uDDD1\uFE0F Unmounting old child element:', childElement.constructor.name);\r\n          childElement.unmount();\r\n          this._children = [];\r\n        }\r\n\r\n        // \u2705 CRITICAL FIX: We need to patch the DOM because we're replacing the child\r\n        this._shouldPatch = true;\r\n\r\n        childElement = this._createElementForWidget(result);\r\n\r\n        // \u2705 Add to children array so unmount() works\r\n        this._children = [childElement];\r\n\r\n        // \u2705 CRITICAL: Use mount() to properly initialize the child element\r\n        childElement.mount(this);\r\n\r\n        const childVNode = childElement.vnode;\r\n\r\n\r\n        if (!childVNode) {\r\n          throw new Error('Child element.build() returned null');\r\n        }\r\n\r\n        console.log('\u2705 Built new child widget, applyChanges will update DOM');\r\n        return childVNode;\r\n      }\r\n\r\n      this._shouldPatch = false; // Should have been set above, but safe default for delegates\r\n      return childElement ? childElement.vnode : result; // Fallback\r\n\r\n      throw new Error(\r\n        `Invalid build() return type from ${this.widget.constructor.name} state. ` +\r\n        `Expected: Widget, VNode, string, number, or null.`\r\n      );\r\n\r\n    } catch (error) {\r\n      throw new Error(`StatefulWidget build failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  _createElementForWidget(widget) {\r\n    // \u2705 Use widget's createElement if available\r\n    if (widget && typeof widget.createElement === 'function') {\r\n      return widget.createElement(this, this.runtime);\r\n    }\r\n\r\n    if (typeof widget.createState === 'function') {\r\n      return new StatefulElement(widget, this, this.runtime);\r\n    } else if (widget.updateShouldNotify && typeof widget.updateShouldNotify === 'function') {\r\n      return new InheritedElement(widget, this, this.runtime);\r\n    } else {\r\n      return new StatelessElement(widget, this, this.runtime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \u2705\u2705\u2705 CRITICAL FIX: Call state._mount() to properly initialize state\r\n   * This ensures this.widget is available in State\r\n   */\r\n  mount() {\r\n    // \u2705 CRITICAL FIX: Prevent double mounting\r\n    if (this._mounted) {\r\n      console.warn(`[StatefulElement] ${this._id} already mounted, skipping duplicate mount`);\r\n      return;\r\n    }\r\n\r\n    console.log('\uD83D\uDE80 StatefulElement.mount() called');\r\n    console.log('   Widget:', this.widget?.constructor?.name);\r\n    console.log('   State:', this.state?.constructor?.name);\r\n    console.log('   State has _mount:', typeof this.state._mount === 'function');\r\n\r\n    // \u2705 CRITICAL: Call state._mount() if available\r\n    if (this.state._mount && typeof this.state._mount === 'function') {\r\n      console.log('\u2705 Calling state._mount(this)...');\r\n      this.state._mount(this);\r\n      console.log('\u2705 state._mount() complete');\r\n    } else {\r\n      // Fallback for old State implementations that don't have _mount()\r\n      console.log('\u26A0\uFE0F State does not have _mount(), using fallback initialization');\r\n\r\n      // Manually set state properties\r\n      this.state._element = this;\r\n      this.state._widget = this.widget;\r\n      this.state._mounted = true;\r\n\r\n      // Call initState manually\r\n      if (this.state.initState && typeof this.state.initState === 'function') {\r\n        try {\r\n          console.log('\uD83C\uDFAC Calling initState()...');\r\n          this.state.initState();\r\n        } catch (error) {\r\n          console.error(`[StatefulElement] initState failed:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Verify state is properly initialized\r\n    console.log('\uD83D\uDD0D State after mount:', {\r\n      hasMounted: this.state._mounted,\r\n      hasElement: !!this.state._element,\r\n      hasWidget: !!this.state._widget,\r\n      widgetType: this.state._widget?.constructor?.name,\r\n      widgetTitle: this.state._widget?.title\r\n    });\r\n\r\n    // Call parent mount\r\n    super.mount();\r\n\r\n    console.log('\u2705 StatefulElement.mount() complete');\r\n  }\r\n\r\n  buildContext() {\r\n    return new BuildContext(this, this.runtime, this.state);\r\n  }\r\n\r\n  /**\r\n   * \u2705 Update widget reference when widget changes\r\n   */\r\n  updateWidget(newWidget) {\r\n    console.log('\uD83D\uDD04 StatefulElement.updateWidget() called');\r\n\r\n    const oldWidget = this._widget;\r\n\r\n    // Update element's widget\r\n    super.updateWidget(newWidget);\r\n\r\n    // \u2705 Update state's widget reference\r\n    if (this.state._updateWidget && typeof this.state._updateWidget === 'function') {\r\n      console.log('\u2705 Calling state._updateWidget()');\r\n      this.state._updateWidget(newWidget);\r\n    } else {\r\n      // Fallback\r\n      console.log('\u26A0\uFE0F State does not have _updateWidget(), updating directly');\r\n      this.state._widget = newWidget;\r\n    }\r\n\r\n    // Call state's didUpdateWidget\r\n    if (this.state.didUpdateWidget && typeof this.state.didUpdateWidget === 'function') {\r\n      try {\r\n        this.state.didUpdateWidget(oldWidget);\r\n      } catch (error) {\r\n        console.error('[StatefulElement] didUpdateWidget failed:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \u2705 Properly unmount state\r\n   */\r\n  unmount() {\r\n    console.log('\uD83D\uDED1 StatefulElement.unmount() called');\r\n\r\n    // Call state._unmount if available\r\n    if (this.state._unmount && typeof this.state._unmount === 'function') {\r\n      this.state._unmount();\r\n    }\r\n\r\n    // Call state.dispose\r\n    if (this.state._dispose && typeof this.state._dispose === 'function') {\r\n      this.state._dispose();\r\n    }\r\n\r\n    super.unmount();\r\n  }\r\n\r\n  /**\r\n   * \u2705 CRITICAL: Implement performRebuild() to satisfy Element.mount() contract\r\n   * This method is called by Element.mount() and must return a VNode\r\n   */\r\n  performRebuild() {\r\n    return this.build();\r\n  }\r\n}\r\n\r\n/**\r\n * ComponentElement - Custom components\r\n */\r\nclass ComponentElement extends Element {\r\n  constructor(widget, parent, runtime) {\r\n    super(widget, parent, runtime);\r\n    this.componentState = {};\r\n  }\r\n\r\n  build() {\r\n    const method = this.widget.render || this.widget.build;\r\n\r\n    if (!method || typeof method !== 'function') {\r\n      throw new Error('ComponentElement widget must have render() or build() method');\r\n    }\r\n\r\n    const context = this.buildContext();\r\n\r\n    try {\r\n      const result = method.call(this.widget, context);\r\n\r\n      // \u2705 Check if VNode\r\n      if (result && typeof result === 'object' && result.tag) {\r\n        return result;\r\n      }\r\n\r\n      if (typeof result === 'string' || typeof result === 'number') {\r\n        return result;\r\n      }\r\n\r\n      const isWidget = result &&\r\n        typeof result === 'object' &&\r\n        (typeof result.build === 'function' || typeof result.createState === 'function');\r\n\r\n      if (isWidget) {\r\n        const childElement = this._createElementForWidget(result);\r\n\r\n        childElement._parent = this;\r\n        childElement._depth = this._depth + 1;\r\n        childElement._mounted = true;\r\n\r\n        return childElement.build();\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      throw new Error(`Component build failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  _createElementForWidget(widget) {\r\n    // \u2705 Use widget's createElement if available\r\n    if (widget && typeof widget.createElement === 'function') {\r\n      return widget.createElement(this, this.runtime);\r\n    }\r\n\r\n    if (typeof widget.createState === 'function') {\r\n      return new StatefulElement(widget, this, this.runtime);\r\n    } else {\r\n      return new StatelessElement(widget, this, this.runtime);\r\n    }\r\n  }\r\n\r\n  buildContext() {\r\n    return {\r\n      element: this,\r\n      runtime: this.runtime,\r\n      widget: this.widget,\r\n      state: this.componentState,\r\n\r\n      setState: (updates) => {\r\n        Object.assign(this.componentState, updates);\r\n        this.markNeedsBuild();\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * \u2705 CRITICAL: Implement performRebuild() to satisfy Element.mount() contract\r\n   * This method is called by Element.mount() and must return a VNode\r\n   */\r\n  performRebuild() {\r\n    return this.build();\r\n  }\r\n}\r\n\r\n// Initialize static ID counter\r\nElement._nextId = 0;\r\n\r\nexport {\r\n  Element,\r\n  StatelessElement,\r\n  StatefulElement,\r\n  ComponentElement,\r\n  DiagnosticLevel,\r\n  isRealVNode, isWidget\r\n};"],
  "mappings": "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",
  "names": ["BuildContext", "VNodeDiffer", "PatchApplier", "DiagnosticLevel", "DiagnosticsTreeStyle", "Diagnosticable", "name", "style", "properties", "isRealVNode", "obj", "hasTag", "hasChildren", "hasProps", "isNotWidget", "isWidget", "Element", "widget", "parent", "runtime", "newWidget", "p", "v", "d", "parentPath", "child", "error", "oldVNode", "newVNode", "oldChildren", "newChildren", "targetElement", "rootElement", "oldDomNode", "parentNode", "tempContainer", "newDomNode", "domNode", "index", "patches", "result", "e", "oldWidget", "w1", "w2", "keys1", "keys2", "key", "val1", "val2", "ElementType", "current", "visitor", "StatelessElement", "context", "childElement", "childVNode", "StatefulElement", "ComponentElement", "method", "updates"]
}
