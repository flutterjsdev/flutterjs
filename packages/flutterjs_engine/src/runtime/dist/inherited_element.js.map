{
  "version": 3,
  "sources": ["../src/inherited_element.js"],
  "sourcesContent": ["/**\r\n * FlutterJS InheritedElement\r\n *\r\n * Element for InheritedWidget. Manages dependency propagation down the widget tree.\r\n * InheritedWidget allows efficient value passing without prop drilling.\r\n *\r\n * Key Features:\r\n * - Track dependent elements\r\n * - Notify dependents on value changes\r\n * - Automatic rebuilds only for affected descendants\r\n * - Memory efficient cleanup\r\n *\r\n * Usage:\r\n * ```javascript\r\n * class Theme extends InheritedWidget {\r\n *   constructor({ data, child, key }) {\r\n *     super({ child, key });\r\n *     this.data = data;\r\n *   }\r\n *\r\n *   updateShouldNotify(oldWidget) {\r\n *     return this.data !== oldWidget.data;\r\n *   }\r\n *\r\n *   static of(context) {\r\n *     return context.dependOnInheritedWidgetOfExactType(Theme);\r\n *   }\r\n * }\r\n * ```\r\n */\r\n\r\nimport { Element } from './element.js';\r\n\r\n/**\r\n * InheritedElement Class\r\n *\r\n * Represents a live instance of an InheritedWidget in the element tree.\r\n * Manages which elements depend on this InheritedWidget's value.\r\n */\r\nclass InheritedElement extends Element {\r\n  /**\r\n   * Create InheritedElement\r\n   * @param {InheritedWidget} widget - The widget\r\n   * @param {Element|null} parent - Parent element\r\n   * @param {RuntimeEngine} runtime - Runtime engine\r\n   */\r\n  constructor(widget, parent, runtime) {\r\n    super(widget, parent, runtime);\r\n\r\n    // Track elements that depend on this InheritedWidget's value\r\n    this.dependents = new Set();\r\n\r\n    // Cache the inherited value for quick access\r\n    this._inheritedValue = widget.data || widget.value || null;\r\n\r\n    // Track if we're in process of notifying dependents\r\n    this._notifying = false;\r\n\r\n    if (this.runtime?.debugMode) {\r\n      console.log(`[InheritedElement] Created ${widget.constructor.name}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build the InheritedWidget's child\r\n   * InheritedWidget typically just wraps a child without additional rendering\r\n   *\r\n   * @returns {VNode} VNode for the child widget\r\n   */\r\n  build() {\r\n    if (!this.widget.child) {\r\n      throw new Error('InheritedWidget must have a child widget');\r\n    }\r\n\r\n    // \u2705 FIX: Convert child widget to element and build it\r\n    const childWidget = this.widget.child;\r\n\r\n    // Check if child is already a VNode\r\n    if (childWidget && typeof childWidget === 'object' && childWidget.tag) {\r\n      // Already a VNode\r\n      return {\r\n        tag: 'div',\r\n        props: {\r\n          'data-widget': this.widget.constructor.name,\r\n          'data-element-id': this.id,\r\n          class: 'fjs-inherited-widget-wrapper'\r\n        },\r\n        children: [childWidget],\r\n        metadata: {\r\n          isInheritedWidget: true,\r\n          widgetType: this.widget.constructor.name\r\n        }\r\n      };\r\n    }\r\n\r\n    // \u2705 CRITICAL: If it's a widget, convert to element and build\r\n    if (childWidget && typeof childWidget === 'object' &&\r\n      (childWidget.build || childWidget.createState || childWidget.render)) {\r\n\r\n      // Reuse existing element if possible\r\n      if (this._childElement) {\r\n        if (this._childElement.shouldRebuild(this._childElement.widget, childWidget)) {\r\n          this._childElement.updateWidget(childWidget);\r\n        } else {\r\n          this._childElement.widget = childWidget;\r\n          this._childElement.markNeedsBuild();\r\n        }\r\n      } else {\r\n        // Create new element\r\n        this._childElement = this.runtime.createElement(childWidget, this);\r\n        if (!this._childElement) {\r\n          throw new Error('Failed to create element from child widget');\r\n        }\r\n\r\n        // Register properly\r\n        this.addChild(this._childElement);\r\n\r\n        // Mount\r\n        if (!this._childElement.mounted) {\r\n          this._childElement.mount();\r\n        }\r\n      }\r\n\r\n      // Return the child's VNode (from the stable element)\r\n      const childVNode = this._childElement.vnode || this._childElement.build();\r\n\r\n      return {\r\n        tag: 'div',\r\n        props: {\r\n          'data-widget': this.widget.constructor.name,\r\n          'data-element-id': this.id,\r\n          class: 'fjs-inherited-widget-wrapper'\r\n        },\r\n        children: [childVNode],\r\n        metadata: {\r\n          isInheritedWidget: true,\r\n          widgetType: this.widget.constructor.name\r\n        }\r\n      };\r\n    }\r\n\r\n    // String or primitive\r\n    return {\r\n      tag: 'div',\r\n      props: {\r\n        'data-widget': this.widget.constructor.name,\r\n        'data-element-id': this.id,\r\n        class: 'fjs-inherited-widget-wrapper'\r\n      },\r\n      children: [childWidget],\r\n      metadata: {\r\n        isInheritedWidget: true,\r\n        widgetType: this.widget.constructor.name\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Perform rebuild - required by Element base class\r\n   * @returns {VNode} VNode for the child widget\r\n   */\r\n  performRebuild() {\r\n    return this.build();\r\n  }\r\n\r\n  /**\r\n   * Register a dependent element\r\n   * Called when an element calls dependOnInheritedWidgetOfExactType\r\n   *\r\n   * @param {Element} element - Element that depends on this InheritedWidget\r\n   * @throws {Error} If element is null\r\n   */\r\n  addDependent(element) {\r\n    if (!element) {\r\n      throw new Error('Cannot add null element as dependent');\r\n    }\r\n\r\n    if (this.dependents.has(element)) {\r\n      if (this.runtime?.debugMode) {\r\n        console.warn(\r\n          `[InheritedElement] Element ${element.id} already registered as dependent`\r\n        );\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.dependents.add(element);\r\n\r\n    if (this.runtime?.debugMode) {\r\n      console.log(\r\n        `[InheritedElement] Added dependent ${element.id} ` +\r\n        `(total: ${this.dependents.size})`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a dependent element\r\n   * Called during cleanup\r\n   *\r\n   * @param {Element} element - Element to remove\r\n   */\r\n  removeDependent(element) {\r\n    if (!element) return;\r\n\r\n    const removed = this.dependents.delete(element);\r\n\r\n    if (removed && this.runtime?.debugMode) {\r\n      console.log(\r\n        `[InheritedElement] Removed dependent ${element.id} ` +\r\n        `(remaining: ${this.dependents.size})`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if element is a dependent\r\n   *\r\n   * @param {Element} element - Element to check\r\n   * @returns {boolean} True if element is dependent\r\n   */\r\n  hasDependent(element) {\r\n    return this.dependents.has(element);\r\n  }\r\n\r\n  /**\r\n   * Get number of dependents\r\n   *\r\n   * @returns {number} Count of dependent elements\r\n   */\r\n  get dependentCount() {\r\n    return this.dependents.size;\r\n  }\r\n\r\n  /**\r\n   * Update the InheritedWidget with new widget\r\n   * Checks if value changed, notifies dependents if needed\r\n   *\r\n   * @param {InheritedWidget} newWidget - New widget with potentially new data\r\n   */\r\n  update(newWidget) {\r\n    const oldWidget = this.widget;\r\n\r\n    // Call parent update\r\n    super.update(newWidget);\r\n\r\n    // Cache new value\r\n    const newValue = newWidget.data || newWidget.value || null;\r\n    const oldValue = this._inheritedValue;\r\n\r\n    this._inheritedValue = newValue;\r\n\r\n    // Check if we should notify dependents\r\n    if (this.widget.updateShouldNotify) {\r\n      try {\r\n        const shouldNotify = this.widget.updateShouldNotify(oldWidget);\r\n\r\n        if (shouldNotify) {\r\n          if (this.runtime?.debugMode) {\r\n            console.log(\r\n              `[InheritedElement] Value changed, notifying ${this.dependents.size} dependents`\r\n            );\r\n          }\r\n\r\n          this.notifyDependents();\r\n        } else if (this.runtime?.debugMode) {\r\n          console.log(\r\n            `[InheritedElement] Value changed but updateShouldNotify returned false`\r\n          );\r\n        }\r\n      } catch (error) {\r\n        console.error(\r\n          `[InheritedElement] Error in updateShouldNotify: ${error.message}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notify all dependent elements to rebuild\r\n   * Only notifies elements that are still mounted\r\n   */\r\n  notifyDependents() {\r\n    // Prevent recursive notifications\r\n    if (this._notifying) {\r\n      if (this.runtime?.debugMode) {\r\n        console.warn('[InheritedElement] Recursive notification detected, skipping');\r\n      }\r\n      return;\r\n    }\r\n\r\n    this._notifying = true;\r\n\r\n    try {\r\n      const startTime = this.runtime?.debugMode ? performance.now() : 0;\r\n      let notifiedCount = 0;\r\n\r\n      // Notify each dependent\r\n      for (const element of this.dependents) {\r\n        if (element.mounted && !element.dirty) {\r\n          element.markNeedsBuild();\r\n          notifiedCount++;\r\n        } else if (!element.mounted && this.runtime?.debugMode) {\r\n          console.warn(\r\n            `[InheritedElement] Dependent ${element.id} is not mounted, skipping`\r\n          );\r\n        }\r\n      }\r\n\r\n      if (this.runtime?.debugMode) {\r\n        const duration = performance.now() - startTime;\r\n        console.log(\r\n          `[InheritedElement] Notified ${notifiedCount} dependents in ${duration.toFixed(2)}ms`\r\n        );\r\n      }\r\n    } finally {\r\n      this._notifying = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notify specific dependents (optimization)\r\n   * Use when you know only certain dependents need rebuild\r\n   *\r\n   * @param {Set<Element>} elements - Elements to notify\r\n   */\r\n  notifySpecificDependents(elements) {\r\n    if (this._notifying) return;\r\n\r\n    this._notifying = true;\r\n\r\n    try {\r\n      for (const element of elements) {\r\n        if (this.dependents.has(element) && element.mounted && !element.dirty) {\r\n          element.markNeedsBuild();\r\n        }\r\n      }\r\n    } finally {\r\n      this._notifying = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mount element - initialize dependent tracking\r\n   */\r\n  mount() {\r\n    super.mount();\r\n\r\n    if (this.runtime?.debugMode) {\r\n      console.log(\r\n        `[InheritedElement] Mounted ${this.widget.constructor.name} ` +\r\n        `with ${this.dependents.size} dependents`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unmount element - cleanup all dependent tracking\r\n   */\r\n  unmount() {\r\n    // Clear all dependent references\r\n    const dependentCount = this.dependents.size;\r\n\r\n    this.dependents.forEach(element => {\r\n      if (element.mounted) {\r\n        // Don't rebuild, just remove from tracking\r\n        element._inheritedDependencies?.delete(this.id);\r\n      }\r\n    });\r\n\r\n    this.dependents.clear();\r\n\r\n    if (this.runtime?.debugMode) {\r\n      console.log(\r\n        `[InheritedElement] Unmounted ${this.widget.constructor.name} ` +\r\n        `(cleaned up ${dependentCount} dependents)`\r\n      );\r\n    }\r\n\r\n    super.unmount();\r\n  }\r\n\r\n  /**\r\n   * Get statistics about this InheritedElement\r\n   *\r\n   * @returns {Object} Statistics object\r\n   */\r\n  getStats() {\r\n    const stats = super.getStats();\r\n\r\n    return {\r\n      ...stats,\r\n      type: 'InheritedElement',\r\n      inheritedValue: this._inheritedValue,\r\n      dependentCount: this.dependents.size,\r\n      dependents: Array.from(this.dependents).map(el => ({\r\n        id: el.id,\r\n        type: el.constructor.name,\r\n        mounted: el.mounted\r\n      }))\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Base InheritedWidget Class\r\n *\r\n * Widgets that provide values to their descendants.\r\n * Descendants access the value via context.dependOnInheritedWidgetOfExactType()\r\n */\r\nclass InheritedWidget {\r\n  /**\r\n   * Create InheritedWidget\r\n   * @param {Object} options - Widget options\r\n   * @param {Widget} options.child - Child widget to wrap\r\n   * @param {*} options.data - Value to provide (alternative to override in subclass)\r\n   * @param {*} options.value - Value to provide (preferred)\r\n   * @param {string} options.key - Widget key for reconciliation\r\n   */\r\n  constructor({ child, data, value, key } = {}) {\r\n    if (!child) {\r\n      throw new Error('InheritedWidget requires a child widget');\r\n    }\r\n\r\n    this.child = child;\r\n    this.data = data || value || null;\r\n    this.key = key;\r\n    this.type = 'InheritedWidget';\r\n  }\r\n\r\n  /**\r\n   * Determine if dependents should be notified of update\r\n   * Override in subclasses to optimize notifications\r\n   *\r\n   * @param {InheritedWidget} oldWidget - Previous widget\r\n   * @returns {boolean} True if dependents should rebuild\r\n   *\r\n   * @example\r\n   * updateShouldNotify(oldWidget) {\r\n   *   return this.data.theme !== oldWidget.data.theme;\r\n   * }\r\n   */\r\n  updateShouldNotify(oldWidget) {\r\n    // Default: always notify on any change\r\n    return this.data !== oldWidget.data;\r\n  }\r\n\r\n  /**\r\n   * Static helper to access this InheritedWidget from descendant\r\n   * Subclasses should override this\r\n   *\r\n   * @param {BuildContext} context - Build context\r\n   * @returns {InheritedWidget|null} This widget instance or null\r\n   *\r\n   * @example\r\n   * class Theme extends InheritedWidget {\r\n   *   static of(context) {\r\n   *     return context.dependOnInheritedWidgetOfExactType(Theme);\r\n   *   }\r\n   * }\r\n   *\r\n   * // Usage\r\n   * const theme = Theme.of(context);\r\n   */\r\n  static of(context) {\r\n    return context.dependOnInheritedWidgetOfExactType(this);\r\n  }\r\n\r\n  /**\r\n   * Create element for this widget\r\n   * Override to customize element type\r\n   *\r\n   * @param {Element} parent - Parent element\r\n   * @param {RuntimeEngine} runtime - Runtime engine\r\n   * @returns {Element} Element instance\r\n   */\r\n  createElement(parent, runtime) {\r\n    return new InheritedElement(this, parent, runtime);\r\n  }\r\n}\r\n\r\n/**\r\n * ChangeNotifier - Allows imperative value updates\r\n *\r\n * Subclass this to create data classes that notify listeners of changes.\r\n * More efficient than InheritedWidget for frequently changing values.\r\n */\r\nclass ChangeNotifier {\r\n  constructor() {\r\n    this.listeners = new Set();\r\n  }\r\n\r\n  /**\r\n   * Add listener\r\n   * @param {Function} listener - Callback called on change\r\n   */\r\n  addListener(listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('Listener must be a function');\r\n    }\r\n    this.listeners.add(listener);\r\n  }\r\n\r\n  /**\r\n   * Remove listener\r\n   * @param {Function} listener - Listener to remove\r\n   */\r\n  removeListener(listener) {\r\n    this.listeners.delete(listener);\r\n  }\r\n\r\n  /**\r\n   * Remove all listeners\r\n   */\r\n  removeAllListeners() {\r\n    this.listeners.clear();\r\n  }\r\n\r\n  /**\r\n   * Notify all listeners of change\r\n   * Call this when data changes\r\n   */\r\n  notifyListeners() {\r\n    for (const listener of this.listeners) {\r\n      try {\r\n        listener();\r\n      } catch (error) {\r\n        console.error('[ChangeNotifier] Listener error:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if has listeners\r\n   * @returns {boolean} True if any listeners registered\r\n   */\r\n  hasListeners() {\r\n    return this.listeners.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Get listener count\r\n   * @returns {number} Number of listeners\r\n   */\r\n  get listenerCount() {\r\n    return this.listeners.size;\r\n  }\r\n\r\n  /**\r\n   * Dispose - cleanup all listeners\r\n   */\r\n  dispose() {\r\n    this.listeners.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * ValueNotifier - Simple ChangeNotifier for single values\r\n *\r\n * Efficient way to manage a single reactive value.\r\n */\r\nclass ValueNotifier extends ChangeNotifier {\r\n  /**\r\n   * Create ValueNotifier\r\n   * @param {*} initialValue - Initial value\r\n   */\r\n  constructor(initialValue) {\r\n    super();\r\n    this._value = initialValue;\r\n  }\r\n\r\n  /**\r\n   * Get current value\r\n   */\r\n  get value() {\r\n    return this._value;\r\n  }\r\n\r\n  /**\r\n   * Set value and notify listeners\r\n   */\r\n  set value(newValue) {\r\n    if (this._value !== newValue) {\r\n      this._value = newValue;\r\n      this.notifyListeners();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get value\r\n   * @returns {*} Current value\r\n   */\r\n  getValue() {\r\n    return this._value;\r\n  }\r\n\r\n  /**\r\n   * Set value with optional notification\r\n   * @param {*} newValue - New value\r\n   * @param {boolean} notify - Whether to notify listeners (default: true)\r\n   */\r\n  setValue(newValue, notify = true) {\r\n    if (this._value !== newValue) {\r\n      this._value = newValue;\r\n      if (notify) {\r\n        this.notifyListeners();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Provider Widget - Helper for dependency injection\r\n *\r\n * Combines InheritedWidget with ChangeNotifier for reactive data.\r\n */\r\nclass Provider extends InheritedWidget {\r\n  /**\r\n   * Create Provider\r\n   * @param {Object} options\r\n   * @param {ChangeNotifier} options.notifier - ChangeNotifier instance\r\n   * @param {*} options.value - Static value (if not using notifier)\r\n   * @param {Widget} options.child - Child widget\r\n   * @param {string} options.key - Widget key\r\n   */\r\n  constructor({ notifier, value, child, key } = {}) {\r\n    super({ child, data: value, key });\r\n\r\n    if (notifier && !(notifier instanceof ChangeNotifier)) {\r\n      throw new Error('Provider requires a ChangeNotifier instance');\r\n    }\r\n\r\n    this.notifier = notifier;\r\n    this.listeners = [];\r\n  }\r\n\r\n  /**\r\n   * Only notify if notifier value actually changed\r\n   * @param {Provider} oldWidget - Previous widget\r\n   * @returns {boolean} Whether to notify\r\n   */\r\n  updateShouldNotify(oldWidget) {\r\n    // If using notifier, let it handle notifications\r\n    if (this.notifier && oldWidget.notifier === this.notifier) {\r\n      return false;\r\n    }\r\n\r\n    // If values are different, notify\r\n    return this.data !== oldWidget.data;\r\n  }\r\n\r\n  /**\r\n   * Get current provided value\r\n   * @returns {*} The value being provided\r\n   */\r\n  getValue() {\r\n    return this.notifier ? this.notifier.value : this.data;\r\n  }\r\n\r\n  /**\r\n   * Static helper to access provider\r\n   * @param {BuildContext} context\r\n   * @returns {Provider|null}\r\n   */\r\n  static of(context) {\r\n    return context.dependOnInheritedWidgetOfExactType(Provider);\r\n  }\r\n}\r\n\r\n\r\nexport {\r\n  InheritedElement,\r\n  InheritedWidget,\r\n  ChangeNotifier,\r\n  ValueNotifier,\r\n  Provider\r\n};"],
  "mappings": "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",
  "names": ["Element", "InheritedElement", "widget", "parent", "runtime", "childWidget", "childVNode", "element", "newWidget", "oldWidget", "newValue", "oldValue", "error", "startTime", "notifiedCount", "duration", "elements", "dependentCount", "el", "InheritedWidget", "child", "data", "value", "key", "context", "ChangeNotifier", "listener", "ValueNotifier", "initialValue", "notify", "Provider", "notifier"]
}
