{
  "version": 3,
  "sources": ["../src/inherited_element.js"],
  "sourcesContent": ["/**\n * FlutterJS InheritedElement\n *\n * Element for InheritedWidget. Manages dependency propagation down the widget tree.\n * InheritedWidget allows efficient value passing without prop drilling.\n *\n * Key Features:\n * - Track dependent elements\n * - Notify dependents on value changes\n * - Automatic rebuilds only for affected descendants\n * - Memory efficient cleanup\n *\n * Usage:\n * ```javascript\n * class Theme extends InheritedWidget {\n *   constructor({ data, child, key }) {\n *     super({ child, key });\n *     this.data = data;\n *   }\n *\n *   updateShouldNotify(oldWidget) {\n *     return this.data !== oldWidget.data;\n *   }\n *\n *   static of(context) {\n *     return context.dependOnInheritedWidgetOfExactType(Theme);\n *   }\n * }\n * ```\n */\n\nimport { Element } from './element.js';\n\n/**\n * InheritedElement Class\n *\n * Represents a live instance of an InheritedWidget in the element tree.\n * Manages which elements depend on this InheritedWidget's value.\n */\nclass InheritedElement extends Element {\n  /**\n   * Create InheritedElement\n   * @param {InheritedWidget} widget - The widget\n   * @param {Element|null} parent - Parent element\n   * @param {RuntimeEngine} runtime - Runtime engine\n   */\n  constructor(widget, parent, runtime) {\n    super(widget, parent, runtime);\n\n    // Track elements that depend on this InheritedWidget's value\n    this.dependents = new Set();\n\n    // Cache the inherited value for quick access\n    this._inheritedValue = widget.data || widget.value || null;\n\n    // Track if we're in process of notifying dependents\n    this._notifying = false;\n\n    if (this.runtime?.debugMode) {\n      console.log(`[InheritedElement] Created ${widget.constructor.name}`);\n    }\n  }\n\n  /**\n   * Build the InheritedWidget's child\n   * InheritedWidget typically just wraps a child without additional rendering\n   *\n   * @returns {VNode} VNode for the child widget\n   */\n  build() {\n    if (!this.widget.child) {\n      throw new Error('InheritedWidget must have a child widget');\n    }\n\n    // \u2705 FIX: Convert child widget to element and build it\n    const childWidget = this.widget.child;\n\n    // Check if child is already a VNode\n    if (childWidget && typeof childWidget === 'object' && childWidget.tag) {\n      // Already a VNode\n      return {\n        tag: 'div',\n        props: {\n          'data-widget': this.widget.constructor.name,\n          'data-element-id': this.id,\n          class: 'fjs-inherited-widget-wrapper'\n        },\n        children: [childWidget],\n        metadata: {\n          isInheritedWidget: true,\n          widgetType: this.widget.constructor.name\n        }\n      };\n    }\n\n    // \u2705 CRITICAL: If it's a widget, convert to element and build\n    if (childWidget && typeof childWidget === 'object' &&\n      (childWidget.build || childWidget.createState || childWidget.render)) {\n\n      const childElement = this.runtime.createElement(childWidget, this);\n\n      if (!childElement) {\n        throw new Error('Failed to create element from child widget');\n      }\n\n      // Mount the child element\n      if (!childElement.mounted) {\n        childElement.mount();\n      }\n\n      // Build it to get VNode\n      const childVNode = childElement.build();\n\n      if (!childVNode) {\n        throw new Error('Child element build returned null');\n      }\n\n      return {\n        tag: 'div',\n        props: {\n          'data-widget': this.widget.constructor.name,\n          'data-element-id': this.id,\n          class: 'fjs-inherited-widget-wrapper'\n        },\n        children: [childVNode],\n        metadata: {\n          isInheritedWidget: true,\n          widgetType: this.widget.constructor.name\n        }\n      };\n    }\n\n    // String or primitive\n    return {\n      tag: 'div',\n      props: {\n        'data-widget': this.widget.constructor.name,\n        'data-element-id': this.id,\n        class: 'fjs-inherited-widget-wrapper'\n      },\n      children: [childWidget],\n      metadata: {\n        isInheritedWidget: true,\n        widgetType: this.widget.constructor.name\n      }\n    };\n  }\n\n  /**\n   * Register a dependent element\n   * Called when an element calls dependOnInheritedWidgetOfExactType\n   *\n   * @param {Element} element - Element that depends on this InheritedWidget\n   * @throws {Error} If element is null\n   */\n  addDependent(element) {\n    if (!element) {\n      throw new Error('Cannot add null element as dependent');\n    }\n\n    if (this.dependents.has(element)) {\n      if (this.runtime?.debugMode) {\n        console.warn(\n          `[InheritedElement] Element ${element.id} already registered as dependent`\n        );\n      }\n      return;\n    }\n\n    this.dependents.add(element);\n\n    if (this.runtime?.debugMode) {\n      console.log(\n        `[InheritedElement] Added dependent ${element.id} ` +\n        `(total: ${this.dependents.size})`\n      );\n    }\n  }\n\n  /**\n   * Remove a dependent element\n   * Called during cleanup\n   *\n   * @param {Element} element - Element to remove\n   */\n  removeDependent(element) {\n    if (!element) return;\n\n    const removed = this.dependents.delete(element);\n\n    if (removed && this.runtime?.debugMode) {\n      console.log(\n        `[InheritedElement] Removed dependent ${element.id} ` +\n        `(remaining: ${this.dependents.size})`\n      );\n    }\n  }\n\n  /**\n   * Check if element is a dependent\n   *\n   * @param {Element} element - Element to check\n   * @returns {boolean} True if element is dependent\n   */\n  hasDependent(element) {\n    return this.dependents.has(element);\n  }\n\n  /**\n   * Get number of dependents\n   *\n   * @returns {number} Count of dependent elements\n   */\n  get dependentCount() {\n    return this.dependents.size;\n  }\n\n  /**\n   * Update the InheritedWidget with new widget\n   * Checks if value changed, notifies dependents if needed\n   *\n   * @param {InheritedWidget} newWidget - New widget with potentially new data\n   */\n  update(newWidget) {\n    const oldWidget = this.widget;\n\n    // Call parent update\n    super.update(newWidget);\n\n    // Cache new value\n    const newValue = newWidget.data || newWidget.value || null;\n    const oldValue = this._inheritedValue;\n\n    this._inheritedValue = newValue;\n\n    // Check if we should notify dependents\n    if (this.widget.updateShouldNotify) {\n      try {\n        const shouldNotify = this.widget.updateShouldNotify(oldWidget);\n\n        if (shouldNotify) {\n          if (this.runtime?.debugMode) {\n            console.log(\n              `[InheritedElement] Value changed, notifying ${this.dependents.size} dependents`\n            );\n          }\n\n          this.notifyDependents();\n        } else if (this.runtime?.debugMode) {\n          console.log(\n            `[InheritedElement] Value changed but updateShouldNotify returned false`\n          );\n        }\n      } catch (error) {\n        console.error(\n          `[InheritedElement] Error in updateShouldNotify: ${error.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Notify all dependent elements to rebuild\n   * Only notifies elements that are still mounted\n   */\n  notifyDependents() {\n    // Prevent recursive notifications\n    if (this._notifying) {\n      if (this.runtime?.debugMode) {\n        console.warn('[InheritedElement] Recursive notification detected, skipping');\n      }\n      return;\n    }\n\n    this._notifying = true;\n\n    try {\n      const startTime = this.runtime?.debugMode ? performance.now() : 0;\n      let notifiedCount = 0;\n\n      // Notify each dependent\n      for (const element of this.dependents) {\n        if (element.mounted && !element.dirty) {\n          element.markNeedsBuild();\n          notifiedCount++;\n        } else if (!element.mounted && this.runtime?.debugMode) {\n          console.warn(\n            `[InheritedElement] Dependent ${element.id} is not mounted, skipping`\n          );\n        }\n      }\n\n      if (this.runtime?.debugMode) {\n        const duration = performance.now() - startTime;\n        console.log(\n          `[InheritedElement] Notified ${notifiedCount} dependents in ${duration.toFixed(2)}ms`\n        );\n      }\n    } finally {\n      this._notifying = false;\n    }\n  }\n\n  /**\n   * Notify specific dependents (optimization)\n   * Use when you know only certain dependents need rebuild\n   *\n   * @param {Set<Element>} elements - Elements to notify\n   */\n  notifySpecificDependents(elements) {\n    if (this._notifying) return;\n\n    this._notifying = true;\n\n    try {\n      for (const element of elements) {\n        if (this.dependents.has(element) && element.mounted && !element.dirty) {\n          element.markNeedsBuild();\n        }\n      }\n    } finally {\n      this._notifying = false;\n    }\n  }\n\n  /**\n   * Mount element - initialize dependent tracking\n   */\n  mount() {\n    super.mount();\n\n    if (this.runtime?.debugMode) {\n      console.log(\n        `[InheritedElement] Mounted ${this.widget.constructor.name} ` +\n        `with ${this.dependents.size} dependents`\n      );\n    }\n  }\n\n  /**\n   * Unmount element - cleanup all dependent tracking\n   */\n  unmount() {\n    // Clear all dependent references\n    const dependentCount = this.dependents.size;\n\n    this.dependents.forEach(element => {\n      if (element.mounted) {\n        // Don't rebuild, just remove from tracking\n        element._inheritedDependencies?.delete(this.id);\n      }\n    });\n\n    this.dependents.clear();\n\n    if (this.runtime?.debugMode) {\n      console.log(\n        `[InheritedElement] Unmounted ${this.widget.constructor.name} ` +\n        `(cleaned up ${dependentCount} dependents)`\n      );\n    }\n\n    super.unmount();\n  }\n\n  /**\n   * Get statistics about this InheritedElement\n   *\n   * @returns {Object} Statistics object\n   */\n  getStats() {\n    const stats = super.getStats();\n\n    return {\n      ...stats,\n      type: 'InheritedElement',\n      inheritedValue: this._inheritedValue,\n      dependentCount: this.dependents.size,\n      dependents: Array.from(this.dependents).map(el => ({\n        id: el.id,\n        type: el.constructor.name,\n        mounted: el.mounted\n      }))\n    };\n  }\n}\n\n/**\n * Base InheritedWidget Class\n *\n * Widgets that provide values to their descendants.\n * Descendants access the value via context.dependOnInheritedWidgetOfExactType()\n */\nclass InheritedWidget {\n  /**\n   * Create InheritedWidget\n   * @param {Object} options - Widget options\n   * @param {Widget} options.child - Child widget to wrap\n   * @param {*} options.data - Value to provide (alternative to override in subclass)\n   * @param {*} options.value - Value to provide (preferred)\n   * @param {string} options.key - Widget key for reconciliation\n   */\n  constructor({ child, data, value, key } = {}) {\n    if (!child) {\n      throw new Error('InheritedWidget requires a child widget');\n    }\n\n    this.child = child;\n    this.data = data || value || null;\n    this.key = key;\n    this.type = 'InheritedWidget';\n  }\n\n  /**\n   * Determine if dependents should be notified of update\n   * Override in subclasses to optimize notifications\n   *\n   * @param {InheritedWidget} oldWidget - Previous widget\n   * @returns {boolean} True if dependents should rebuild\n   *\n   * @example\n   * updateShouldNotify(oldWidget) {\n   *   return this.data.theme !== oldWidget.data.theme;\n   * }\n   */\n  updateShouldNotify(oldWidget) {\n    // Default: always notify on any change\n    return this.data !== oldWidget.data;\n  }\n\n  /**\n   * Static helper to access this InheritedWidget from descendant\n   * Subclasses should override this\n   *\n   * @param {BuildContext} context - Build context\n   * @returns {InheritedWidget|null} This widget instance or null\n   *\n   * @example\n   * class Theme extends InheritedWidget {\n   *   static of(context) {\n   *     return context.dependOnInheritedWidgetOfExactType(Theme);\n   *   }\n   * }\n   *\n   * // Usage\n   * const theme = Theme.of(context);\n   */\n  static of(context) {\n    return context.dependOnInheritedWidgetOfExactType(this);\n  }\n\n  /**\n   * Create element for this widget\n   * Override to customize element type\n   *\n   * @param {Element} parent - Parent element\n   * @param {RuntimeEngine} runtime - Runtime engine\n   * @returns {Element} Element instance\n   */\n  createElement(parent, runtime) {\n    return new InheritedElement(this, parent, runtime);\n  }\n}\n\n/**\n * ChangeNotifier - Allows imperative value updates\n *\n * Subclass this to create data classes that notify listeners of changes.\n * More efficient than InheritedWidget for frequently changing values.\n */\nclass ChangeNotifier {\n  constructor() {\n    this.listeners = new Set();\n  }\n\n  /**\n   * Add listener\n   * @param {Function} listener - Callback called on change\n   */\n  addListener(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Listener must be a function');\n    }\n    this.listeners.add(listener);\n  }\n\n  /**\n   * Remove listener\n   * @param {Function} listener - Listener to remove\n   */\n  removeListener(listener) {\n    this.listeners.delete(listener);\n  }\n\n  /**\n   * Remove all listeners\n   */\n  removeAllListeners() {\n    this.listeners.clear();\n  }\n\n  /**\n   * Notify all listeners of change\n   * Call this when data changes\n   */\n  notifyListeners() {\n    for (const listener of this.listeners) {\n      try {\n        listener();\n      } catch (error) {\n        console.error('[ChangeNotifier] Listener error:', error);\n      }\n    }\n  }\n\n  /**\n   * Check if has listeners\n   * @returns {boolean} True if any listeners registered\n   */\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  /**\n   * Get listener count\n   * @returns {number} Number of listeners\n   */\n  get listenerCount() {\n    return this.listeners.size;\n  }\n\n  /**\n   * Dispose - cleanup all listeners\n   */\n  dispose() {\n    this.listeners.clear();\n  }\n}\n\n/**\n * ValueNotifier - Simple ChangeNotifier for single values\n *\n * Efficient way to manage a single reactive value.\n */\nclass ValueNotifier extends ChangeNotifier {\n  /**\n   * Create ValueNotifier\n   * @param {*} initialValue - Initial value\n   */\n  constructor(initialValue) {\n    super();\n    this._value = initialValue;\n  }\n\n  /**\n   * Get current value\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Set value and notify listeners\n   */\n  set value(newValue) {\n    if (this._value !== newValue) {\n      this._value = newValue;\n      this.notifyListeners();\n    }\n  }\n\n  /**\n   * Get value\n   * @returns {*} Current value\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * Set value with optional notification\n   * @param {*} newValue - New value\n   * @param {boolean} notify - Whether to notify listeners (default: true)\n   */\n  setValue(newValue, notify = true) {\n    if (this._value !== newValue) {\n      this._value = newValue;\n      if (notify) {\n        this.notifyListeners();\n      }\n    }\n  }\n}\n\n/**\n * Provider Widget - Helper for dependency injection\n *\n * Combines InheritedWidget with ChangeNotifier for reactive data.\n */\nclass Provider extends InheritedWidget {\n  /**\n   * Create Provider\n   * @param {Object} options\n   * @param {ChangeNotifier} options.notifier - ChangeNotifier instance\n   * @param {*} options.value - Static value (if not using notifier)\n   * @param {Widget} options.child - Child widget\n   * @param {string} options.key - Widget key\n   */\n  constructor({ notifier, value, child, key } = {}) {\n    super({ child, data: value, key });\n\n    if (notifier && !(notifier instanceof ChangeNotifier)) {\n      throw new Error('Provider requires a ChangeNotifier instance');\n    }\n\n    this.notifier = notifier;\n    this.listeners = [];\n  }\n\n  /**\n   * Only notify if notifier value actually changed\n   * @param {Provider} oldWidget - Previous widget\n   * @returns {boolean} Whether to notify\n   */\n  updateShouldNotify(oldWidget) {\n    // If using notifier, let it handle notifications\n    if (this.notifier && oldWidget.notifier === this.notifier) {\n      return false;\n    }\n\n    // If values are different, notify\n    return this.data !== oldWidget.data;\n  }\n\n  /**\n   * Get current provided value\n   * @returns {*} The value being provided\n   */\n  getValue() {\n    return this.notifier ? this.notifier.value : this.data;\n  }\n\n  /**\n   * Static helper to access provider\n   * @param {BuildContext} context\n   * @returns {Provider|null}\n   */\n  static of(context) {\n    return context.dependOnInheritedWidgetOfExactType(Provider);\n  }\n}\n\n\nexport {\n  InheritedElement,\n  InheritedWidget,\n  ChangeNotifier,\n  ValueNotifier,\n  Provider\n};"],
  "mappings": "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",
  "names": ["Element", "InheritedElement", "widget", "parent", "runtime", "childWidget", "childElement", "childVNode", "element", "newWidget", "oldWidget", "newValue", "oldValue", "error", "startTime", "notifiedCount", "duration", "elements", "dependentCount", "el", "InheritedWidget", "child", "data", "value", "key", "context", "ChangeNotifier", "listener", "ValueNotifier", "initialValue", "notify", "Provider", "notifier"]
}
