{
  "version": 3,
  "sources": ["../src/memory_manager.js"],
  "sourcesContent": ["/**\n * FlutterJS Memory Manager\n * \n * Manages memory lifecycle, prevents leaks, and tracks resource usage.\n * \n * Responsibilities:\n * - Track element references\n * - Manage event listener lifecycle\n * - Monitor VNode references\n * - Detect memory leaks\n * - Provide memory statistics\n * - Cleanup on element disposal\n */\n\n/**\n * MemoryManager Class\n * \n * Central memory management system for FlutterJS runtime\n */\nclass MemoryManager {\n  constructor(config = {}) {\n    // Configuration\n    this.config = {\n      enableLeakDetection: config.enableLeakDetection !== false,\n      leakDetectionInterval: config.leakDetectionInterval || 30000, // 30s\n      maxRetainedObjects: config.maxRetainedObjects || 10000,\n      warnThreshold: config.warnThreshold || 5000,\n      enableProfiling: config.enableProfiling || false,\n      debugMode: config.debugMode || false\n    };\n    \n    // Core registries\n    this.elementRegistry = new WeakMap();     // Element \u2192 metadata\n    this.vnodeRegistry = new WeakMap();       // VNode \u2192 element\n    this.listenerRegistry = new WeakMap();    // Element \u2192 listeners[]\n    this.stateRegistry = new WeakMap();       // State \u2192 element\n    this.disposableRegistry = new Map();      // ID \u2192 cleanup function\n    \n    // Strong references for leak detection\n    this.elementRefs = new Map();             // ID \u2192 element (for tracking)\n    this.vnodeRefs = new Map();               // ID \u2192 vnode\n    this.listenerRefs = new Map();            // ID \u2192 listener info\n    \n    // Statistics\n    this.stats = {\n      elementsCreated: 0,\n      elementsDisposed: 0,\n      vnodeCreated: 0,\n      vnodeDisposed: 0,\n      listenersAttached: 0,\n      listenersRemoved: 0,\n      cleanupCallsTotal: 0,\n      memoryLeaksDetected: 0,\n      peakElementCount: 0,\n      peakVNodeCount: 0\n    };\n    \n    // Lifecycle tracking\n    this.disposalQueue = new Set();\n    this.cleanupScheduled = false;\n    \n    // Leak detection\n    this.leakDetectionTimer = null;\n    \n    // Start leak detection if enabled\n    if (this.config.enableLeakDetection) {\n      this.startLeakDetection();\n    }\n  }\n  \n  /**\n   * Register an element\n   * @param {Element} element - Element to register\n   * @param {Object} metadata - Additional metadata\n   */\n  register(element) {\n    if (!element) {\n      throw new Error('Element is required for registration');\n    }\n    \n    // Store metadata in WeakMap (auto garbage collected)\n    const metadata = {\n      id: element.id,\n      type: element.constructor.name,\n      depth: element.depth,\n      createdAt: Date.now(),\n      mounted: element.mounted,\n      hasChildren: element.children.length > 0,\n      hasState: !!element.state,\n      parentId: element.parent ? element.parent.id : null\n    };\n    \n    this.elementRegistry.set(element, metadata);\n    \n    // Store strong reference for leak detection (with ID)\n    if (this.config.enableLeakDetection) {\n      this.elementRefs.set(element.id, {\n        element: element,\n        registeredAt: Date.now(),\n        type: element.constructor.name\n      });\n    }\n    \n    // Update stats\n    this.stats.elementsCreated++;\n    \n    if (this.elementRefs.size > this.stats.peakElementCount) {\n      this.stats.peakElementCount = this.elementRefs.size;\n    }\n    \n    // Check threshold\n    if (this.elementRefs.size > this.config.warnThreshold) {\n      this.logWarning(`Element count (${this.elementRefs.size}) exceeds threshold (${this.config.warnThreshold})`);\n    }\n    \n    if (this.config.debugMode) {\n      this.logDebug(`Registered element ${element.id} (${element.constructor.name})`);\n    }\n  }\n  \n  /**\n   * Unregister an element\n   * @param {Element} element - Element to unregister\n   */\n  unregister(element) {\n    if (!element) {\n      return;\n    }\n    \n    // Schedule cleanup instead of immediate execution\n    this.disposalQueue.add(element);\n    this.scheduleCleanup();\n  }\n  \n  /**\n   * Schedule cleanup batch\n   */\n  scheduleCleanup() {\n    if (this.cleanupScheduled) {\n      return;\n    }\n    \n    this.cleanupScheduled = true;\n    \n    // Use microtask for fast cleanup\n    Promise.resolve().then(() => {\n      this.performBatchCleanup();\n    });\n  }\n  \n  /**\n   * Perform batch cleanup\n   */\n  performBatchCleanup() {\n    this.cleanupScheduled = false;\n    \n    const elements = Array.from(this.disposalQueue);\n    this.disposalQueue.clear();\n    \n    elements.forEach(element => {\n      this.cleanupElement(element);\n    });\n    \n    if (this.config.debugMode) {\n      this.logDebug(`Batch cleanup: ${elements.length} elements`);\n    }\n  }\n  \n  /**\n   * Cleanup a single element\n   * @param {Element} element - Element to cleanup\n   */\n  cleanupElement(element) {\n    const elementId = element.id;\n    \n    try {\n      // Remove event listeners\n      this.removeAllListeners(element);\n      \n      // Cleanup VNode references\n      if (element.vnode) {\n        this.unregisterVNode(element.vnode);\n      }\n      \n      // Cleanup state references\n      if (element.state) {\n        this.stateRegistry.delete(element.state);\n      }\n      \n      // Cleanup disposables\n      if (this.disposableRegistry.has(elementId)) {\n        const cleanup = this.disposableRegistry.get(elementId);\n        try {\n          cleanup();\n        } catch (error) {\n          this.logError(`Cleanup function failed for ${elementId}:`, error);\n        }\n        this.disposableRegistry.delete(elementId);\n      }\n      \n      // Clear element references\n      element.vnode = null;\n      element.domNode = null;\n      element.children = [];\n      \n      // Remove from registries\n      this.elementRegistry.delete(element);\n      this.listenerRegistry.delete(element);\n      this.elementRefs.delete(elementId);\n      \n      // Update stats\n      this.stats.elementsDisposed++;\n      this.stats.cleanupCallsTotal++;\n      \n      if (this.config.debugMode) {\n        this.logDebug(`Cleaned up element ${elementId}`);\n      }\n    } catch (error) {\n      this.logError(`Cleanup failed for element ${elementId}:`, error);\n    }\n  }\n  \n  /**\n   * Register a VNode\n   * @param {Object} vnode - VNode to register\n   * @param {Element} element - Owning element\n   */\n  registerVNode(vnode, element) {\n    if (!vnode || !element) {\n      return;\n    }\n    \n    // Link VNode to element\n    this.vnodeRegistry.set(vnode, element);\n    \n    // Track for leak detection\n    if (this.config.enableLeakDetection) {\n      const vnodeId = this.generateVNodeId(vnode);\n      this.vnodeRefs.set(vnodeId, {\n        vnode: vnode,\n        elementId: element.id,\n        createdAt: Date.now()\n      });\n    }\n    \n    this.stats.vnodeCreated++;\n    \n    if (this.vnodeRefs.size > this.stats.peakVNodeCount) {\n      this.stats.peakVNodeCount = this.vnodeRefs.size;\n    }\n  }\n  \n  /**\n   * Unregister a VNode\n   * @param {Object} vnode - VNode to unregister\n   */\n  unregisterVNode(vnode) {\n    if (!vnode) {\n      return;\n    }\n    \n    this.vnodeRegistry.delete(vnode);\n    \n    // Remove from tracking\n    const vnodeId = this.generateVNodeId(vnode);\n    this.vnodeRefs.delete(vnodeId);\n    \n    this.stats.vnodeDisposed++;\n  }\n  \n  /**\n   * Generate VNode ID\n   */\n  generateVNodeId(vnode) {\n    if (!vnode._memoryId) {\n      vnode._memoryId = `vnode_${++MemoryManager._vnodeIdCounter}`;\n    }\n    return vnode._memoryId;\n  }\n  \n  /**\n   * Track event listener\n   * @param {Element} element - Element owning the listener\n   * @param {HTMLElement} target - DOM element\n   * @param {string} event - Event name\n   * @param {Function} handler - Event handler\n   * @param {Object} options - Event options\n   */\n  trackListener(element, target, event, handler, options = {}) {\n    if (!element || !target || !event || !handler) {\n      throw new Error('All listener parameters are required');\n    }\n    \n    // Get or create listener list for element\n    if (!this.listenerRegistry.has(element)) {\n      this.listenerRegistry.set(element, []);\n    }\n    \n    const listeners = this.listenerRegistry.get(element);\n    \n    const listenerInfo = {\n      target: target,\n      event: event,\n      handler: handler,\n      options: options,\n      attachedAt: Date.now()\n    };\n    \n    listeners.push(listenerInfo);\n    \n    // Track for leak detection\n    if (this.config.enableLeakDetection) {\n      const listenerId = `${element.id}_${event}_${listeners.length}`;\n      this.listenerRefs.set(listenerId, {\n        elementId: element.id,\n        event: event,\n        attachedAt: Date.now()\n      });\n    }\n    \n    this.stats.listenersAttached++;\n    \n    if (this.config.debugMode) {\n      this.logDebug(`Tracked listener: ${element.id} \u2192 ${event}`);\n    }\n  }\n  \n  /**\n   * Remove all listeners for an element\n   * @param {Element} element - Element to remove listeners from\n   */\n  removeAllListeners(element) {\n    if (!element) {\n      return;\n    }\n    \n    const listeners = this.listenerRegistry.get(element);\n    \n    if (!listeners || listeners.length === 0) {\n      return;\n    }\n    \n    // Remove each listener\n    listeners.forEach(({ target, event, handler, options }) => {\n      try {\n        if (target && target.removeEventListener) {\n          target.removeEventListener(event, handler, options);\n        }\n        this.stats.listenersRemoved++;\n      } catch (error) {\n        this.logError(`Failed to remove listener ${event}:`, error);\n      }\n    });\n    \n    // Clear listener list\n    this.listenerRegistry.delete(element);\n    \n    // Remove from tracking\n    if (this.config.enableLeakDetection) {\n      listeners.forEach((_, index) => {\n        const listenerId = `${element.id}_${listeners[index].event}_${index + 1}`;\n        this.listenerRefs.delete(listenerId);\n      });\n    }\n    \n    if (this.config.debugMode) {\n      this.logDebug(`Removed ${listeners.length} listeners from ${element.id}`);\n    }\n  }\n  \n  /**\n   * Register a disposable cleanup function\n   * @param {string} id - Unique identifier\n   * @param {Function} cleanup - Cleanup function\n   */\n  registerDisposable(id, cleanup) {\n    if (!id || typeof cleanup !== 'function') {\n      throw new Error('Valid ID and cleanup function required');\n    }\n    \n    this.disposableRegistry.set(id, cleanup);\n  }\n  \n  /**\n   * Track state object\n   * @param {Object} state - State object\n   * @param {Element} element - Owning element\n   */\n  trackState(state, element) {\n    if (!state || !element) {\n      return;\n    }\n    \n    this.stateRegistry.set(state, element);\n  }\n  \n  /**\n   * Get element by ID (for debugging)\n   * @param {string} elementId - Element ID\n   * @returns {Element|null}\n   */\n  getElementById(elementId) {\n    const ref = this.elementRefs.get(elementId);\n    return ref ? ref.element : null;\n  }\n  \n  /**\n   * Get element metadata\n   * @param {Element} element - Element\n   * @returns {Object|null}\n   */\n  getElementMetadata(element) {\n    return this.elementRegistry.get(element) || null;\n  }\n  \n  /**\n   * Get element owning a VNode\n   * @param {Object} vnode - VNode\n   * @returns {Element|null}\n   */\n  getElementForVNode(vnode) {\n    return this.vnodeRegistry.get(vnode) || null;\n  }\n  \n  /**\n   * Get listeners for an element\n   * @param {Element} element - Element\n   * @returns {Array}\n   */\n  getListenersForElement(element) {\n    return this.listenerRegistry.get(element) || [];\n  }\n  \n  /**\n   * Start leak detection\n   */\n  startLeakDetection() {\n    if (this.leakDetectionTimer) {\n      return;\n    }\n    \n    this.leakDetectionTimer = setInterval(() => {\n      this.detectLeaks();\n    }, this.config.leakDetectionInterval);\n    \n    if (this.config.debugMode) {\n      this.logDebug('Leak detection started');\n    }\n  }\n  \n  /**\n   * Stop leak detection\n   */\n  stopLeakDetection() {\n    if (this.leakDetectionTimer) {\n      clearInterval(this.leakDetectionTimer);\n      this.leakDetectionTimer = null;\n      \n      if (this.config.debugMode) {\n        this.logDebug('Leak detection stopped');\n      }\n    }\n  }\n  \n  /**\n   * Detect memory leaks\n   */\n  detectLeaks() {\n    const now = Date.now();\n    const leakThreshold = 60000; // 60 seconds\n    \n    const potentialLeaks = [];\n    \n    // Check for old unmounted elements still in memory\n    this.elementRefs.forEach((ref, id) => {\n      const element = ref.element;\n      const age = now - ref.registeredAt;\n      \n      // If element is old and unmounted, it might be leaked\n      if (!element.mounted && age > leakThreshold) {\n        potentialLeaks.push({\n          type: 'element',\n          id: id,\n          elementType: ref.type,\n          age: age,\n          mounted: element.mounted\n        });\n      }\n    });\n    \n    // Check for orphaned VNodes\n    this.vnodeRefs.forEach((ref, id) => {\n      const age = now - ref.createdAt;\n      \n      // If VNode is very old, might be leaked\n      if (age > leakThreshold * 2) {\n        potentialLeaks.push({\n          type: 'vnode',\n          id: id,\n          elementId: ref.elementId,\n          age: age\n        });\n      }\n    });\n    \n    // Check for orphaned listeners\n    this.listenerRefs.forEach((ref, id) => {\n      const age = now - ref.attachedAt;\n      \n      if (age > leakThreshold) {\n        potentialLeaks.push({\n          type: 'listener',\n          id: id,\n          elementId: ref.elementId,\n          event: ref.event,\n          age: age\n        });\n      }\n    });\n    \n    if (potentialLeaks.length > 0) {\n      this.stats.memoryLeaksDetected += potentialLeaks.length;\n      \n      this.logWarning(`Potential memory leaks detected: ${potentialLeaks.length}`);\n      \n      if (this.config.debugMode) {\n        potentialLeaks.forEach(leak => {\n          this.logDebug(`Leak: ${leak.type} ${leak.id} (age: ${Math.round(leak.age / 1000)}s)`);\n        });\n      }\n    }\n    \n    return potentialLeaks;\n  }\n  \n  /**\n   * Force cleanup of all unmounted elements\n   */\n  forceCleanupUnmounted() {\n    const cleanedElements = [];\n    \n    this.elementRefs.forEach((ref, id) => {\n      if (!ref.element.mounted) {\n        this.cleanupElement(ref.element);\n        cleanedElements.push(id);\n      }\n    });\n    \n    if (this.config.debugMode) {\n      this.logDebug(`Force cleanup: ${cleanedElements.length} elements`);\n    }\n    \n    return cleanedElements.length;\n  }\n  \n  /**\n   * Get memory statistics\n   * @returns {Object}\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      currentElements: this.elementRefs.size,\n      currentVNodes: this.vnodeRefs.size,\n      currentListeners: this.listenerRefs.size,\n      disposablesRegistered: this.disposableRegistry.size,\n      elementsInQueue: this.disposalQueue.size,\n      leakDetectionEnabled: this.config.enableLeakDetection\n    };\n  }\n  \n  /**\n   * Get detailed report\n   * @returns {Object}\n   */\n  getDetailedReport() {\n    const elements = [];\n    \n    this.elementRefs.forEach((ref, id) => {\n      const element = ref.element;\n      elements.push({\n        id: id,\n        type: ref.type,\n        mounted: element.mounted,\n        depth: element.depth,\n        childCount: element.children.length,\n        hasState: !!element.state,\n        age: Date.now() - ref.registeredAt\n      });\n    });\n    \n    return {\n      stats: this.getStats(),\n      elements: elements,\n      config: this.config,\n      timestamp: Date.now()\n    };\n  }\n  \n  /**\n   * Reset statistics\n   */\n  resetStats() {\n    this.stats = {\n      elementsCreated: 0,\n      elementsDisposed: 0,\n      vnodeCreated: 0,\n      vnodeDisposed: 0,\n      listenersAttached: 0,\n      listenersRemoved: 0,\n      cleanupCallsTotal: 0,\n      memoryLeaksDetected: 0,\n      peakElementCount: 0,\n      peakVNodeCount: 0\n    };\n  }\n  \n  /**\n   * Clear all registries (for testing/reset)\n   */\n  clear() {\n    // Perform cleanup on all elements\n    this.elementRefs.forEach((ref) => {\n      this.cleanupElement(ref.element);\n    });\n    \n    // Clear all registries\n    this.elementRefs.clear();\n    this.vnodeRefs.clear();\n    this.listenerRefs.clear();\n    this.disposableRegistry.clear();\n    this.disposalQueue.clear();\n    \n    if (this.config.debugMode) {\n      this.logDebug('Memory manager cleared');\n    }\n  }\n  \n  /**\n   * Dispose memory manager\n   */\n  dispose() {\n    this.stopLeakDetection();\n    this.clear();\n    \n    if (this.config.debugMode) {\n      this.logDebug('Memory manager disposed');\n    }\n  }\n  \n  // Logging helpers\n  \n  logDebug(message) {\n    if (this.config.debugMode) {\n      console.log(`[MemoryManager] ${message}`);\n    }\n  }\n  \n  logWarning(message) {\n    console.warn(`[MemoryManager] \u26A0\uFE0F  ${message}`);\n  }\n  \n  logError(message, error) {\n    console.error(`[MemoryManager] \u274C ${message}`, error);\n  }\n}\n\n// Static counter for VNode IDs\nMemoryManager._vnodeIdCounter = 0;\n\n/**\n * Memory profiler for detailed analysis\n */\nclass MemoryProfiler {\n  constructor(memoryManager) {\n    this.memoryManager = memoryManager;\n    this.snapshots = [];\n    this.maxSnapshots = 50;\n  }\n  \n  /**\n   * Take a memory snapshot\n   */\n  takeSnapshot() {\n    const stats = this.memoryManager.getStats();\n    \n    const snapshot = {\n      timestamp: Date.now(),\n      stats: { ...stats },\n      heapUsage: this.getHeapUsage()\n    };\n    \n    this.snapshots.push(snapshot);\n    \n    // Keep only recent snapshots\n    if (this.snapshots.length > this.maxSnapshots) {\n      this.snapshots.shift();\n    }\n    \n    return snapshot;\n  }\n  \n  /**\n   * Get heap usage (if available)\n   */\n  getHeapUsage() {\n    if (typeof performance !== 'undefined' && performance.memory) {\n      return {\n        usedJSHeapSize: performance.memory.usedJSHeapSize,\n        totalJSHeapSize: performance.memory.totalJSHeapSize,\n        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit\n      };\n    }\n    return null;\n  }\n  \n  /**\n   * Compare two snapshots\n   */\n  compareSnapshots(snapshot1, snapshot2) {\n    const diff = {};\n    \n    Object.keys(snapshot1.stats).forEach(key => {\n      diff[key] = snapshot2.stats[key] - snapshot1.stats[key];\n    });\n    \n    return diff;\n  }\n  \n  /**\n   * Get growth trend\n   */\n  getTrend() {\n    if (this.snapshots.length < 2) {\n      return null;\n    }\n    \n    const first = this.snapshots[0];\n    const last = this.snapshots[this.snapshots.length - 1];\n    \n    return this.compareSnapshots(first, last);\n  }\n  \n  /**\n   * Clear snapshots\n   */\n  clear() {\n    this.snapshots = [];\n  }\n}\n\n\nexport { MemoryManager,\n    MemoryProfiler};"],
  "mappings": "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",
  "names": ["MemoryManager", "config", "element", "metadata", "elements", "elementId", "cleanup", "error", "vnode", "vnodeId", "target", "event", "handler", "options", "listeners", "listenerInfo", "listenerId", "_", "index", "id", "state", "ref", "now", "leakThreshold", "potentialLeaks", "age", "leak", "cleanedElements", "message", "MemoryProfiler", "memoryManager", "stats", "snapshot", "snapshot1", "snapshot2", "diff", "key", "first", "last"]
}
