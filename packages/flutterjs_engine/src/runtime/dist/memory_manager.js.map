{
  "version": 3,
  "sources": ["../src/memory_manager.js"],
  "sourcesContent": ["/**\r\n * FlutterJS Memory Manager\r\n * \r\n * Manages memory lifecycle, prevents leaks, and tracks resource usage.\r\n * \r\n * Responsibilities:\r\n * - Track element references\r\n * - Manage event listener lifecycle\r\n * - Monitor VNode references\r\n * - Detect memory leaks\r\n * - Provide memory statistics\r\n * - Cleanup on element disposal\r\n */\r\n\r\n/**\r\n * MemoryManager Class\r\n * \r\n * Central memory management system for FlutterJS runtime\r\n */\r\nclass MemoryManager {\r\n  constructor(config = {}) {\r\n    // Configuration\r\n    this.config = {\r\n      enableLeakDetection: config.enableLeakDetection !== false,\r\n      leakDetectionInterval: config.leakDetectionInterval || 30000, // 30s\r\n      maxRetainedObjects: config.maxRetainedObjects || 10000,\r\n      warnThreshold: config.warnThreshold || 5000,\r\n      enableProfiling: config.enableProfiling || false,\r\n      debugMode: config.debugMode || false\r\n    };\r\n    \r\n    // Core registries\r\n    this.elementRegistry = new WeakMap();     // Element \u2192 metadata\r\n    this.vnodeRegistry = new WeakMap();       // VNode \u2192 element\r\n    this.listenerRegistry = new WeakMap();    // Element \u2192 listeners[]\r\n    this.stateRegistry = new WeakMap();       // State \u2192 element\r\n    this.disposableRegistry = new Map();      // ID \u2192 cleanup function\r\n    \r\n    // Strong references for leak detection\r\n    this.elementRefs = new Map();             // ID \u2192 element (for tracking)\r\n    this.vnodeRefs = new Map();               // ID \u2192 vnode\r\n    this.listenerRefs = new Map();            // ID \u2192 listener info\r\n    \r\n    // Statistics\r\n    this.stats = {\r\n      elementsCreated: 0,\r\n      elementsDisposed: 0,\r\n      vnodeCreated: 0,\r\n      vnodeDisposed: 0,\r\n      listenersAttached: 0,\r\n      listenersRemoved: 0,\r\n      cleanupCallsTotal: 0,\r\n      memoryLeaksDetected: 0,\r\n      peakElementCount: 0,\r\n      peakVNodeCount: 0\r\n    };\r\n    \r\n    // Lifecycle tracking\r\n    this.disposalQueue = new Set();\r\n    this.cleanupScheduled = false;\r\n    \r\n    // Leak detection\r\n    this.leakDetectionTimer = null;\r\n    \r\n    // Start leak detection if enabled\r\n    if (this.config.enableLeakDetection) {\r\n      this.startLeakDetection();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Register an element\r\n   * @param {Element} element - Element to register\r\n   * @param {Object} metadata - Additional metadata\r\n   */\r\n  register(element) {\r\n    if (!element) {\r\n      throw new Error('Element is required for registration');\r\n    }\r\n    \r\n    // Store metadata in WeakMap (auto garbage collected)\r\n    const metadata = {\r\n      id: element.id,\r\n      type: element.constructor.name,\r\n      depth: element.depth,\r\n      createdAt: Date.now(),\r\n      mounted: element.mounted,\r\n      hasChildren: element.children.length > 0,\r\n      hasState: !!element.state,\r\n      parentId: element.parent ? element.parent.id : null\r\n    };\r\n    \r\n    this.elementRegistry.set(element, metadata);\r\n    \r\n    // Store strong reference for leak detection (with ID)\r\n    if (this.config.enableLeakDetection) {\r\n      this.elementRefs.set(element.id, {\r\n        element: element,\r\n        registeredAt: Date.now(),\r\n        type: element.constructor.name\r\n      });\r\n    }\r\n    \r\n    // Update stats\r\n    this.stats.elementsCreated++;\r\n    \r\n    if (this.elementRefs.size > this.stats.peakElementCount) {\r\n      this.stats.peakElementCount = this.elementRefs.size;\r\n    }\r\n    \r\n    // Check threshold\r\n    if (this.elementRefs.size > this.config.warnThreshold) {\r\n      this.logWarning(`Element count (${this.elementRefs.size}) exceeds threshold (${this.config.warnThreshold})`);\r\n    }\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug(`Registered element ${element.id} (${element.constructor.name})`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Unregister an element\r\n   * @param {Element} element - Element to unregister\r\n   */\r\n  unregister(element) {\r\n    if (!element) {\r\n      return;\r\n    }\r\n    \r\n    // Schedule cleanup instead of immediate execution\r\n    this.disposalQueue.add(element);\r\n    this.scheduleCleanup();\r\n  }\r\n  \r\n  /**\r\n   * Schedule cleanup batch\r\n   */\r\n  scheduleCleanup() {\r\n    if (this.cleanupScheduled) {\r\n      return;\r\n    }\r\n    \r\n    this.cleanupScheduled = true;\r\n    \r\n    // Use microtask for fast cleanup\r\n    Promise.resolve().then(() => {\r\n      this.performBatchCleanup();\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Perform batch cleanup\r\n   */\r\n  performBatchCleanup() {\r\n    this.cleanupScheduled = false;\r\n    \r\n    const elements = Array.from(this.disposalQueue);\r\n    this.disposalQueue.clear();\r\n    \r\n    elements.forEach(element => {\r\n      this.cleanupElement(element);\r\n    });\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug(`Batch cleanup: ${elements.length} elements`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Cleanup a single element\r\n   * @param {Element} element - Element to cleanup\r\n   */\r\n  cleanupElement(element) {\r\n    const elementId = element.id;\r\n    \r\n    try {\r\n      // Remove event listeners\r\n      this.removeAllListeners(element);\r\n      \r\n      // Cleanup VNode references\r\n      if (element.vnode) {\r\n        this.unregisterVNode(element.vnode);\r\n      }\r\n      \r\n      // Cleanup state references\r\n      if (element.state) {\r\n        this.stateRegistry.delete(element.state);\r\n      }\r\n      \r\n      // Cleanup disposables\r\n      if (this.disposableRegistry.has(elementId)) {\r\n        const cleanup = this.disposableRegistry.get(elementId);\r\n        try {\r\n          cleanup();\r\n        } catch (error) {\r\n          this.logError(`Cleanup function failed for ${elementId}:`, error);\r\n        }\r\n        this.disposableRegistry.delete(elementId);\r\n      }\r\n      \r\n      // Clear element references\r\n      element.vnode = null;\r\n      element.domNode = null;\r\n      element.children = [];\r\n      \r\n      // Remove from registries\r\n      this.elementRegistry.delete(element);\r\n      this.listenerRegistry.delete(element);\r\n      this.elementRefs.delete(elementId);\r\n      \r\n      // Update stats\r\n      this.stats.elementsDisposed++;\r\n      this.stats.cleanupCallsTotal++;\r\n      \r\n      if (this.config.debugMode) {\r\n        this.logDebug(`Cleaned up element ${elementId}`);\r\n      }\r\n    } catch (error) {\r\n      this.logError(`Cleanup failed for element ${elementId}:`, error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Register a VNode\r\n   * @param {Object} vnode - VNode to register\r\n   * @param {Element} element - Owning element\r\n   */\r\n  registerVNode(vnode, element) {\r\n    if (!vnode || !element) {\r\n      return;\r\n    }\r\n    \r\n    // Link VNode to element\r\n    this.vnodeRegistry.set(vnode, element);\r\n    \r\n    // Track for leak detection\r\n    if (this.config.enableLeakDetection) {\r\n      const vnodeId = this.generateVNodeId(vnode);\r\n      this.vnodeRefs.set(vnodeId, {\r\n        vnode: vnode,\r\n        elementId: element.id,\r\n        createdAt: Date.now()\r\n      });\r\n    }\r\n    \r\n    this.stats.vnodeCreated++;\r\n    \r\n    if (this.vnodeRefs.size > this.stats.peakVNodeCount) {\r\n      this.stats.peakVNodeCount = this.vnodeRefs.size;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Unregister a VNode\r\n   * @param {Object} vnode - VNode to unregister\r\n   */\r\n  unregisterVNode(vnode) {\r\n    if (!vnode) {\r\n      return;\r\n    }\r\n    \r\n    this.vnodeRegistry.delete(vnode);\r\n    \r\n    // Remove from tracking\r\n    const vnodeId = this.generateVNodeId(vnode);\r\n    this.vnodeRefs.delete(vnodeId);\r\n    \r\n    this.stats.vnodeDisposed++;\r\n  }\r\n  \r\n  /**\r\n   * Generate VNode ID\r\n   */\r\n  generateVNodeId(vnode) {\r\n    if (!vnode._memoryId) {\r\n      vnode._memoryId = `vnode_${++MemoryManager._vnodeIdCounter}`;\r\n    }\r\n    return vnode._memoryId;\r\n  }\r\n  \r\n  /**\r\n   * Track event listener\r\n   * @param {Element} element - Element owning the listener\r\n   * @param {HTMLElement} target - DOM element\r\n   * @param {string} event - Event name\r\n   * @param {Function} handler - Event handler\r\n   * @param {Object} options - Event options\r\n   */\r\n  trackListener(element, target, event, handler, options = {}) {\r\n    if (!element || !target || !event || !handler) {\r\n      throw new Error('All listener parameters are required');\r\n    }\r\n    \r\n    // Get or create listener list for element\r\n    if (!this.listenerRegistry.has(element)) {\r\n      this.listenerRegistry.set(element, []);\r\n    }\r\n    \r\n    const listeners = this.listenerRegistry.get(element);\r\n    \r\n    const listenerInfo = {\r\n      target: target,\r\n      event: event,\r\n      handler: handler,\r\n      options: options,\r\n      attachedAt: Date.now()\r\n    };\r\n    \r\n    listeners.push(listenerInfo);\r\n    \r\n    // Track for leak detection\r\n    if (this.config.enableLeakDetection) {\r\n      const listenerId = `${element.id}_${event}_${listeners.length}`;\r\n      this.listenerRefs.set(listenerId, {\r\n        elementId: element.id,\r\n        event: event,\r\n        attachedAt: Date.now()\r\n      });\r\n    }\r\n    \r\n    this.stats.listenersAttached++;\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug(`Tracked listener: ${element.id} \u2192 ${event}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Remove all listeners for an element\r\n   * @param {Element} element - Element to remove listeners from\r\n   */\r\n  removeAllListeners(element) {\r\n    if (!element) {\r\n      return;\r\n    }\r\n    \r\n    const listeners = this.listenerRegistry.get(element);\r\n    \r\n    if (!listeners || listeners.length === 0) {\r\n      return;\r\n    }\r\n    \r\n    // Remove each listener\r\n    listeners.forEach(({ target, event, handler, options }) => {\r\n      try {\r\n        if (target && target.removeEventListener) {\r\n          target.removeEventListener(event, handler, options);\r\n        }\r\n        this.stats.listenersRemoved++;\r\n      } catch (error) {\r\n        this.logError(`Failed to remove listener ${event}:`, error);\r\n      }\r\n    });\r\n    \r\n    // Clear listener list\r\n    this.listenerRegistry.delete(element);\r\n    \r\n    // Remove from tracking\r\n    if (this.config.enableLeakDetection) {\r\n      listeners.forEach((_, index) => {\r\n        const listenerId = `${element.id}_${listeners[index].event}_${index + 1}`;\r\n        this.listenerRefs.delete(listenerId);\r\n      });\r\n    }\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug(`Removed ${listeners.length} listeners from ${element.id}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Register a disposable cleanup function\r\n   * @param {string} id - Unique identifier\r\n   * @param {Function} cleanup - Cleanup function\r\n   */\r\n  registerDisposable(id, cleanup) {\r\n    if (!id || typeof cleanup !== 'function') {\r\n      throw new Error('Valid ID and cleanup function required');\r\n    }\r\n    \r\n    this.disposableRegistry.set(id, cleanup);\r\n  }\r\n  \r\n  /**\r\n   * Track state object\r\n   * @param {Object} state - State object\r\n   * @param {Element} element - Owning element\r\n   */\r\n  trackState(state, element) {\r\n    if (!state || !element) {\r\n      return;\r\n    }\r\n    \r\n    this.stateRegistry.set(state, element);\r\n  }\r\n  \r\n  /**\r\n   * Get element by ID (for debugging)\r\n   * @param {string} elementId - Element ID\r\n   * @returns {Element|null}\r\n   */\r\n  getElementById(elementId) {\r\n    const ref = this.elementRefs.get(elementId);\r\n    return ref ? ref.element : null;\r\n  }\r\n  \r\n  /**\r\n   * Get element metadata\r\n   * @param {Element} element - Element\r\n   * @returns {Object|null}\r\n   */\r\n  getElementMetadata(element) {\r\n    return this.elementRegistry.get(element) || null;\r\n  }\r\n  \r\n  /**\r\n   * Get element owning a VNode\r\n   * @param {Object} vnode - VNode\r\n   * @returns {Element|null}\r\n   */\r\n  getElementForVNode(vnode) {\r\n    return this.vnodeRegistry.get(vnode) || null;\r\n  }\r\n  \r\n  /**\r\n   * Get listeners for an element\r\n   * @param {Element} element - Element\r\n   * @returns {Array}\r\n   */\r\n  getListenersForElement(element) {\r\n    return this.listenerRegistry.get(element) || [];\r\n  }\r\n  \r\n  /**\r\n   * Start leak detection\r\n   */\r\n  startLeakDetection() {\r\n    if (this.leakDetectionTimer) {\r\n      return;\r\n    }\r\n    \r\n    this.leakDetectionTimer = setInterval(() => {\r\n      this.detectLeaks();\r\n    }, this.config.leakDetectionInterval);\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug('Leak detection started');\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Stop leak detection\r\n   */\r\n  stopLeakDetection() {\r\n    if (this.leakDetectionTimer) {\r\n      clearInterval(this.leakDetectionTimer);\r\n      this.leakDetectionTimer = null;\r\n      \r\n      if (this.config.debugMode) {\r\n        this.logDebug('Leak detection stopped');\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Detect memory leaks\r\n   */\r\n  detectLeaks() {\r\n    const now = Date.now();\r\n    const leakThreshold = 60000; // 60 seconds\r\n    \r\n    const potentialLeaks = [];\r\n    \r\n    // Check for old unmounted elements still in memory\r\n    this.elementRefs.forEach((ref, id) => {\r\n      const element = ref.element;\r\n      const age = now - ref.registeredAt;\r\n      \r\n      // If element is old and unmounted, it might be leaked\r\n      if (!element.mounted && age > leakThreshold) {\r\n        potentialLeaks.push({\r\n          type: 'element',\r\n          id: id,\r\n          elementType: ref.type,\r\n          age: age,\r\n          mounted: element.mounted\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Check for orphaned VNodes\r\n    this.vnodeRefs.forEach((ref, id) => {\r\n      const age = now - ref.createdAt;\r\n      \r\n      // If VNode is very old, might be leaked\r\n      if (age > leakThreshold * 2) {\r\n        potentialLeaks.push({\r\n          type: 'vnode',\r\n          id: id,\r\n          elementId: ref.elementId,\r\n          age: age\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Check for orphaned listeners\r\n    this.listenerRefs.forEach((ref, id) => {\r\n      const age = now - ref.attachedAt;\r\n      \r\n      if (age > leakThreshold) {\r\n        potentialLeaks.push({\r\n          type: 'listener',\r\n          id: id,\r\n          elementId: ref.elementId,\r\n          event: ref.event,\r\n          age: age\r\n        });\r\n      }\r\n    });\r\n    \r\n    if (potentialLeaks.length > 0) {\r\n      this.stats.memoryLeaksDetected += potentialLeaks.length;\r\n      \r\n      this.logWarning(`Potential memory leaks detected: ${potentialLeaks.length}`);\r\n      \r\n      if (this.config.debugMode) {\r\n        potentialLeaks.forEach(leak => {\r\n          this.logDebug(`Leak: ${leak.type} ${leak.id} (age: ${Math.round(leak.age / 1000)}s)`);\r\n        });\r\n      }\r\n    }\r\n    \r\n    return potentialLeaks;\r\n  }\r\n  \r\n  /**\r\n   * Force cleanup of all unmounted elements\r\n   */\r\n  forceCleanupUnmounted() {\r\n    const cleanedElements = [];\r\n    \r\n    this.elementRefs.forEach((ref, id) => {\r\n      if (!ref.element.mounted) {\r\n        this.cleanupElement(ref.element);\r\n        cleanedElements.push(id);\r\n      }\r\n    });\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug(`Force cleanup: ${cleanedElements.length} elements`);\r\n    }\r\n    \r\n    return cleanedElements.length;\r\n  }\r\n  \r\n  /**\r\n   * Get memory statistics\r\n   * @returns {Object}\r\n   */\r\n  getStats() {\r\n    return {\r\n      ...this.stats,\r\n      currentElements: this.elementRefs.size,\r\n      currentVNodes: this.vnodeRefs.size,\r\n      currentListeners: this.listenerRefs.size,\r\n      disposablesRegistered: this.disposableRegistry.size,\r\n      elementsInQueue: this.disposalQueue.size,\r\n      leakDetectionEnabled: this.config.enableLeakDetection\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get detailed report\r\n   * @returns {Object}\r\n   */\r\n  getDetailedReport() {\r\n    const elements = [];\r\n    \r\n    this.elementRefs.forEach((ref, id) => {\r\n      const element = ref.element;\r\n      elements.push({\r\n        id: id,\r\n        type: ref.type,\r\n        mounted: element.mounted,\r\n        depth: element.depth,\r\n        childCount: element.children.length,\r\n        hasState: !!element.state,\r\n        age: Date.now() - ref.registeredAt\r\n      });\r\n    });\r\n    \r\n    return {\r\n      stats: this.getStats(),\r\n      elements: elements,\r\n      config: this.config,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Reset statistics\r\n   */\r\n  resetStats() {\r\n    this.stats = {\r\n      elementsCreated: 0,\r\n      elementsDisposed: 0,\r\n      vnodeCreated: 0,\r\n      vnodeDisposed: 0,\r\n      listenersAttached: 0,\r\n      listenersRemoved: 0,\r\n      cleanupCallsTotal: 0,\r\n      memoryLeaksDetected: 0,\r\n      peakElementCount: 0,\r\n      peakVNodeCount: 0\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Clear all registries (for testing/reset)\r\n   */\r\n  clear() {\r\n    // Perform cleanup on all elements\r\n    this.elementRefs.forEach((ref) => {\r\n      this.cleanupElement(ref.element);\r\n    });\r\n    \r\n    // Clear all registries\r\n    this.elementRefs.clear();\r\n    this.vnodeRefs.clear();\r\n    this.listenerRefs.clear();\r\n    this.disposableRegistry.clear();\r\n    this.disposalQueue.clear();\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug('Memory manager cleared');\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Dispose memory manager\r\n   */\r\n  dispose() {\r\n    this.stopLeakDetection();\r\n    this.clear();\r\n    \r\n    if (this.config.debugMode) {\r\n      this.logDebug('Memory manager disposed');\r\n    }\r\n  }\r\n  \r\n  // Logging helpers\r\n  \r\n  logDebug(message) {\r\n    if (this.config.debugMode) {\r\n      console.log(`[MemoryManager] ${message}`);\r\n    }\r\n  }\r\n  \r\n  logWarning(message) {\r\n    console.warn(`[MemoryManager] \u26A0\uFE0F  ${message}`);\r\n  }\r\n  \r\n  logError(message, error) {\r\n    console.error(`[MemoryManager] \u274C ${message}`, error);\r\n  }\r\n}\r\n\r\n// Static counter for VNode IDs\r\nMemoryManager._vnodeIdCounter = 0;\r\n\r\n/**\r\n * Memory profiler for detailed analysis\r\n */\r\nclass MemoryProfiler {\r\n  constructor(memoryManager) {\r\n    this.memoryManager = memoryManager;\r\n    this.snapshots = [];\r\n    this.maxSnapshots = 50;\r\n  }\r\n  \r\n  /**\r\n   * Take a memory snapshot\r\n   */\r\n  takeSnapshot() {\r\n    const stats = this.memoryManager.getStats();\r\n    \r\n    const snapshot = {\r\n      timestamp: Date.now(),\r\n      stats: { ...stats },\r\n      heapUsage: this.getHeapUsage()\r\n    };\r\n    \r\n    this.snapshots.push(snapshot);\r\n    \r\n    // Keep only recent snapshots\r\n    if (this.snapshots.length > this.maxSnapshots) {\r\n      this.snapshots.shift();\r\n    }\r\n    \r\n    return snapshot;\r\n  }\r\n  \r\n  /**\r\n   * Get heap usage (if available)\r\n   */\r\n  getHeapUsage() {\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      return {\r\n        usedJSHeapSize: performance.memory.usedJSHeapSize,\r\n        totalJSHeapSize: performance.memory.totalJSHeapSize,\r\n        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Compare two snapshots\r\n   */\r\n  compareSnapshots(snapshot1, snapshot2) {\r\n    const diff = {};\r\n    \r\n    Object.keys(snapshot1.stats).forEach(key => {\r\n      diff[key] = snapshot2.stats[key] - snapshot1.stats[key];\r\n    });\r\n    \r\n    return diff;\r\n  }\r\n  \r\n  /**\r\n   * Get growth trend\r\n   */\r\n  getTrend() {\r\n    if (this.snapshots.length < 2) {\r\n      return null;\r\n    }\r\n    \r\n    const first = this.snapshots[0];\r\n    const last = this.snapshots[this.snapshots.length - 1];\r\n    \r\n    return this.compareSnapshots(first, last);\r\n  }\r\n  \r\n  /**\r\n   * Clear snapshots\r\n   */\r\n  clear() {\r\n    this.snapshots = [];\r\n  }\r\n}\r\n\r\n\r\nexport { MemoryManager,\r\n    MemoryProfiler};"],
  "mappings": "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",
  "names": ["MemoryManager", "config", "element", "metadata", "elements", "elementId", "cleanup", "error", "vnode", "vnodeId", "target", "event", "handler", "options", "listeners", "listenerInfo", "listenerId", "_", "index", "id", "state", "ref", "now", "leakThreshold", "potentialLeaks", "age", "leak", "cleanedElements", "message", "MemoryProfiler", "memoryManager", "stats", "snapshot", "snapshot1", "snapshot2", "diff", "key", "first", "last"]
}
