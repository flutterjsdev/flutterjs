{
  "version": 3,
  "sources": ["../src/focus_manager.js"],
  "sourcesContent": ["/**\n * Focus Manager\n * \n * Manages keyboard focus and navigation across the widget tree.\n * Handles Tab navigation, autofocus, focus scopes, and programmatic focus control.\n * \n * Features:\n * - Focus registration and tracking\n * - Keyboard navigation (Tab/Shift+Tab)\n * - Focus scopes for modal dialogs\n * - Autofocus support\n * - Focus event callbacks\n * - Accessibility support\n */\n\nclass FocusManager {\n  constructor(runtime) {\n    this.runtime = runtime;\n    this.focusedElement = null;\n    this.focusableElements = new Map(); // elementId \u2192 FocusableInfo\n    this.focusScopes = new Map(); // scopeId \u2192 [elementIds]\n    this.activeScopeId = null;\n    \n    // Focus event listeners\n    this.focusChangeListeners = new Set();\n    \n    // Keyboard navigation\n    this.keyboardEnabled = false;\n    this.keyboardHandler = null;\n  }\n  \n  /**\n   * Register a focusable element\n   * @param {string} elementId - Unique element identifier\n   * @param {HTMLElement} domElement - Actual DOM element\n   * @param {Object} options - Focus configuration\n   */\n  registerFocusable(elementId, domElement, options = {}) {\n    if (!elementId || !domElement) {\n      console.warn('[FocusManager] Invalid registration:', { elementId, domElement });\n      return;\n    }\n    \n    const focusableInfo = {\n      elementId,\n      element: domElement,\n      canRequestFocus: options.canRequestFocus !== false,\n      skipTraversal: options.skipTraversal === true,\n      autofocus: options.autofocus === true,\n      onFocusChange: options.onFocusChange || null,\n      tabIndex: options.tabIndex ?? 0,\n      scopeId: options.scopeId || null\n    };\n    \n    this.focusableElements.set(elementId, focusableInfo);\n    \n    // Set tabIndex for keyboard navigation\n    if (!focusableInfo.skipTraversal) {\n      domElement.tabIndex = focusableInfo.tabIndex;\n    }\n    \n    // Attach DOM focus/blur listeners\n    this._attachDOMListeners(domElement, elementId);\n    \n    // Handle autofocus\n    if (focusableInfo.autofocus) {\n      // Defer to next tick to ensure element is mounted\n      requestAnimationFrame(() => {\n        if (this.focusableElements.has(elementId)) {\n          this.requestFocus(elementId);\n        }\n      });\n    }\n  }\n  \n  /**\n   * Unregister a focusable element\n   * @param {string} elementId - Element to unregister\n   */\n  unregisterFocusable(elementId) {\n    const info = this.focusableElements.get(elementId);\n    if (!info) return;\n    \n    // Blur if currently focused\n    if (this.focusedElement === elementId) {\n      this.focusedElement = null;\n      this._notifyFocusChange(null, elementId);\n    }\n    \n    // Remove from scopes\n    for (const [scopeId, elementIds] of this.focusScopes.entries()) {\n      const index = elementIds.indexOf(elementId);\n      if (index !== -1) {\n        elementIds.splice(index, 1);\n      }\n    }\n    \n    // Remove DOM listeners\n    this._detachDOMListeners(info.element, elementId);\n    \n    this.focusableElements.delete(elementId);\n  }\n  \n  /**\n   * Request focus for an element\n   * @param {string} elementId - Element to focus\n   * @param {Object} options - Focus options\n   * @returns {boolean} Success\n   */\n  requestFocus(elementId, options = {}) {\n    const info = this.focusableElements.get(elementId);\n    \n    if (!info) {\n      console.warn('[FocusManager] Cannot focus unknown element:', elementId);\n      return false;\n    }\n    \n    if (!info.canRequestFocus) {\n      console.warn('[FocusManager] Element cannot receive focus:', elementId);\n      return false;\n    }\n    \n    // Check scope restrictions\n    if (this.activeScopeId && info.scopeId !== this.activeScopeId) {\n      console.warn('[FocusManager] Focus request blocked by active scope');\n      return false;\n    }\n    \n    // Blur previous focus\n    const previousFocus = this.focusedElement;\n    if (previousFocus && previousFocus !== elementId) {\n      this._blurElement(previousFocus);\n    }\n    \n    // Focus new element\n    try {\n      info.element.focus(options);\n      this.focusedElement = elementId;\n      this._notifyFocusChange(elementId, previousFocus);\n      \n      // Call widget's onFocusChange callback\n      if (info.onFocusChange) {\n        info.onFocusChange(true);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('[FocusManager] Focus failed:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Blur an element\n   * @param {string} elementId - Element to blur\n   */\n  unfocus(elementId) {\n    if (this.focusedElement !== elementId) return;\n    \n    this._blurElement(elementId);\n    this.focusedElement = null;\n    this._notifyFocusChange(null, elementId);\n  }\n  \n  /**\n   * Internal blur helper\n   * @private\n   */\n  _blurElement(elementId) {\n    const info = this.focusableElements.get(elementId);\n    if (!info) return;\n    \n    try {\n      info.element.blur();\n      \n      // Call widget's onFocusChange callback\n      if (info.onFocusChange) {\n        info.onFocusChange(false);\n      }\n    } catch (error) {\n      console.error('[FocusManager] Blur failed:', error);\n    }\n  }\n  \n  /**\n   * Move focus in a direction (Tab navigation)\n   * @param {string} direction - 'forward' or 'backward'\n   */\n  moveFocus(direction = 'forward') {\n    const focusable = this._getFocusableInScope();\n    \n    if (focusable.length === 0) {\n      console.warn('[FocusManager] No focusable elements available');\n      return;\n    }\n    \n    // Sort by DOM position for correct tab order\n    focusable.sort((a, b) => {\n      const aInfo = this.focusableElements.get(a);\n      const bInfo = this.focusableElements.get(b);\n      \n      // First by tabIndex\n      if (aInfo.tabIndex !== bInfo.tabIndex) {\n        return aInfo.tabIndex - bInfo.tabIndex;\n      }\n      \n      // Then by DOM position\n      const position = aInfo.element.compareDocumentPosition(bInfo.element);\n      if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n        return -1;\n      } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n        return 1;\n      }\n      return 0;\n    });\n    \n    // Find current index\n    const currentIndex = this.focusedElement \n      ? focusable.indexOf(this.focusedElement)\n      : -1;\n    \n    // Calculate next index\n    let nextIndex;\n    if (direction === 'forward') {\n      nextIndex = (currentIndex + 1) % focusable.length;\n    } else {\n      nextIndex = (currentIndex - 1 + focusable.length) % focusable.length;\n    }\n    \n    // Focus next element\n    const nextElementId = focusable[nextIndex];\n    this.requestFocus(nextElementId);\n  }\n  \n  /**\n   * Get focusable elements in current scope\n   * @private\n   */\n  _getFocusableInScope() {\n    const allFocusable = Array.from(this.focusableElements.entries())\n      .filter(([id, info]) => !info.skipTraversal)\n      .map(([id]) => id);\n    \n    // If no active scope, return all\n    if (!this.activeScopeId) {\n      return allFocusable;\n    }\n    \n    // Return only elements in active scope\n    const scopeElements = this.focusScopes.get(this.activeScopeId) || [];\n    return allFocusable.filter(id => scopeElements.includes(id));\n  }\n  \n  /**\n   * Create a focus scope (for modals, dialogs)\n   * @param {string} scopeId - Unique scope identifier\n   * @param {string[]} elementIds - Elements in this scope\n   */\n  createScope(scopeId, elementIds = []) {\n    this.focusScopes.set(scopeId, elementIds);\n  }\n  \n  /**\n   * Add element to scope\n   * @param {string} scopeId - Scope identifier\n   * @param {string} elementId - Element to add\n   */\n  addToScope(scopeId, elementId) {\n    if (!this.focusScopes.has(scopeId)) {\n      this.createScope(scopeId);\n    }\n    \n    const elements = this.focusScopes.get(scopeId);\n    if (!elements.includes(elementId)) {\n      elements.push(elementId);\n    }\n    \n    // Update element's scope\n    const info = this.focusableElements.get(elementId);\n    if (info) {\n      info.scopeId = scopeId;\n    }\n  }\n  \n  /**\n   * Activate a focus scope (restrict focus to this scope)\n   * @param {string} scopeId - Scope to activate\n   */\n  pushScope(scopeId) {\n    if (!this.focusScopes.has(scopeId)) {\n      console.warn('[FocusManager] Cannot activate unknown scope:', scopeId);\n      return;\n    }\n    \n    this.activeScopeId = scopeId;\n    \n    // If current focus is outside scope, blur it\n    const currentInfo = this.focusedElement \n      ? this.focusableElements.get(this.focusedElement)\n      : null;\n    \n    if (currentInfo && currentInfo.scopeId !== scopeId) {\n      this.unfocus(this.focusedElement);\n    }\n  }\n  \n  /**\n   * Deactivate current scope\n   */\n  popScope() {\n    this.activeScopeId = null;\n  }\n  \n  /**\n   * Remove a focus scope\n   * @param {string} scopeId - Scope to remove\n   */\n  removeScope(scopeId) {\n    // Clear scope ID from all elements\n    const elements = this.focusScopes.get(scopeId) || [];\n    elements.forEach(elementId => {\n      const info = this.focusableElements.get(elementId);\n      if (info && info.scopeId === scopeId) {\n        info.scopeId = null;\n      }\n    });\n    \n    this.focusScopes.delete(scopeId);\n    \n    // Clear active scope if it was this one\n    if (this.activeScopeId === scopeId) {\n      this.activeScopeId = null;\n    }\n  }\n  \n  /**\n   * Setup keyboard navigation\n   */\n  setupKeyboardNavigation() {\n    if (this.keyboardEnabled) return;\n    \n    this.keyboardHandler = (event) => {\n      // Tab key\n      if (event.key === 'Tab') {\n        event.preventDefault();\n        const direction = event.shiftKey ? 'backward' : 'forward';\n        this.moveFocus(direction);\n      }\n      \n      // Escape key - exit scope\n      if (event.key === 'Escape' && this.activeScopeId) {\n        this.popScope();\n      }\n    };\n    \n    document.addEventListener('keydown', this.keyboardHandler);\n    this.keyboardEnabled = true;\n  }\n  \n  /**\n   * Disable keyboard navigation\n   */\n  disableKeyboardNavigation() {\n    if (!this.keyboardEnabled) return;\n    \n    if (this.keyboardHandler) {\n      document.removeEventListener('keydown', this.keyboardHandler);\n      this.keyboardHandler = null;\n    }\n    \n    this.keyboardEnabled = false;\n  }\n  \n  /**\n   * Attach DOM focus/blur listeners\n   * @private\n   */\n  _attachDOMListeners(element, elementId) {\n    const focusHandler = () => {\n      if (this.focusedElement !== elementId) {\n        const previousFocus = this.focusedElement;\n        this.focusedElement = elementId;\n        this._notifyFocusChange(elementId, previousFocus);\n        \n        const info = this.focusableElements.get(elementId);\n        if (info && info.onFocusChange) {\n          info.onFocusChange(true);\n        }\n      }\n    };\n    \n    const blurHandler = () => {\n      if (this.focusedElement === elementId) {\n        this.focusedElement = null;\n        this._notifyFocusChange(null, elementId);\n        \n        const info = this.focusableElements.get(elementId);\n        if (info && info.onFocusChange) {\n          info.onFocusChange(false);\n        }\n      }\n    };\n    \n    element.addEventListener('focus', focusHandler);\n    element.addEventListener('blur', blurHandler);\n    \n    // Store handlers for cleanup\n    element._focusHandlers = { focusHandler, blurHandler };\n  }\n  \n  /**\n   * Detach DOM listeners\n   * @private\n   */\n  _detachDOMListeners(element, elementId) {\n    if (!element._focusHandlers) return;\n    \n    const { focusHandler, blurHandler } = element._focusHandlers;\n    element.removeEventListener('focus', focusHandler);\n    element.removeEventListener('blur', blurHandler);\n    \n    delete element._focusHandlers;\n  }\n  \n  /**\n   * Add focus change listener\n   * @param {Function} listener - Callback(newFocus, oldFocus)\n   */\n  addFocusChangeListener(listener) {\n    this.focusChangeListeners.add(listener);\n  }\n  \n  /**\n   * Remove focus change listener\n   * @param {Function} listener - Previously added listener\n   */\n  removeFocusChangeListener(listener) {\n    this.focusChangeListeners.delete(listener);\n  }\n  \n  /**\n   * Notify all listeners of focus change\n   * @private\n   */\n  _notifyFocusChange(newFocus, oldFocus) {\n    this.focusChangeListeners.forEach(listener => {\n      try {\n        listener(newFocus, oldFocus);\n      } catch (error) {\n        console.error('[FocusManager] Listener error:', error);\n      }\n    });\n  }\n  \n  /**\n   * Get current focus\n   * @returns {string|null} Currently focused element ID\n   */\n  get currentFocus() {\n    return this.focusedElement;\n  }\n  \n  /**\n   * Check if element has focus\n   * @param {string} elementId - Element to check\n   * @returns {boolean}\n   */\n  hasFocus(elementId) {\n    return this.focusedElement === elementId;\n  }\n  \n  /**\n   * Get all focusable elements\n   * @returns {string[]} Array of element IDs\n   */\n  getFocusableElements() {\n    return Array.from(this.focusableElements.keys());\n  }\n  \n  /**\n   * Get element info\n   * @param {string} elementId - Element ID\n   * @returns {Object|null} Element info\n   */\n  getElementInfo(elementId) {\n    return this.focusableElements.get(elementId) || null;\n  }\n  \n  /**\n   * Clear all focus\n   */\n  clearFocus() {\n    if (this.focusedElement) {\n      this._blurElement(this.focusedElement);\n      this.focusedElement = null;\n    }\n  }\n  \n  /**\n   * Get focus statistics\n   * @returns {Object} Statistics\n   */\n  getStats() {\n    return {\n      totalFocusable: this.focusableElements.size,\n      currentFocus: this.focusedElement,\n      activeScope: this.activeScopeId,\n      scopeCount: this.focusScopes.size,\n      keyboardEnabled: this.keyboardEnabled,\n      listeners: this.focusChangeListeners.size\n    };\n  }\n  \n  /**\n   * Dispose and cleanup\n   */\n  dispose() {\n    // Disable keyboard navigation\n    this.disableKeyboardNavigation();\n    \n    // Detach all DOM listeners\n    for (const [elementId, info] of this.focusableElements.entries()) {\n      this._detachDOMListeners(info.element, elementId);\n    }\n    \n    // Clear all data\n    this.focusableElements.clear();\n    this.focusScopes.clear();\n    this.focusChangeListeners.clear();\n    this.focusedElement = null;\n    this.activeScopeId = null;\n  }\n}\n\n\nexport {FocusManager};"],
  "mappings": "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",
  "names": ["FocusManager", "runtime", "elementId", "domElement", "options", "focusableInfo", "info", "scopeId", "elementIds", "index", "previousFocus", "error", "direction", "focusable", "a", "b", "aInfo", "bInfo", "position", "currentIndex", "nextIndex", "nextElementId", "allFocusable", "id", "scopeElements", "elements", "currentInfo", "event", "element", "focusHandler", "blurHandler", "listener", "newFocus", "oldFocus"]
}
