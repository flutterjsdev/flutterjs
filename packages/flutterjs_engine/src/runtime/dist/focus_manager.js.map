{
  "version": 3,
  "sources": ["../src/focus_manager.js"],
  "sourcesContent": ["/**\r\n * Focus Manager\r\n * \r\n * Manages keyboard focus and navigation across the widget tree.\r\n * Handles Tab navigation, autofocus, focus scopes, and programmatic focus control.\r\n * \r\n * Features:\r\n * - Focus registration and tracking\r\n * - Keyboard navigation (Tab/Shift+Tab)\r\n * - Focus scopes for modal dialogs\r\n * - Autofocus support\r\n * - Focus event callbacks\r\n * - Accessibility support\r\n */\r\n\r\nclass FocusManager {\r\n  constructor(runtime) {\r\n    this.runtime = runtime;\r\n    this.focusedElement = null;\r\n    this.focusableElements = new Map(); // elementId \u2192 FocusableInfo\r\n    this.focusScopes = new Map(); // scopeId \u2192 [elementIds]\r\n    this.activeScopeId = null;\r\n    \r\n    // Focus event listeners\r\n    this.focusChangeListeners = new Set();\r\n    \r\n    // Keyboard navigation\r\n    this.keyboardEnabled = false;\r\n    this.keyboardHandler = null;\r\n  }\r\n  \r\n  /**\r\n   * Register a focusable element\r\n   * @param {string} elementId - Unique element identifier\r\n   * @param {HTMLElement} domElement - Actual DOM element\r\n   * @param {Object} options - Focus configuration\r\n   */\r\n  registerFocusable(elementId, domElement, options = {}) {\r\n    if (!elementId || !domElement) {\r\n      console.warn('[FocusManager] Invalid registration:', { elementId, domElement });\r\n      return;\r\n    }\r\n    \r\n    const focusableInfo = {\r\n      elementId,\r\n      element: domElement,\r\n      canRequestFocus: options.canRequestFocus !== false,\r\n      skipTraversal: options.skipTraversal === true,\r\n      autofocus: options.autofocus === true,\r\n      onFocusChange: options.onFocusChange || null,\r\n      tabIndex: options.tabIndex ?? 0,\r\n      scopeId: options.scopeId || null\r\n    };\r\n    \r\n    this.focusableElements.set(elementId, focusableInfo);\r\n    \r\n    // Set tabIndex for keyboard navigation\r\n    if (!focusableInfo.skipTraversal) {\r\n      domElement.tabIndex = focusableInfo.tabIndex;\r\n    }\r\n    \r\n    // Attach DOM focus/blur listeners\r\n    this._attachDOMListeners(domElement, elementId);\r\n    \r\n    // Handle autofocus\r\n    if (focusableInfo.autofocus) {\r\n      // Defer to next tick to ensure element is mounted\r\n      requestAnimationFrame(() => {\r\n        if (this.focusableElements.has(elementId)) {\r\n          this.requestFocus(elementId);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Unregister a focusable element\r\n   * @param {string} elementId - Element to unregister\r\n   */\r\n  unregisterFocusable(elementId) {\r\n    const info = this.focusableElements.get(elementId);\r\n    if (!info) return;\r\n    \r\n    // Blur if currently focused\r\n    if (this.focusedElement === elementId) {\r\n      this.focusedElement = null;\r\n      this._notifyFocusChange(null, elementId);\r\n    }\r\n    \r\n    // Remove from scopes\r\n    for (const [scopeId, elementIds] of this.focusScopes.entries()) {\r\n      const index = elementIds.indexOf(elementId);\r\n      if (index !== -1) {\r\n        elementIds.splice(index, 1);\r\n      }\r\n    }\r\n    \r\n    // Remove DOM listeners\r\n    this._detachDOMListeners(info.element, elementId);\r\n    \r\n    this.focusableElements.delete(elementId);\r\n  }\r\n  \r\n  /**\r\n   * Request focus for an element\r\n   * @param {string} elementId - Element to focus\r\n   * @param {Object} options - Focus options\r\n   * @returns {boolean} Success\r\n   */\r\n  requestFocus(elementId, options = {}) {\r\n    const info = this.focusableElements.get(elementId);\r\n    \r\n    if (!info) {\r\n      console.warn('[FocusManager] Cannot focus unknown element:', elementId);\r\n      return false;\r\n    }\r\n    \r\n    if (!info.canRequestFocus) {\r\n      console.warn('[FocusManager] Element cannot receive focus:', elementId);\r\n      return false;\r\n    }\r\n    \r\n    // Check scope restrictions\r\n    if (this.activeScopeId && info.scopeId !== this.activeScopeId) {\r\n      console.warn('[FocusManager] Focus request blocked by active scope');\r\n      return false;\r\n    }\r\n    \r\n    // Blur previous focus\r\n    const previousFocus = this.focusedElement;\r\n    if (previousFocus && previousFocus !== elementId) {\r\n      this._blurElement(previousFocus);\r\n    }\r\n    \r\n    // Focus new element\r\n    try {\r\n      info.element.focus(options);\r\n      this.focusedElement = elementId;\r\n      this._notifyFocusChange(elementId, previousFocus);\r\n      \r\n      // Call widget's onFocusChange callback\r\n      if (info.onFocusChange) {\r\n        info.onFocusChange(true);\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('[FocusManager] Focus failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Blur an element\r\n   * @param {string} elementId - Element to blur\r\n   */\r\n  unfocus(elementId) {\r\n    if (this.focusedElement !== elementId) return;\r\n    \r\n    this._blurElement(elementId);\r\n    this.focusedElement = null;\r\n    this._notifyFocusChange(null, elementId);\r\n  }\r\n  \r\n  /**\r\n   * Internal blur helper\r\n   * @private\r\n   */\r\n  _blurElement(elementId) {\r\n    const info = this.focusableElements.get(elementId);\r\n    if (!info) return;\r\n    \r\n    try {\r\n      info.element.blur();\r\n      \r\n      // Call widget's onFocusChange callback\r\n      if (info.onFocusChange) {\r\n        info.onFocusChange(false);\r\n      }\r\n    } catch (error) {\r\n      console.error('[FocusManager] Blur failed:', error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Move focus in a direction (Tab navigation)\r\n   * @param {string} direction - 'forward' or 'backward'\r\n   */\r\n  moveFocus(direction = 'forward') {\r\n    const focusable = this._getFocusableInScope();\r\n    \r\n    if (focusable.length === 0) {\r\n      console.warn('[FocusManager] No focusable elements available');\r\n      return;\r\n    }\r\n    \r\n    // Sort by DOM position for correct tab order\r\n    focusable.sort((a, b) => {\r\n      const aInfo = this.focusableElements.get(a);\r\n      const bInfo = this.focusableElements.get(b);\r\n      \r\n      // First by tabIndex\r\n      if (aInfo.tabIndex !== bInfo.tabIndex) {\r\n        return aInfo.tabIndex - bInfo.tabIndex;\r\n      }\r\n      \r\n      // Then by DOM position\r\n      const position = aInfo.element.compareDocumentPosition(bInfo.element);\r\n      if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n        return -1;\r\n      } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n        return 1;\r\n      }\r\n      return 0;\r\n    });\r\n    \r\n    // Find current index\r\n    const currentIndex = this.focusedElement \r\n      ? focusable.indexOf(this.focusedElement)\r\n      : -1;\r\n    \r\n    // Calculate next index\r\n    let nextIndex;\r\n    if (direction === 'forward') {\r\n      nextIndex = (currentIndex + 1) % focusable.length;\r\n    } else {\r\n      nextIndex = (currentIndex - 1 + focusable.length) % focusable.length;\r\n    }\r\n    \r\n    // Focus next element\r\n    const nextElementId = focusable[nextIndex];\r\n    this.requestFocus(nextElementId);\r\n  }\r\n  \r\n  /**\r\n   * Get focusable elements in current scope\r\n   * @private\r\n   */\r\n  _getFocusableInScope() {\r\n    const allFocusable = Array.from(this.focusableElements.entries())\r\n      .filter(([id, info]) => !info.skipTraversal)\r\n      .map(([id]) => id);\r\n    \r\n    // If no active scope, return all\r\n    if (!this.activeScopeId) {\r\n      return allFocusable;\r\n    }\r\n    \r\n    // Return only elements in active scope\r\n    const scopeElements = this.focusScopes.get(this.activeScopeId) || [];\r\n    return allFocusable.filter(id => scopeElements.includes(id));\r\n  }\r\n  \r\n  /**\r\n   * Create a focus scope (for modals, dialogs)\r\n   * @param {string} scopeId - Unique scope identifier\r\n   * @param {string[]} elementIds - Elements in this scope\r\n   */\r\n  createScope(scopeId, elementIds = []) {\r\n    this.focusScopes.set(scopeId, elementIds);\r\n  }\r\n  \r\n  /**\r\n   * Add element to scope\r\n   * @param {string} scopeId - Scope identifier\r\n   * @param {string} elementId - Element to add\r\n   */\r\n  addToScope(scopeId, elementId) {\r\n    if (!this.focusScopes.has(scopeId)) {\r\n      this.createScope(scopeId);\r\n    }\r\n    \r\n    const elements = this.focusScopes.get(scopeId);\r\n    if (!elements.includes(elementId)) {\r\n      elements.push(elementId);\r\n    }\r\n    \r\n    // Update element's scope\r\n    const info = this.focusableElements.get(elementId);\r\n    if (info) {\r\n      info.scopeId = scopeId;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Activate a focus scope (restrict focus to this scope)\r\n   * @param {string} scopeId - Scope to activate\r\n   */\r\n  pushScope(scopeId) {\r\n    if (!this.focusScopes.has(scopeId)) {\r\n      console.warn('[FocusManager] Cannot activate unknown scope:', scopeId);\r\n      return;\r\n    }\r\n    \r\n    this.activeScopeId = scopeId;\r\n    \r\n    // If current focus is outside scope, blur it\r\n    const currentInfo = this.focusedElement \r\n      ? this.focusableElements.get(this.focusedElement)\r\n      : null;\r\n    \r\n    if (currentInfo && currentInfo.scopeId !== scopeId) {\r\n      this.unfocus(this.focusedElement);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Deactivate current scope\r\n   */\r\n  popScope() {\r\n    this.activeScopeId = null;\r\n  }\r\n  \r\n  /**\r\n   * Remove a focus scope\r\n   * @param {string} scopeId - Scope to remove\r\n   */\r\n  removeScope(scopeId) {\r\n    // Clear scope ID from all elements\r\n    const elements = this.focusScopes.get(scopeId) || [];\r\n    elements.forEach(elementId => {\r\n      const info = this.focusableElements.get(elementId);\r\n      if (info && info.scopeId === scopeId) {\r\n        info.scopeId = null;\r\n      }\r\n    });\r\n    \r\n    this.focusScopes.delete(scopeId);\r\n    \r\n    // Clear active scope if it was this one\r\n    if (this.activeScopeId === scopeId) {\r\n      this.activeScopeId = null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Setup keyboard navigation\r\n   */\r\n  setupKeyboardNavigation() {\r\n    if (this.keyboardEnabled) return;\r\n    \r\n    this.keyboardHandler = (event) => {\r\n      // Tab key\r\n      if (event.key === 'Tab') {\r\n        event.preventDefault();\r\n        const direction = event.shiftKey ? 'backward' : 'forward';\r\n        this.moveFocus(direction);\r\n      }\r\n      \r\n      // Escape key - exit scope\r\n      if (event.key === 'Escape' && this.activeScopeId) {\r\n        this.popScope();\r\n      }\r\n    };\r\n    \r\n    document.addEventListener('keydown', this.keyboardHandler);\r\n    this.keyboardEnabled = true;\r\n  }\r\n  \r\n  /**\r\n   * Disable keyboard navigation\r\n   */\r\n  disableKeyboardNavigation() {\r\n    if (!this.keyboardEnabled) return;\r\n    \r\n    if (this.keyboardHandler) {\r\n      document.removeEventListener('keydown', this.keyboardHandler);\r\n      this.keyboardHandler = null;\r\n    }\r\n    \r\n    this.keyboardEnabled = false;\r\n  }\r\n  \r\n  /**\r\n   * Attach DOM focus/blur listeners\r\n   * @private\r\n   */\r\n  _attachDOMListeners(element, elementId) {\r\n    const focusHandler = () => {\r\n      if (this.focusedElement !== elementId) {\r\n        const previousFocus = this.focusedElement;\r\n        this.focusedElement = elementId;\r\n        this._notifyFocusChange(elementId, previousFocus);\r\n        \r\n        const info = this.focusableElements.get(elementId);\r\n        if (info && info.onFocusChange) {\r\n          info.onFocusChange(true);\r\n        }\r\n      }\r\n    };\r\n    \r\n    const blurHandler = () => {\r\n      if (this.focusedElement === elementId) {\r\n        this.focusedElement = null;\r\n        this._notifyFocusChange(null, elementId);\r\n        \r\n        const info = this.focusableElements.get(elementId);\r\n        if (info && info.onFocusChange) {\r\n          info.onFocusChange(false);\r\n        }\r\n      }\r\n    };\r\n    \r\n    element.addEventListener('focus', focusHandler);\r\n    element.addEventListener('blur', blurHandler);\r\n    \r\n    // Store handlers for cleanup\r\n    element._focusHandlers = { focusHandler, blurHandler };\r\n  }\r\n  \r\n  /**\r\n   * Detach DOM listeners\r\n   * @private\r\n   */\r\n  _detachDOMListeners(element, elementId) {\r\n    if (!element._focusHandlers) return;\r\n    \r\n    const { focusHandler, blurHandler } = element._focusHandlers;\r\n    element.removeEventListener('focus', focusHandler);\r\n    element.removeEventListener('blur', blurHandler);\r\n    \r\n    delete element._focusHandlers;\r\n  }\r\n  \r\n  /**\r\n   * Add focus change listener\r\n   * @param {Function} listener - Callback(newFocus, oldFocus)\r\n   */\r\n  addFocusChangeListener(listener) {\r\n    this.focusChangeListeners.add(listener);\r\n  }\r\n  \r\n  /**\r\n   * Remove focus change listener\r\n   * @param {Function} listener - Previously added listener\r\n   */\r\n  removeFocusChangeListener(listener) {\r\n    this.focusChangeListeners.delete(listener);\r\n  }\r\n  \r\n  /**\r\n   * Notify all listeners of focus change\r\n   * @private\r\n   */\r\n  _notifyFocusChange(newFocus, oldFocus) {\r\n    this.focusChangeListeners.forEach(listener => {\r\n      try {\r\n        listener(newFocus, oldFocus);\r\n      } catch (error) {\r\n        console.error('[FocusManager] Listener error:', error);\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Get current focus\r\n   * @returns {string|null} Currently focused element ID\r\n   */\r\n  get currentFocus() {\r\n    return this.focusedElement;\r\n  }\r\n  \r\n  /**\r\n   * Check if element has focus\r\n   * @param {string} elementId - Element to check\r\n   * @returns {boolean}\r\n   */\r\n  hasFocus(elementId) {\r\n    return this.focusedElement === elementId;\r\n  }\r\n  \r\n  /**\r\n   * Get all focusable elements\r\n   * @returns {string[]} Array of element IDs\r\n   */\r\n  getFocusableElements() {\r\n    return Array.from(this.focusableElements.keys());\r\n  }\r\n  \r\n  /**\r\n   * Get element info\r\n   * @param {string} elementId - Element ID\r\n   * @returns {Object|null} Element info\r\n   */\r\n  getElementInfo(elementId) {\r\n    return this.focusableElements.get(elementId) || null;\r\n  }\r\n  \r\n  /**\r\n   * Clear all focus\r\n   */\r\n  clearFocus() {\r\n    if (this.focusedElement) {\r\n      this._blurElement(this.focusedElement);\r\n      this.focusedElement = null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get focus statistics\r\n   * @returns {Object} Statistics\r\n   */\r\n  getStats() {\r\n    return {\r\n      totalFocusable: this.focusableElements.size,\r\n      currentFocus: this.focusedElement,\r\n      activeScope: this.activeScopeId,\r\n      scopeCount: this.focusScopes.size,\r\n      keyboardEnabled: this.keyboardEnabled,\r\n      listeners: this.focusChangeListeners.size\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Dispose and cleanup\r\n   */\r\n  dispose() {\r\n    // Disable keyboard navigation\r\n    this.disableKeyboardNavigation();\r\n    \r\n    // Detach all DOM listeners\r\n    for (const [elementId, info] of this.focusableElements.entries()) {\r\n      this._detachDOMListeners(info.element, elementId);\r\n    }\r\n    \r\n    // Clear all data\r\n    this.focusableElements.clear();\r\n    this.focusScopes.clear();\r\n    this.focusChangeListeners.clear();\r\n    this.focusedElement = null;\r\n    this.activeScopeId = null;\r\n  }\r\n}\r\n\r\n\r\nexport {FocusManager};"],
  "mappings": "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",
  "names": ["FocusManager", "runtime", "elementId", "domElement", "options", "focusableInfo", "info", "scopeId", "elementIds", "index", "previousFocus", "error", "direction", "focusable", "a", "b", "aInfo", "bInfo", "position", "currentIndex", "nextIndex", "nextElementId", "allFocusable", "id", "scopeElements", "elements", "currentInfo", "event", "element", "focusHandler", "blurHandler", "listener", "newFocus", "oldFocus"]
}
