import{BuildContext as c}from"./build_context.js";import{VNodeDiffer as p}from"@flutterjs/vdom/vnode_differ";import{PatchApplier as _}from"@flutterjs/vdom/patch_applier";const y={hidden:"hidden",fine:"fine",debug:"debug",info:"info",warning:"warning",hint:"hint",summary:"summary",error:"error",off:"off"},g={none:"none",sparse:"sparse",offstage:"offstage",dense:"dense",transition:"transition",error:"error",whitespace:"whitespace",flat:"flat",singleLine:"singleLine",errorProperty:"errorProperty",shallow:"shallow",truncateChildren:"truncateChildren"};class E{toStringShort(){return`${this.constructor.name}${this.key?`(key: ${this.key})`:"(unkeyed)"}`}toDiagnosticsNode(e=null,t=g.sparse){return{name:e||this.constructor.name,value:this,style:t,toString:()=>this.toStringShort()}}debugFillProperties(e){this.key!==null&&this.key!==void 0&&e.push({name:"key",value:this.key})}debugInfo(){const e=[];return this.debugFillProperties(e),{type:this.constructor.name,key:this.key||null,properties:e,style:this.style||g.sparse,description:this.toStringShort()}}toString(){return this.toStringShort()}}function m(r){if(!r||typeof r!="object")return!1;const e=typeof r.tag=="string",t=Array.isArray(r.children)||r.children===null||r.children===void 0,n=r.props===null||r.props===void 0||typeof r.props=="object",o=typeof r.build!="function"&&typeof r.createState!="function";return e&&t&&n&&o}function f(r){return!r||typeof r!="object"?!1:typeof r.build=="function"||typeof r.createState=="function"||typeof r.render=="function"}class u extends E{constructor(e,t=null,n=null){if(super(),!e)throw new Error("Widget is required for Element creation");if(!n)throw new Error("RUNTIME IS UNDEFINED! Runtime is required for Element creation");this._widget=e,this._parent=t,this.runtime=n,this._children=[],this._childMap=new Map,this._vnode=null,this._domNode=null,this._mounted=!1,this._dirty=!1,this._building=!1,this._shouldPatch=!0,this._depth=t?(t._depth||0)+1:0,this.key=e.key,this._id=`el_${u._nextId++}`,console.log(`[Element] \u{1F195} Created ${this._id} for ${e?.constructor?.name}`),this._buildCount=0,this._lastBuildTime=0,this._lastBuildDuration=0,this._context=null}get widget(){return this._widget}set widget(e){this._widget=e}get parent(){return this._parent}set parent(e){this._parent=e}get children(){return this._children}get depth(){return this._depth}get id(){return this._id}get mounted(){return this._mounted}get dirty(){return this._dirty}get building(){return this._building}get vnode(){return this._vnode}set vnode(e){this._vnode=e}get domNode(){return this._domNode}set domNode(e){this._domNode=e}get context(){return this._context||(this._context=new c(this,this.runtime)),this._context}getElementId(){return this._id}getWidgetPath(){if(this._widgetPath)return this._widgetPath;const e=this.widget?.constructor?.name||"Unknown",t=this.parent?.getWidgetPath?this.parent.getWidgetPath():"";return this._widgetPath=t?`${t}/${e}`:e,this._widgetPath}getIdentificationStrategy(){return this.key?"key":"id"}performRebuild(){throw new Error(`${this.constructor.name}.performRebuild() must be implemented by subclass`)}mount(e=null){if(this._mounted){console.warn(`[Element] ${this._id} already mounted`);return}try{this._mounted=!0,e&&(this._parent=e,this._depth=(e._depth||0)+1),this._vnode=this.performRebuild(),this._children.forEach(t=>{t._mounted||t.mount(this)}),this.didMount(),this._initialMountComplete=!0}catch(t){throw this._mounted=!1,new Error(`Failed to mount ${this.constructor.name}: ${t.message}`)}}rebuild(){if(!this._mounted){console.warn(`[Element] Cannot rebuild unmounted element ${this._id}`);return}if(this._building){console.warn(`[Element] Recursive rebuild detected for ${this._id}`);return}try{this._building=!0,console.log(`\u{1F504} [Element.rebuild] START for ${this._id} (${this.widget?.constructor?.name})`),console.log("   _shouldPatch BEFORE performRebuild:",this._shouldPatch);const e=this._vnode;console.log("   oldVNode:",e?.tag,e?._element),this._vnode=this.performRebuild(),console.log("   newVNode:",this._vnode?.tag,this._vnode?._element),console.log("   _shouldPatch AFTER performRebuild:",this._shouldPatch),this._shouldPatch&&this._initialMountComplete?(console.log(`\u2705 [Element.rebuild] Calling applyChanges for ${this._id}`),this.applyChanges(e,this._vnode)):(this._initialMountComplete?console.log(e?`\u23ED\uFE0F [Element.rebuild] Skipping applyChanges for ${this._id} (_shouldPatch = false)`:`\u23ED\uFE0F [Element.rebuild] Skipping applyChanges for ${this._id} (initial mount, oldVNode is null)`):console.log(`\u23ED\uFE0F [Element.rebuild] Skipping applyChanges for ${this._id} (first rebuild after mount)`),this._vnode&&this._vnode._element&&(this._domNode=this._vnode._element)),this._dirty=!1}catch(e){throw console.error(`[Element] Rebuild failed for ${this._id}:`,e),e}finally{this._building=!1}}applyChanges(e,t){if(console.log(`[Element.applyChanges] START for ${this._id} (${this.widget?.constructor.name})`),console.log("  oldVNode:",{tag:e?.tag,hasElement:!!e?._element,element:e?._element?.tagName}),console.log("  newVNode:",{tag:t?.tag,hasElement:!!t?._element,element:t?._element?.tagName}),this.runtime.config&&this.runtime.config.debugMode&&console.log(`[Element] Applied changes to ${this._id}`),this._hasAppliedChanges&&e&&t&&!e?._element&&!t?._element&&this.runtime.renderer){const n=e.children||[],o=t.children||[];if(n.length!==o.length||JSON.stringify(n)!==JSON.stringify(o)){console.log("[Element] \u{1F504} Both VNodes have no DOM but children changed - forcing full re-render");try{let i=this._domNode;if(!i&&this._parent&&(i=this._parent._domNode),!i){const l=document.getElementById("root");l&&l.firstChild&&(i=l.firstChild)}if(i){console.log("[Element] \u{1F3A8} Found target element, rendering new VNode"),i.innerHTML="",this.runtime.renderer.render(t,i),t._element=i.firstChild,t._element&&(t._element._vnode=t,this._domNode=t._element),console.log("[Element] \u2705 Successfully re-rendered for VNode change");return}else console.warn("[Element] \u26A0\uFE0F Could not find target element for re-render")}catch(i){console.error("[Element] \u274C Failed to re-render:",i)}}else console.log("[Element] \u2139\uFE0F Both VNodes have no DOM but children unchanged - skipping re-render")}if(this._mounted&&e&&e._element&&!t._element&&this.runtime.renderer){console.log("[Element] \u{1F504} Widget type changed - rendering new VNode and replacing DOM");try{const n=e._element,o=n.parentNode;if(o){const s=document.createElement("div");this.runtime.renderer.render(t,s);const i=s.firstChild;if(i){o.replaceChild(i,n),t._element=i,i._vnode=t,this._domNode===n&&(this._domNode=i),console.log("[Element] \u2705 Successfully replaced DOM for widget type change");return}}}catch(n){console.error("[Element] \u274C Failed to replace DOM for widget type change:",n)}}else e&&e._element&&t._element&&console.log("[Element] \u2139\uFE0F Both VNodes have DOM elements - using normal patching");if(e&&e._element&&this.runtime.renderer){if(e._element.parentNode)try{const n=e._element,o=n.parentNode,s=Array.from(o.childNodes).indexOf(n);if(s!==-1){this.runtime.config&&this.runtime.config.debugMode&&console.log(`[Element] Diffing at index ${s}`);const i=p.diff(e,t,s);if(i.length>0){console.log(`[Element] Applying ${i.length} patches to ${this._id} (${this.widget?.constructor.name})`),i.forEach(a=>console.log(`   - Patch: ${a.type} at index ${a.index}, content:`,a.content));const l=_.apply(o,i);l.success?console.log("[Element] Patches applied successfully"):console.error("[Element] PatchApplier failed:",l.errors),t._element||(t._element=e._element),this._domNode===n&&(this._domNode=t._element)}else console.log(`[Element] No patches generated for ${this._id} (${this.widget?.constructor.name})`),t._element=e._element,t._element&&(t._element._vnode=t);return}}catch(n){console.warn("[Element] Diffing failed, falling back to replace",n)}this.runtime.config&&this.runtime.config.debugMode&&console.log(`[Element] Fallback: Replacing DOM for ${this._id}`);try{const n=this.runtime.renderer.replaceElement(e._element,t);this._domNode===e._element&&(this._domNode=n)}catch(n){console.error(`[Element] Failed to patch DOM for ${this._id}:`,n)}}this._hasAppliedChanges=!0}markNeedsBuild(){if(!this._dirty){if(!this._mounted){console.warn(`[Element] Cannot mark unmounted element ${this._id} dirty`);return}this._dirty=!0,console.log(`\u{1F50D} [Element.markNeedsBuild] Called for ${this._id} (${this.widget?.constructor?.name})`),console.trace("Call stack:"),this.runtime&&this.runtime.markNeedsBuild&&this.runtime.markNeedsBuild(this)}}unmount(){if(this._mounted)try{this.willUnmount(),this._children.forEach(e=>{e._mounted&&e.unmount()}),this._children=[],this._childMap.clear(),this._vnode=null,this._domNode=null,this._mounted=!1,this._dirty=!1,this.didUnmount()}catch(e){console.error(`[Element] Unmount failed for ${this._id}:`,e)}}updateWidget(e){if(!e)throw new Error("New widget is required for update");const t=this._widget;this.widget=e,this.shouldRebuild(t,e)&&this.markNeedsBuild(),this.didUpdateWidget(t,e)}shouldRebuild(e,t){return e===t?!1:e.constructor!==t.constructor?!0:!this.areWidgetsEqual(e,t)}areWidgetsEqual(e,t){if(e.constructor!==t.constructor)return!1;const n=Object.keys(e),o=Object.keys(t);return n.length!==o.length?!1:n.every(s=>{const i=e[s],l=t[s];if(typeof i=="function"&&typeof l=="function")return!0;if(typeof i=="object"&&typeof l=="object")try{return JSON.stringify(i)===JSON.stringify(l)}catch{return!1}return i===l})}addChild(e){if(!e)throw new Error("Child element is required");this._children.push(e),e.key&&this._childMap.set(e.key,e),e.parent=this}removeChild(e){const t=this._children.indexOf(e);t!==-1&&this._children.splice(t,1),e.key&&this._childMap.delete(e.key),e.parent=null}findChildByKey(e){return this._childMap.get(e)}findAncestorOfType(e){let t=this._parent;for(;t;){if(t instanceof e)return t;t=t._parent}return null}visitAncestors(e){let t=this._parent;for(;t&&e(t)!==!1;)t=t._parent}didMount(){}didUpdateWidget(e,t){}willUnmount(){}didUnmount(){}reassemble(){}activate(){}deactivate(){}didChangeDependencies(){}getStats(){return{id:this._id,type:this.constructor.name,mounted:this._mounted,dirty:this._dirty,depth:this._depth,childCount:this._children.length,buildCount:this._buildCount,lastBuildDuration:this._lastBuildDuration,hasKey:!!this.key}}static generateId(){return`el_${++u._counter}`}static resetCounter(){u._counter=0}}u._counter=0;class d extends u{constructor(e,t,n){super(e,t,n)}build(){console.log("\u{1F4E6} StatelessElement.build() START",{widgetType:this.widget?.constructor.name,widgetInstance:this.widget});const e=this.buildContext();try{console.log("\u{1F528} Calling widget.build(context)...");const t=this.widget.build(e);if(console.log("\u2713 widget.build() returned:",{resultType:typeof t,resultConstructor:t?.constructor?.name,hasTag:t?.tag!==void 0,isString:typeof t=="string",isNull:t===null}),!t)throw console.warn("\u26A0\uFE0F Result is null/undefined"),new Error("StatelessWidget.build() returned null");if(m(t))return console.log("\u2705 Result is a REAL VNode, returning it directly"),this._shouldPatch=!0,t;if(typeof t=="string"||typeof t=="number"||typeof t=="boolean")return console.log("\u2705 Result is a primitive:",t),this._shouldPatch=!0,t;if(f(t)){console.log("\u{1F504} Result is a Widget, need to build recursively:",t.constructor.name);let n=this._children[0];if(n&&n.widget.constructor===t.constructor&&n.widget.key===t.key){console.log("\u267B\uFE0F Reusing existing child element for:",t.constructor.name);const s=n.widget;return n.widget=t,n.shouldRebuild(s,t)?(console.log("\u{1F504} Widget changed, rebuilding child element"),n.rebuild()):console.log("\u2705 Widget unchanged, reusing existing vnode"),n.vnode}n&&(console.log("\u{1F5D1}\uFE0F Unmounting old child element:",n.constructor.name),n.unmount(),this._children=[]),this._shouldPatch=!0,n=this._createElementForWidget(t),console.log("\u2705 Created child element:",n.constructor.name),this._children=[n],n.mount(this);const o=n.vnode;if(!o)throw new Error("Child element.build() returned null");return console.log("\u2705 Built new child widget, applyChanges will update DOM"),o}throw console.warn("\u26A0\uFE0F Unknown result type from build():",t),console.warn("   Constructor:",t?.constructor?.name),console.warn("   Type:",typeof t),console.warn("   Has .tag:",t?.tag),console.warn("   Has .build:",typeof t?.build),new Error(`Invalid build() return type from ${this.widget.constructor.name}. Expected: Widget, VNode, string, number, or null. Got: ${t?.constructor?.name} with tag="${t?.tag}"`)}catch(t){throw console.error("\u274C Build error:",t.message),console.error("   Widget:",this.widget?.constructor.name),new Error(`StatelessWidget build failed: ${t.message}`)}}_createElementForWidget(e){if(e&&typeof e.createElement=="function")return console.log("  Using widget.createElement() for:",e.constructor.name),e.createElement(this,this.runtime);if(typeof e.createState=="function")return console.log("  Creating StatefulElement for:",e.constructor.name),new h(e,this,this.runtime);if(e.updateShouldNotify&&typeof e.updateShouldNotify=="function")throw console.error("  \u26A0\uFE0F InheritedWidget without createElement():",e.constructor.name),new Error(`InheritedWidget "${e.constructor.name}" must define createElement() method. Extend InheritedWidget class properly.`);return console.log("  Creating StatelessElement for:",e.constructor.name),new d(e,this,this.runtime)}buildContext(){return new c(this,this.runtime)}performRebuild(){return this.build()}}class h extends u{constructor(e,t,n){if(super(e,t,n),!e.createState||typeof e.createState!="function")throw new Error("StatefulWidget must implement createState()");if(this.state=e.createState(),!this.state)throw new Error("createState() returned null or undefined");this.state._element=this,this.state._widget=e,this.state._mounted=!1}build(){console.log("\u{1F4E6} StatefulElement.build() START",{widgetType:this.widget?.constructor.name,stateType:this.state?.constructor.name});const e=this.buildContext();try{if(!this.state.build||typeof this.state.build!="function")throw new Error("State must implement build() method");console.log("\u{1F528} Calling state.build(context)...");const t=this.state.build(e);if(console.log("\u2713 state.build() returned:",{resultType:typeof t,resultConstructor:t?.constructor?.name,isVNode:t?.tag!==void 0}),!t)throw new Error("State.build() returned null");if(m(t))return console.log("\u2705 Result is a REAL VNode, returning"),this._shouldPatch=!0,t;if(typeof t=="string"||typeof t=="number"||typeof t=="boolean")return console.log("\u2705 Result is a primitive"),this._shouldPatch=!0,t;let n=this._children[0];if(f(t)){if(console.log("\u{1F504} State.build() returned a Widget, building recursively:",t.constructor.name),n&&n.widget.constructor===t.constructor&&n.widget.key===t.key){console.log("\u267B\uFE0F Reusing existing child element for:",t.constructor.name);const s=n.widget;return n.widget=t,n.shouldRebuild(s,t)?(console.log("\u{1F504} Widget changed, rebuilding child element"),n.rebuild()):console.log("\u2705 Widget unchanged, reusing existing vnode"),this._shouldPatch=!1,n.vnode}n&&(console.log("\u{1F5D1}\uFE0F Unmounting old child element:",n.constructor.name),n.unmount(),this._children=[]),this._shouldPatch=!0,n=this._createElementForWidget(t),this._children=[n],n.mount(this);const o=n.vnode;if(!o)throw new Error("Child element.build() returned null");return console.log("\u2705 Built new child widget, applyChanges will update DOM"),o}return this._shouldPatch=!1,n?n.vnode:t;throw new Error(`Invalid build() return type from ${this.widget.constructor.name} state. Expected: Widget, VNode, string, number, or null.`)}catch(t){throw new Error(`StatefulWidget build failed: ${t.message}`)}}_createElementForWidget(e){return e&&typeof e.createElement=="function"?e.createElement(this,this.runtime):typeof e.createState=="function"?new h(e,this,this.runtime):e.updateShouldNotify&&typeof e.updateShouldNotify=="function"?new InheritedElement(e,this,this.runtime):new d(e,this,this.runtime)}mount(){if(this._mounted){console.warn(`[StatefulElement] ${this._id} already mounted, skipping duplicate mount`);return}if(console.log("\u{1F680} StatefulElement.mount() called"),console.log("   Widget:",this.widget?.constructor?.name),console.log("   State:",this.state?.constructor?.name),console.log("   State has _mount:",typeof this.state._mount=="function"),this.state._mount&&typeof this.state._mount=="function")console.log("\u2705 Calling state._mount(this)..."),this.state._mount(this),console.log("\u2705 state._mount() complete");else if(console.log("\u26A0\uFE0F State does not have _mount(), using fallback initialization"),this.state._element=this,this.state._widget=this.widget,this.state._mounted=!0,this.state.initState&&typeof this.state.initState=="function")try{console.log("\u{1F3AC} Calling initState()..."),this.state.initState()}catch(e){console.error("[StatefulElement] initState failed:",e)}console.log("\u{1F50D} State after mount:",{hasMounted:this.state._mounted,hasElement:!!this.state._element,hasWidget:!!this.state._widget,widgetType:this.state._widget?.constructor?.name,widgetTitle:this.state._widget?.title}),super.mount(),console.log("\u2705 StatefulElement.mount() complete")}buildContext(){return new c(this,this.runtime,this.state)}updateWidget(e){console.log("\u{1F504} StatefulElement.updateWidget() called");const t=this._widget;if(super.updateWidget(e),this.state._updateWidget&&typeof this.state._updateWidget=="function"?(console.log("\u2705 Calling state._updateWidget()"),this.state._updateWidget(e)):(console.log("\u26A0\uFE0F State does not have _updateWidget(), updating directly"),this.state._widget=e),this.state.didUpdateWidget&&typeof this.state.didUpdateWidget=="function")try{this.state.didUpdateWidget(t)}catch(n){console.error("[StatefulElement] didUpdateWidget failed:",n)}}unmount(){console.log("\u{1F6D1} StatefulElement.unmount() called"),this.state._unmount&&typeof this.state._unmount=="function"&&this.state._unmount(),this.state._dispose&&typeof this.state._dispose=="function"&&this.state._dispose(),super.unmount()}performRebuild(){return this.build()}}class b extends u{constructor(e,t,n){super(e,t,n),this.componentState={}}build(){const e=this.widget.render||this.widget.build;if(!e||typeof e!="function")throw new Error("ComponentElement widget must have render() or build() method");const t=this.buildContext();try{const n=e.call(this.widget,t);if(n&&typeof n=="object"&&n.tag||typeof n=="string"||typeof n=="number")return n;if(n&&typeof n=="object"&&(typeof n.build=="function"||typeof n.createState=="function")){const s=this._createElementForWidget(n);return s._parent=this,s._depth=this._depth+1,s._mounted=!0,s.build()}return n}catch(n){throw new Error(`Component build failed: ${n.message}`)}}_createElementForWidget(e){return e&&typeof e.createElement=="function"?e.createElement(this,this.runtime):typeof e.createState=="function"?new h(e,this,this.runtime):new d(e,this,this.runtime)}buildContext(){return{element:this,runtime:this.runtime,widget:this.widget,state:this.componentState,setState:e=>{Object.assign(this.componentState,e),this.markNeedsBuild()}}}performRebuild(){return this.build()}}u._nextId=0;export{b as ComponentElement,y as DiagnosticLevel,E as Diagnosticable,u as Element,h as StatefulElement,d as StatelessElement,m as isRealVNode,f as isWidget};
//# sourceMappingURL=element.js.map
