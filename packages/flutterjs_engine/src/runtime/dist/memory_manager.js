class a{constructor(e={}){this.config={enableLeakDetection:e.enableLeakDetection!==!1,leakDetectionInterval:e.leakDetectionInterval||3e4,maxRetainedObjects:e.maxRetainedObjects||1e4,warnThreshold:e.warnThreshold||5e3,enableProfiling:e.enableProfiling||!1,debugMode:e.debugMode||!1},this.elementRegistry=new WeakMap,this.vnodeRegistry=new WeakMap,this.listenerRegistry=new WeakMap,this.stateRegistry=new WeakMap,this.disposableRegistry=new Map,this.elementRefs=new Map,this.vnodeRefs=new Map,this.listenerRefs=new Map,this.stats={elementsCreated:0,elementsDisposed:0,vnodeCreated:0,vnodeDisposed:0,listenersAttached:0,listenersRemoved:0,cleanupCallsTotal:0,memoryLeaksDetected:0,peakElementCount:0,peakVNodeCount:0},this.disposalQueue=new Set,this.cleanupScheduled=!1,this.leakDetectionTimer=null,this.config.enableLeakDetection&&this.startLeakDetection()}register(e){if(!e)throw new Error("Element is required for registration");const t={id:e.id,type:e.constructor.name,depth:e.depth,createdAt:Date.now(),mounted:e.mounted,hasChildren:e.children.length>0,hasState:!!e.state,parentId:e.parent?e.parent.id:null};this.elementRegistry.set(e,t),this.config.enableLeakDetection&&this.elementRefs.set(e.id,{element:e,registeredAt:Date.now(),type:e.constructor.name}),this.stats.elementsCreated++,this.elementRefs.size>this.stats.peakElementCount&&(this.stats.peakElementCount=this.elementRefs.size),this.elementRefs.size>this.config.warnThreshold&&this.logWarning(`Element count (${this.elementRefs.size}) exceeds threshold (${this.config.warnThreshold})`),this.config.debugMode&&this.logDebug(`Registered element ${e.id} (${e.constructor.name})`)}unregister(e){e&&(this.disposalQueue.add(e),this.scheduleCleanup())}scheduleCleanup(){this.cleanupScheduled||(this.cleanupScheduled=!0,Promise.resolve().then(()=>{this.performBatchCleanup()}))}performBatchCleanup(){this.cleanupScheduled=!1;const e=Array.from(this.disposalQueue);this.disposalQueue.clear(),e.forEach(t=>{this.cleanupElement(t)}),this.config.debugMode&&this.logDebug(`Batch cleanup: ${e.length} elements`)}cleanupElement(e){const t=e.id;try{if(this.removeAllListeners(e),e.vnode&&this.unregisterVNode(e.vnode),e.state&&this.stateRegistry.delete(e.state),this.disposableRegistry.has(t)){const i=this.disposableRegistry.get(t);try{i()}catch(s){this.logError(`Cleanup function failed for ${t}:`,s)}this.disposableRegistry.delete(t)}e.vnode=null,e.domNode=null,e.children=[],this.elementRegistry.delete(e),this.listenerRegistry.delete(e),this.elementRefs.delete(t),this.stats.elementsDisposed++,this.stats.cleanupCallsTotal++,this.config.debugMode&&this.logDebug(`Cleaned up element ${t}`)}catch(i){this.logError(`Cleanup failed for element ${t}:`,i)}}registerVNode(e,t){if(!(!e||!t)){if(this.vnodeRegistry.set(e,t),this.config.enableLeakDetection){const i=this.generateVNodeId(e);this.vnodeRefs.set(i,{vnode:e,elementId:t.id,createdAt:Date.now()})}this.stats.vnodeCreated++,this.vnodeRefs.size>this.stats.peakVNodeCount&&(this.stats.peakVNodeCount=this.vnodeRefs.size)}}unregisterVNode(e){if(!e)return;this.vnodeRegistry.delete(e);const t=this.generateVNodeId(e);this.vnodeRefs.delete(t),this.stats.vnodeDisposed++}generateVNodeId(e){return e._memoryId||(e._memoryId=`vnode_${++a._vnodeIdCounter}`),e._memoryId}trackListener(e,t,i,s,r={}){if(!e||!t||!i||!s)throw new Error("All listener parameters are required");this.listenerRegistry.has(e)||this.listenerRegistry.set(e,[]);const n=this.listenerRegistry.get(e),o={target:t,event:i,handler:s,options:r,attachedAt:Date.now()};if(n.push(o),this.config.enableLeakDetection){const l=`${e.id}_${i}_${n.length}`;this.listenerRefs.set(l,{elementId:e.id,event:i,attachedAt:Date.now()})}this.stats.listenersAttached++,this.config.debugMode&&this.logDebug(`Tracked listener: ${e.id} \u2192 ${i}`)}removeAllListeners(e){if(!e)return;const t=this.listenerRegistry.get(e);!t||t.length===0||(t.forEach(({target:i,event:s,handler:r,options:n})=>{try{i&&i.removeEventListener&&i.removeEventListener(s,r,n),this.stats.listenersRemoved++}catch(o){this.logError(`Failed to remove listener ${s}:`,o)}}),this.listenerRegistry.delete(e),this.config.enableLeakDetection&&t.forEach((i,s)=>{const r=`${e.id}_${t[s].event}_${s+1}`;this.listenerRefs.delete(r)}),this.config.debugMode&&this.logDebug(`Removed ${t.length} listeners from ${e.id}`))}registerDisposable(e,t){if(!e||typeof t!="function")throw new Error("Valid ID and cleanup function required");this.disposableRegistry.set(e,t)}trackState(e,t){!e||!t||this.stateRegistry.set(e,t)}getElementById(e){const t=this.elementRefs.get(e);return t?t.element:null}getElementMetadata(e){return this.elementRegistry.get(e)||null}getElementForVNode(e){return this.vnodeRegistry.get(e)||null}getListenersForElement(e){return this.listenerRegistry.get(e)||[]}startLeakDetection(){this.leakDetectionTimer||(this.leakDetectionTimer=setInterval(()=>{this.detectLeaks()},this.config.leakDetectionInterval),this.config.debugMode&&this.logDebug("Leak detection started"))}stopLeakDetection(){this.leakDetectionTimer&&(clearInterval(this.leakDetectionTimer),this.leakDetectionTimer=null,this.config.debugMode&&this.logDebug("Leak detection stopped"))}detectLeaks(){const e=Date.now(),t=6e4,i=[];return this.elementRefs.forEach((s,r)=>{const n=s.element,o=e-s.registeredAt;!n.mounted&&o>t&&i.push({type:"element",id:r,elementType:s.type,age:o,mounted:n.mounted})}),this.vnodeRefs.forEach((s,r)=>{const n=e-s.createdAt;n>t*2&&i.push({type:"vnode",id:r,elementId:s.elementId,age:n})}),this.listenerRefs.forEach((s,r)=>{const n=e-s.attachedAt;n>t&&i.push({type:"listener",id:r,elementId:s.elementId,event:s.event,age:n})}),i.length>0&&(this.stats.memoryLeaksDetected+=i.length,this.logWarning(`Potential memory leaks detected: ${i.length}`),this.config.debugMode&&i.forEach(s=>{this.logDebug(`Leak: ${s.type} ${s.id} (age: ${Math.round(s.age/1e3)}s)`)})),i}forceCleanupUnmounted(){const e=[];return this.elementRefs.forEach((t,i)=>{t.element.mounted||(this.cleanupElement(t.element),e.push(i))}),this.config.debugMode&&this.logDebug(`Force cleanup: ${e.length} elements`),e.length}getStats(){return{...this.stats,currentElements:this.elementRefs.size,currentVNodes:this.vnodeRefs.size,currentListeners:this.listenerRefs.size,disposablesRegistered:this.disposableRegistry.size,elementsInQueue:this.disposalQueue.size,leakDetectionEnabled:this.config.enableLeakDetection}}getDetailedReport(){const e=[];return this.elementRefs.forEach((t,i)=>{const s=t.element;e.push({id:i,type:t.type,mounted:s.mounted,depth:s.depth,childCount:s.children.length,hasState:!!s.state,age:Date.now()-t.registeredAt})}),{stats:this.getStats(),elements:e,config:this.config,timestamp:Date.now()}}resetStats(){this.stats={elementsCreated:0,elementsDisposed:0,vnodeCreated:0,vnodeDisposed:0,listenersAttached:0,listenersRemoved:0,cleanupCallsTotal:0,memoryLeaksDetected:0,peakElementCount:0,peakVNodeCount:0}}clear(){this.elementRefs.forEach(e=>{this.cleanupElement(e.element)}),this.elementRefs.clear(),this.vnodeRefs.clear(),this.listenerRefs.clear(),this.disposableRegistry.clear(),this.disposalQueue.clear(),this.config.debugMode&&this.logDebug("Memory manager cleared")}dispose(){this.stopLeakDetection(),this.clear(),this.config.debugMode&&this.logDebug("Memory manager disposed")}logDebug(e){this.config.debugMode&&console.log(`[MemoryManager] ${e}`)}logWarning(e){console.warn(`[MemoryManager] \u26A0\uFE0F  ${e}`)}logError(e,t){console.error(`[MemoryManager] \u274C ${e}`,t)}}a._vnodeIdCounter=0;class h{constructor(e){this.memoryManager=e,this.snapshots=[],this.maxSnapshots=50}takeSnapshot(){const e=this.memoryManager.getStats(),t={timestamp:Date.now(),stats:{...e},heapUsage:this.getHeapUsage()};return this.snapshots.push(t),this.snapshots.length>this.maxSnapshots&&this.snapshots.shift(),t}getHeapUsage(){return typeof performance<"u"&&performance.memory?{usedJSHeapSize:performance.memory.usedJSHeapSize,totalJSHeapSize:performance.memory.totalJSHeapSize,jsHeapSizeLimit:performance.memory.jsHeapSizeLimit}:null}compareSnapshots(e,t){const i={};return Object.keys(e.stats).forEach(s=>{i[s]=t.stats[s]-e.stats[s]}),i}getTrend(){if(this.snapshots.length<2)return null;const e=this.snapshots[0],t=this.snapshots[this.snapshots.length-1];return this.compareSnapshots(e,t)}clear(){this.snapshots=[]}}export{a as MemoryManager,h as MemoryProfiler};
//# sourceMappingURL=memory_manager.js.map
