{
  "version": 3,
  "sources": ["../src/state_tracker.js"],
  "sourcesContent": ["/**\n * FlutterJS State Tracker\n * \n * Tracks dependencies between state properties and UI elements.\n * Enables fine-grained reactivity by only rebuilding elements\n * that depend on changed state properties.\n * \n * Key Features:\n * - Track which elements depend on which state properties\n * - Automatic dependency recording during build\n * - Selective rebuilds (only affected elements)\n * - Memory-efficient weak references\n * - Performance monitoring\n * \n * Usage:\n * 1. Start tracking before build\n * 2. Record dependencies during property access\n * 3. Stop tracking after build\n * 4. Rebuild only dependents when property changes\n */\n\n/**\n * StateTracker Class\n * \n * Manages dependency relationships between state and elements\n */\nclass StateTracker {\n  constructor(config = {}) {\n    // Configuration\n    this.config = {\n      enableTracking: config.enableTracking !== false,\n      enableWeakRefs: config.enableWeakRefs !== false,\n      maxDependenciesPerProperty: config.maxDependenciesPerProperty || 1000,\n      enableDebugLogging: config.enableDebugLogging || false,\n      warnOnThreshold: config.warnOnThreshold !== false,\n      dependencyThreshold: config.dependencyThreshold || 500\n    };\n    \n    // Core tracking\n    this.dependencies = new Map();          // \"stateId.property\" \u2192 Set<element>\n    this.elementDependencies = new Map();   // elementId \u2192 Set<\"stateId.property\">\n    \n    // Weak references for automatic cleanup\n    this.weakElementRefs = new WeakMap();   // element \u2192 metadata\n    \n    // Current tracking state\n    this.tracking = false;\n    this.currentElement = null;\n    this.trackingStack = [];                // Support nested tracking\n    \n    // Performance tracking\n    this.stats = {\n      dependenciesTracked: 0,\n      dependenciesCleared: 0,\n      rebuildsTriggered: 0,\n      selectiveRebuilds: 0,\n      fullRebuilds: 0,\n      trackingSessionsStarted: 0,\n      trackingSessionsEnded: 0,\n      peakDependencies: 0\n    };\n    \n    // Debug tracking\n    this.debugLog = [];\n    this.maxDebugLogSize = 1000;\n  }\n  \n  /**\n   * Start tracking dependencies for build\n   * @param {Element} element - Element being built\n   */\n  startTracking(element) {\n    if (!this.config.enableTracking) {\n      return;\n    }\n    \n    if (!element) {\n      throw new Error('Element is required for tracking');\n    }\n    \n    // Support nested tracking (push to stack)\n    if (this.tracking && this.currentElement) {\n      this.trackingStack.push({\n        element: this.currentElement,\n        tracking: this.tracking\n      });\n    }\n    \n    this.tracking = true;\n    this.currentElement = element;\n    \n    this.stats.trackingSessionsStarted++;\n    \n    this.log(`Started tracking for element ${element.id}`);\n  }\n  \n  /**\n   * Stop tracking dependencies\n   */\n  stopTracking() {\n    if (!this.config.enableTracking) {\n      return;\n    }\n    \n    if (this.currentElement) {\n      this.log(`Stopped tracking for element ${this.currentElement.id}`);\n    }\n    \n    // Restore previous tracking state from stack\n    if (this.trackingStack.length > 0) {\n      const previous = this.trackingStack.pop();\n      this.currentElement = previous.element;\n      this.tracking = previous.tracking;\n    } else {\n      this.tracking = false;\n      this.currentElement = null;\n    }\n    \n    this.stats.trackingSessionsEnded++;\n  }\n  \n  /**\n   * Record dependency: element depends on state property\n   * @param {State} state - State object\n   * @param {string} property - Property name\n   */\n  recordDependency(state, property) {\n    if (!this.config.enableTracking || !this.tracking || !this.currentElement) {\n      return;\n    }\n    \n    if (!state || !property) {\n      if (this.config.enableDebugLogging) {\n        console.warn('[StateTracker] Invalid dependency recording attempt');\n      }\n      return;\n    }\n    \n    // Generate dependency key\n    const stateId = this.getStateId(state);\n    const dependencyKey = `${stateId}.${property}`;\n    \n    // Add to main dependencies map\n    if (!this.dependencies.has(dependencyKey)) {\n      this.dependencies.set(dependencyKey, new Set());\n    }\n    \n    const dependents = this.dependencies.get(dependencyKey);\n    \n    // Check threshold\n    if (dependents.size >= this.config.maxDependenciesPerProperty) {\n      console.warn(\n        `[StateTracker] Max dependencies reached for ${dependencyKey} ` +\n        `(${dependents.size}/${this.config.maxDependenciesPerProperty})`\n      );\n      return;\n    }\n    \n    dependents.add(this.currentElement);\n    \n    // Track reverse dependency (element \u2192 dependencies)\n    const elementId = this.currentElement.id;\n    if (!this.elementDependencies.has(elementId)) {\n      this.elementDependencies.set(elementId, new Set());\n    }\n    this.elementDependencies.get(elementId).add(dependencyKey);\n    \n    // Store weak reference for cleanup\n    if (this.config.enableWeakRefs) {\n      this.weakElementRefs.set(this.currentElement, {\n        id: elementId,\n        stateId: stateId,\n        property: property,\n        trackedAt: Date.now()\n      });\n    }\n    \n    this.stats.dependenciesTracked++;\n    \n    // Track peak\n    const totalDeps = this.getTotalDependencies();\n    if (totalDeps > this.stats.peakDependencies) {\n      this.stats.peakDependencies = totalDeps;\n    }\n    \n    // Warn on threshold\n    if (this.config.warnOnThreshold && \n        totalDeps > this.config.dependencyThreshold) {\n      console.warn(\n        `[StateTracker] Dependency count (${totalDeps}) exceeds threshold ` +\n        `(${this.config.dependencyThreshold})`\n      );\n    }\n    \n    this.log(\n      `Recorded dependency: ${this.currentElement.id} \u2192 ${dependencyKey}`\n    );\n  }\n  \n  /**\n   * Get elements that depend on state property\n   * @param {State} state - State object\n   * @param {string} property - Property name\n   * @returns {Set<Element>}\n   */\n  getDependents(state, property) {\n    if (!state || !property) {\n      return new Set();\n    }\n    \n    const stateId = this.getStateId(state);\n    const dependencyKey = `${stateId}.${property}`;\n    \n    const dependents = this.dependencies.get(dependencyKey);\n    \n    if (!dependents) {\n      return new Set();\n    }\n    \n    // Filter out unmounted elements\n    const validDependents = new Set();\n    \n    dependents.forEach(element => {\n      if (element && element.mounted) {\n        validDependents.add(element);\n      }\n    });\n    \n    return validDependents;\n  }\n  \n  /**\n   * Get all dependencies for an element\n   * @param {Element} element - Element\n   * @returns {Set<string>} Set of dependency keys\n   */\n  getElementDependencies(element) {\n    if (!element) {\n      return new Set();\n    }\n    \n    return this.elementDependencies.get(element.id) || new Set();\n  }\n  \n  /**\n   * Notify dependents of property change\n   * @param {State} state - State object\n   * @param {string} property - Property name\n   * @returns {number} Number of elements rebuilt\n   */\n  notifyPropertyChange(state, property) {\n    const dependents = this.getDependents(state, property);\n    \n    if (dependents.size === 0) {\n      return 0;\n    }\n    \n    dependents.forEach(element => {\n      if (element.mounted && !element.dirty) {\n        element.markNeedsBuild();\n        this.stats.selectiveRebuilds++;\n      }\n    });\n    \n    this.stats.rebuildsTriggered++;\n    \n    this.log(\n      `Notified ${dependents.size} dependents of ${this.getStateId(state)}.${property} change`\n    );\n    \n    return dependents.size;\n  }\n  \n  /**\n   * Notify dependents of multiple property changes\n   * @param {State} state - State object\n   * @param {Array<string>} properties - Property names\n   * @returns {number} Number of unique elements rebuilt\n   */\n  notifyMultipleChanges(state, properties) {\n    if (!properties || properties.length === 0) {\n      return 0;\n    }\n    \n    const allDependents = new Set();\n    \n    properties.forEach(property => {\n      const dependents = this.getDependents(state, property);\n      dependents.forEach(el => allDependents.add(el));\n    });\n    \n    allDependents.forEach(element => {\n      if (element.mounted && !element.dirty) {\n        element.markNeedsBuild();\n        this.stats.selectiveRebuilds++;\n      }\n    });\n    \n    this.stats.rebuildsTriggered++;\n    \n    return allDependents.size;\n  }\n  \n  /**\n   * Clear dependencies for element\n   * @param {Element} element - Element to clear\n   */\n  clearDependencies(element) {\n    if (!element) {\n      return;\n    }\n    \n    const elementId = element.id;\n    \n    // Get all dependencies for this element\n    const elementDeps = this.elementDependencies.get(elementId);\n    \n    if (!elementDeps) {\n      return;\n    }\n    \n    let clearedCount = 0;\n    \n    // Remove element from each dependency set\n    elementDeps.forEach(dependencyKey => {\n      const dependents = this.dependencies.get(dependencyKey);\n      \n      if (dependents && dependents.has(element)) {\n        dependents.delete(element);\n        clearedCount++;\n        \n        // Remove empty dependency sets\n        if (dependents.size === 0) {\n          this.dependencies.delete(dependencyKey);\n        }\n      }\n    });\n    \n    // Remove element's dependency tracking\n    this.elementDependencies.delete(elementId);\n    \n    // Remove weak reference\n    this.weakElementRefs.delete(element);\n    \n    this.stats.dependenciesCleared += clearedCount;\n    \n    this.log(`Cleared ${clearedCount} dependencies for element ${elementId}`);\n  }\n  \n  /**\n   * Clear dependencies for a specific state property\n   * @param {State} state - State object\n   * @param {string} property - Property name\n   */\n  clearPropertyDependencies(state, property) {\n    const stateId = this.getStateId(state);\n    const dependencyKey = `${stateId}.${property}`;\n    \n    const dependents = this.dependencies.get(dependencyKey);\n    \n    if (!dependents) {\n      return;\n    }\n    \n    const count = dependents.size;\n    \n    // Remove from element dependencies\n    dependents.forEach(element => {\n      const elementDeps = this.elementDependencies.get(element.id);\n      if (elementDeps) {\n        elementDeps.delete(dependencyKey);\n      }\n    });\n    \n    // Remove dependency\n    this.dependencies.delete(dependencyKey);\n    \n    this.stats.dependenciesCleared += count;\n  }\n  \n  /**\n   * Clear all dependencies for a state\n   * @param {State} state - State object\n   */\n  clearStateDependencies(state) {\n    const stateId = this.getStateId(state);\n    \n    // Find all dependencies for this state\n    const keysToDelete = [];\n    \n    this.dependencies.forEach((dependents, key) => {\n      if (key.startsWith(`${stateId}.`)) {\n        keysToDelete.push(key);\n        \n        // Remove from element dependencies\n        dependents.forEach(element => {\n          const elementDeps = this.elementDependencies.get(element.id);\n          if (elementDeps) {\n            elementDeps.delete(key);\n          }\n        });\n      }\n    });\n    \n    keysToDelete.forEach(key => {\n      this.dependencies.delete(key);\n    });\n    \n    this.log(`Cleared all dependencies for state ${stateId}`);\n  }\n  \n  /**\n   * Clear all dependencies\n   */\n  clear() {\n    this.dependencies.clear();\n    this.elementDependencies.clear();\n    this.tracking = false;\n    this.currentElement = null;\n    this.trackingStack = [];\n    \n    this.log('Cleared all dependencies');\n  }\n  \n  /**\n   * Get state ID\n   * @param {State} state - State object\n   * @returns {string}\n   */\n  getStateId(state) {\n    if (!state) {\n      return 'unknown';\n    }\n    \n    // Use existing ID or generate one\n    if (!state._stateId) {\n      state._stateId = `state_${++StateTracker._stateIdCounter}`;\n    }\n    \n    return state._stateId;\n  }\n  \n  /**\n   * Get total number of dependencies\n   * @returns {number}\n   */\n  getTotalDependencies() {\n    let total = 0;\n    this.dependencies.forEach(dependents => {\n      total += dependents.size;\n    });\n    return total;\n  }\n  \n  /**\n   * Get dependency tree for debugging\n   * @returns {Object}\n   */\n  getDependencyTree() {\n    const tree = {};\n    \n    this.dependencies.forEach((dependents, key) => {\n      tree[key] = Array.from(dependents).map(el => ({\n        id: el.id,\n        type: el.constructor.name,\n        mounted: el.mounted\n      }));\n    });\n    \n    return tree;\n  }\n  \n  /**\n   * Get element dependency map\n   * @returns {Object}\n   */\n  getElementDependencyMap() {\n    const map = {};\n    \n    this.elementDependencies.forEach((deps, elementId) => {\n      map[elementId] = Array.from(deps);\n    });\n    \n    return map;\n  }\n  \n  /**\n   * Check if tracking is active\n   * @returns {boolean}\n   */\n  isTracking() {\n    return this.tracking && this.currentElement !== null;\n  }\n  \n  /**\n   * Get current tracking element\n   * @returns {Element|null}\n   */\n  getCurrentElement() {\n    return this.currentElement;\n  }\n  \n  /**\n   * Get statistics\n   * @returns {Object}\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      totalDependencies: this.getTotalDependencies(),\n      uniqueDependencyKeys: this.dependencies.size,\n      trackedElements: this.elementDependencies.size,\n      isTracking: this.tracking,\n      trackingStackDepth: this.trackingStack.length\n    };\n  }\n  \n  /**\n   * Get detailed report\n   * @returns {Object}\n   */\n  getDetailedReport() {\n    return {\n      stats: this.getStats(),\n      dependencyTree: this.getDependencyTree(),\n      elementDependencies: this.getElementDependencyMap(),\n      config: this.config,\n      timestamp: Date.now()\n    };\n  }\n  \n  /**\n   * Reset statistics\n   */\n  resetStats() {\n    this.stats = {\n      dependenciesTracked: 0,\n      dependenciesCleared: 0,\n      rebuildsTriggered: 0,\n      selectiveRebuilds: 0,\n      fullRebuilds: 0,\n      trackingSessionsStarted: 0,\n      trackingSessionsEnded: 0,\n      peakDependencies: 0\n    };\n  }\n  \n  /**\n   * Enable/disable tracking\n   * @param {boolean} enabled - Enable tracking\n   */\n  setTrackingEnabled(enabled) {\n    this.config.enableTracking = enabled;\n    \n    if (!enabled) {\n      this.stopTracking();\n    }\n  }\n  \n  /**\n   * Log debug message\n   * @param {string} message - Message to log\n   */\n  log(message) {\n    if (!this.config.enableDebugLogging) {\n      return;\n    }\n    \n    const logEntry = {\n      timestamp: Date.now(),\n      message: message\n    };\n    \n    this.debugLog.push(logEntry);\n    \n    // Keep log size manageable\n    if (this.debugLog.length > this.maxDebugLogSize) {\n      this.debugLog.shift();\n    }\n    \n    console.log(`[StateTracker] ${message}`);\n  }\n  \n  /**\n   * Get debug log\n   * @returns {Array}\n   */\n  getDebugLog() {\n    return [...this.debugLog];\n  }\n  \n  /**\n   * Clear debug log\n   */\n  clearDebugLog() {\n    this.debugLog = [];\n  }\n}\n\n// Static counter for state IDs\nStateTracker._stateIdCounter = 0;\n\n\nexport {StateTracker};"],
  "mappings": "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",
  "names": ["StateTracker", "config", "element", "previous", "state", "property", "stateId", "dependencyKey", "dependents", "elementId", "totalDeps", "validDependents", "properties", "allDependents", "el", "elementDeps", "clearedCount", "count", "keysToDelete", "key", "total", "tree", "map", "deps", "enabled", "message", "logEntry"]
}
