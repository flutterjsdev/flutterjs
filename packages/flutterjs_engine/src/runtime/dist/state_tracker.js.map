{
  "version": 3,
  "sources": ["../src/state_tracker.js"],
  "sourcesContent": ["/**\r\n * FlutterJS State Tracker\r\n * \r\n * Tracks dependencies between state properties and UI elements.\r\n * Enables fine-grained reactivity by only rebuilding elements\r\n * that depend on changed state properties.\r\n * \r\n * Key Features:\r\n * - Track which elements depend on which state properties\r\n * - Automatic dependency recording during build\r\n * - Selective rebuilds (only affected elements)\r\n * - Memory-efficient weak references\r\n * - Performance monitoring\r\n * \r\n * Usage:\r\n * 1. Start tracking before build\r\n * 2. Record dependencies during property access\r\n * 3. Stop tracking after build\r\n * 4. Rebuild only dependents when property changes\r\n */\r\n\r\n/**\r\n * StateTracker Class\r\n * \r\n * Manages dependency relationships between state and elements\r\n */\r\nclass StateTracker {\r\n  constructor(config = {}) {\r\n    // Configuration\r\n    this.config = {\r\n      enableTracking: config.enableTracking !== false,\r\n      enableWeakRefs: config.enableWeakRefs !== false,\r\n      maxDependenciesPerProperty: config.maxDependenciesPerProperty || 1000,\r\n      enableDebugLogging: config.enableDebugLogging || false,\r\n      warnOnThreshold: config.warnOnThreshold !== false,\r\n      dependencyThreshold: config.dependencyThreshold || 500\r\n    };\r\n    \r\n    // Core tracking\r\n    this.dependencies = new Map();          // \"stateId.property\" \u2192 Set<element>\r\n    this.elementDependencies = new Map();   // elementId \u2192 Set<\"stateId.property\">\r\n    \r\n    // Weak references for automatic cleanup\r\n    this.weakElementRefs = new WeakMap();   // element \u2192 metadata\r\n    \r\n    // Current tracking state\r\n    this.tracking = false;\r\n    this.currentElement = null;\r\n    this.trackingStack = [];                // Support nested tracking\r\n    \r\n    // Performance tracking\r\n    this.stats = {\r\n      dependenciesTracked: 0,\r\n      dependenciesCleared: 0,\r\n      rebuildsTriggered: 0,\r\n      selectiveRebuilds: 0,\r\n      fullRebuilds: 0,\r\n      trackingSessionsStarted: 0,\r\n      trackingSessionsEnded: 0,\r\n      peakDependencies: 0\r\n    };\r\n    \r\n    // Debug tracking\r\n    this.debugLog = [];\r\n    this.maxDebugLogSize = 1000;\r\n  }\r\n  \r\n  /**\r\n   * Start tracking dependencies for build\r\n   * @param {Element} element - Element being built\r\n   */\r\n  startTracking(element) {\r\n    if (!this.config.enableTracking) {\r\n      return;\r\n    }\r\n    \r\n    if (!element) {\r\n      throw new Error('Element is required for tracking');\r\n    }\r\n    \r\n    // Support nested tracking (push to stack)\r\n    if (this.tracking && this.currentElement) {\r\n      this.trackingStack.push({\r\n        element: this.currentElement,\r\n        tracking: this.tracking\r\n      });\r\n    }\r\n    \r\n    this.tracking = true;\r\n    this.currentElement = element;\r\n    \r\n    this.stats.trackingSessionsStarted++;\r\n    \r\n    this.log(`Started tracking for element ${element.id}`);\r\n  }\r\n  \r\n  /**\r\n   * Stop tracking dependencies\r\n   */\r\n  stopTracking() {\r\n    if (!this.config.enableTracking) {\r\n      return;\r\n    }\r\n    \r\n    if (this.currentElement) {\r\n      this.log(`Stopped tracking for element ${this.currentElement.id}`);\r\n    }\r\n    \r\n    // Restore previous tracking state from stack\r\n    if (this.trackingStack.length > 0) {\r\n      const previous = this.trackingStack.pop();\r\n      this.currentElement = previous.element;\r\n      this.tracking = previous.tracking;\r\n    } else {\r\n      this.tracking = false;\r\n      this.currentElement = null;\r\n    }\r\n    \r\n    this.stats.trackingSessionsEnded++;\r\n  }\r\n  \r\n  /**\r\n   * Record dependency: element depends on state property\r\n   * @param {State} state - State object\r\n   * @param {string} property - Property name\r\n   */\r\n  recordDependency(state, property) {\r\n    if (!this.config.enableTracking || !this.tracking || !this.currentElement) {\r\n      return;\r\n    }\r\n    \r\n    if (!state || !property) {\r\n      if (this.config.enableDebugLogging) {\r\n        console.warn('[StateTracker] Invalid dependency recording attempt');\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Generate dependency key\r\n    const stateId = this.getStateId(state);\r\n    const dependencyKey = `${stateId}.${property}`;\r\n    \r\n    // Add to main dependencies map\r\n    if (!this.dependencies.has(dependencyKey)) {\r\n      this.dependencies.set(dependencyKey, new Set());\r\n    }\r\n    \r\n    const dependents = this.dependencies.get(dependencyKey);\r\n    \r\n    // Check threshold\r\n    if (dependents.size >= this.config.maxDependenciesPerProperty) {\r\n      console.warn(\r\n        `[StateTracker] Max dependencies reached for ${dependencyKey} ` +\r\n        `(${dependents.size}/${this.config.maxDependenciesPerProperty})`\r\n      );\r\n      return;\r\n    }\r\n    \r\n    dependents.add(this.currentElement);\r\n    \r\n    // Track reverse dependency (element \u2192 dependencies)\r\n    const elementId = this.currentElement.id;\r\n    if (!this.elementDependencies.has(elementId)) {\r\n      this.elementDependencies.set(elementId, new Set());\r\n    }\r\n    this.elementDependencies.get(elementId).add(dependencyKey);\r\n    \r\n    // Store weak reference for cleanup\r\n    if (this.config.enableWeakRefs) {\r\n      this.weakElementRefs.set(this.currentElement, {\r\n        id: elementId,\r\n        stateId: stateId,\r\n        property: property,\r\n        trackedAt: Date.now()\r\n      });\r\n    }\r\n    \r\n    this.stats.dependenciesTracked++;\r\n    \r\n    // Track peak\r\n    const totalDeps = this.getTotalDependencies();\r\n    if (totalDeps > this.stats.peakDependencies) {\r\n      this.stats.peakDependencies = totalDeps;\r\n    }\r\n    \r\n    // Warn on threshold\r\n    if (this.config.warnOnThreshold && \r\n        totalDeps > this.config.dependencyThreshold) {\r\n      console.warn(\r\n        `[StateTracker] Dependency count (${totalDeps}) exceeds threshold ` +\r\n        `(${this.config.dependencyThreshold})`\r\n      );\r\n    }\r\n    \r\n    this.log(\r\n      `Recorded dependency: ${this.currentElement.id} \u2192 ${dependencyKey}`\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Get elements that depend on state property\r\n   * @param {State} state - State object\r\n   * @param {string} property - Property name\r\n   * @returns {Set<Element>}\r\n   */\r\n  getDependents(state, property) {\r\n    if (!state || !property) {\r\n      return new Set();\r\n    }\r\n    \r\n    const stateId = this.getStateId(state);\r\n    const dependencyKey = `${stateId}.${property}`;\r\n    \r\n    const dependents = this.dependencies.get(dependencyKey);\r\n    \r\n    if (!dependents) {\r\n      return new Set();\r\n    }\r\n    \r\n    // Filter out unmounted elements\r\n    const validDependents = new Set();\r\n    \r\n    dependents.forEach(element => {\r\n      if (element && element.mounted) {\r\n        validDependents.add(element);\r\n      }\r\n    });\r\n    \r\n    return validDependents;\r\n  }\r\n  \r\n  /**\r\n   * Get all dependencies for an element\r\n   * @param {Element} element - Element\r\n   * @returns {Set<string>} Set of dependency keys\r\n   */\r\n  getElementDependencies(element) {\r\n    if (!element) {\r\n      return new Set();\r\n    }\r\n    \r\n    return this.elementDependencies.get(element.id) || new Set();\r\n  }\r\n  \r\n  /**\r\n   * Notify dependents of property change\r\n   * @param {State} state - State object\r\n   * @param {string} property - Property name\r\n   * @returns {number} Number of elements rebuilt\r\n   */\r\n  notifyPropertyChange(state, property) {\r\n    const dependents = this.getDependents(state, property);\r\n    \r\n    if (dependents.size === 0) {\r\n      return 0;\r\n    }\r\n    \r\n    dependents.forEach(element => {\r\n      if (element.mounted && !element.dirty) {\r\n        element.markNeedsBuild();\r\n        this.stats.selectiveRebuilds++;\r\n      }\r\n    });\r\n    \r\n    this.stats.rebuildsTriggered++;\r\n    \r\n    this.log(\r\n      `Notified ${dependents.size} dependents of ${this.getStateId(state)}.${property} change`\r\n    );\r\n    \r\n    return dependents.size;\r\n  }\r\n  \r\n  /**\r\n   * Notify dependents of multiple property changes\r\n   * @param {State} state - State object\r\n   * @param {Array<string>} properties - Property names\r\n   * @returns {number} Number of unique elements rebuilt\r\n   */\r\n  notifyMultipleChanges(state, properties) {\r\n    if (!properties || properties.length === 0) {\r\n      return 0;\r\n    }\r\n    \r\n    const allDependents = new Set();\r\n    \r\n    properties.forEach(property => {\r\n      const dependents = this.getDependents(state, property);\r\n      dependents.forEach(el => allDependents.add(el));\r\n    });\r\n    \r\n    allDependents.forEach(element => {\r\n      if (element.mounted && !element.dirty) {\r\n        element.markNeedsBuild();\r\n        this.stats.selectiveRebuilds++;\r\n      }\r\n    });\r\n    \r\n    this.stats.rebuildsTriggered++;\r\n    \r\n    return allDependents.size;\r\n  }\r\n  \r\n  /**\r\n   * Clear dependencies for element\r\n   * @param {Element} element - Element to clear\r\n   */\r\n  clearDependencies(element) {\r\n    if (!element) {\r\n      return;\r\n    }\r\n    \r\n    const elementId = element.id;\r\n    \r\n    // Get all dependencies for this element\r\n    const elementDeps = this.elementDependencies.get(elementId);\r\n    \r\n    if (!elementDeps) {\r\n      return;\r\n    }\r\n    \r\n    let clearedCount = 0;\r\n    \r\n    // Remove element from each dependency set\r\n    elementDeps.forEach(dependencyKey => {\r\n      const dependents = this.dependencies.get(dependencyKey);\r\n      \r\n      if (dependents && dependents.has(element)) {\r\n        dependents.delete(element);\r\n        clearedCount++;\r\n        \r\n        // Remove empty dependency sets\r\n        if (dependents.size === 0) {\r\n          this.dependencies.delete(dependencyKey);\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Remove element's dependency tracking\r\n    this.elementDependencies.delete(elementId);\r\n    \r\n    // Remove weak reference\r\n    this.weakElementRefs.delete(element);\r\n    \r\n    this.stats.dependenciesCleared += clearedCount;\r\n    \r\n    this.log(`Cleared ${clearedCount} dependencies for element ${elementId}`);\r\n  }\r\n  \r\n  /**\r\n   * Clear dependencies for a specific state property\r\n   * @param {State} state - State object\r\n   * @param {string} property - Property name\r\n   */\r\n  clearPropertyDependencies(state, property) {\r\n    const stateId = this.getStateId(state);\r\n    const dependencyKey = `${stateId}.${property}`;\r\n    \r\n    const dependents = this.dependencies.get(dependencyKey);\r\n    \r\n    if (!dependents) {\r\n      return;\r\n    }\r\n    \r\n    const count = dependents.size;\r\n    \r\n    // Remove from element dependencies\r\n    dependents.forEach(element => {\r\n      const elementDeps = this.elementDependencies.get(element.id);\r\n      if (elementDeps) {\r\n        elementDeps.delete(dependencyKey);\r\n      }\r\n    });\r\n    \r\n    // Remove dependency\r\n    this.dependencies.delete(dependencyKey);\r\n    \r\n    this.stats.dependenciesCleared += count;\r\n  }\r\n  \r\n  /**\r\n   * Clear all dependencies for a state\r\n   * @param {State} state - State object\r\n   */\r\n  clearStateDependencies(state) {\r\n    const stateId = this.getStateId(state);\r\n    \r\n    // Find all dependencies for this state\r\n    const keysToDelete = [];\r\n    \r\n    this.dependencies.forEach((dependents, key) => {\r\n      if (key.startsWith(`${stateId}.`)) {\r\n        keysToDelete.push(key);\r\n        \r\n        // Remove from element dependencies\r\n        dependents.forEach(element => {\r\n          const elementDeps = this.elementDependencies.get(element.id);\r\n          if (elementDeps) {\r\n            elementDeps.delete(key);\r\n          }\r\n        });\r\n      }\r\n    });\r\n    \r\n    keysToDelete.forEach(key => {\r\n      this.dependencies.delete(key);\r\n    });\r\n    \r\n    this.log(`Cleared all dependencies for state ${stateId}`);\r\n  }\r\n  \r\n  /**\r\n   * Clear all dependencies\r\n   */\r\n  clear() {\r\n    this.dependencies.clear();\r\n    this.elementDependencies.clear();\r\n    this.tracking = false;\r\n    this.currentElement = null;\r\n    this.trackingStack = [];\r\n    \r\n    this.log('Cleared all dependencies');\r\n  }\r\n  \r\n  /**\r\n   * Get state ID\r\n   * @param {State} state - State object\r\n   * @returns {string}\r\n   */\r\n  getStateId(state) {\r\n    if (!state) {\r\n      return 'unknown';\r\n    }\r\n    \r\n    // Use existing ID or generate one\r\n    if (!state._stateId) {\r\n      state._stateId = `state_${++StateTracker._stateIdCounter}`;\r\n    }\r\n    \r\n    return state._stateId;\r\n  }\r\n  \r\n  /**\r\n   * Get total number of dependencies\r\n   * @returns {number}\r\n   */\r\n  getTotalDependencies() {\r\n    let total = 0;\r\n    this.dependencies.forEach(dependents => {\r\n      total += dependents.size;\r\n    });\r\n    return total;\r\n  }\r\n  \r\n  /**\r\n   * Get dependency tree for debugging\r\n   * @returns {Object}\r\n   */\r\n  getDependencyTree() {\r\n    const tree = {};\r\n    \r\n    this.dependencies.forEach((dependents, key) => {\r\n      tree[key] = Array.from(dependents).map(el => ({\r\n        id: el.id,\r\n        type: el.constructor.name,\r\n        mounted: el.mounted\r\n      }));\r\n    });\r\n    \r\n    return tree;\r\n  }\r\n  \r\n  /**\r\n   * Get element dependency map\r\n   * @returns {Object}\r\n   */\r\n  getElementDependencyMap() {\r\n    const map = {};\r\n    \r\n    this.elementDependencies.forEach((deps, elementId) => {\r\n      map[elementId] = Array.from(deps);\r\n    });\r\n    \r\n    return map;\r\n  }\r\n  \r\n  /**\r\n   * Check if tracking is active\r\n   * @returns {boolean}\r\n   */\r\n  isTracking() {\r\n    return this.tracking && this.currentElement !== null;\r\n  }\r\n  \r\n  /**\r\n   * Get current tracking element\r\n   * @returns {Element|null}\r\n   */\r\n  getCurrentElement() {\r\n    return this.currentElement;\r\n  }\r\n  \r\n  /**\r\n   * Get statistics\r\n   * @returns {Object}\r\n   */\r\n  getStats() {\r\n    return {\r\n      ...this.stats,\r\n      totalDependencies: this.getTotalDependencies(),\r\n      uniqueDependencyKeys: this.dependencies.size,\r\n      trackedElements: this.elementDependencies.size,\r\n      isTracking: this.tracking,\r\n      trackingStackDepth: this.trackingStack.length\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get detailed report\r\n   * @returns {Object}\r\n   */\r\n  getDetailedReport() {\r\n    return {\r\n      stats: this.getStats(),\r\n      dependencyTree: this.getDependencyTree(),\r\n      elementDependencies: this.getElementDependencyMap(),\r\n      config: this.config,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Reset statistics\r\n   */\r\n  resetStats() {\r\n    this.stats = {\r\n      dependenciesTracked: 0,\r\n      dependenciesCleared: 0,\r\n      rebuildsTriggered: 0,\r\n      selectiveRebuilds: 0,\r\n      fullRebuilds: 0,\r\n      trackingSessionsStarted: 0,\r\n      trackingSessionsEnded: 0,\r\n      peakDependencies: 0\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Enable/disable tracking\r\n   * @param {boolean} enabled - Enable tracking\r\n   */\r\n  setTrackingEnabled(enabled) {\r\n    this.config.enableTracking = enabled;\r\n    \r\n    if (!enabled) {\r\n      this.stopTracking();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Log debug message\r\n   * @param {string} message - Message to log\r\n   */\r\n  log(message) {\r\n    if (!this.config.enableDebugLogging) {\r\n      return;\r\n    }\r\n    \r\n    const logEntry = {\r\n      timestamp: Date.now(),\r\n      message: message\r\n    };\r\n    \r\n    this.debugLog.push(logEntry);\r\n    \r\n    // Keep log size manageable\r\n    if (this.debugLog.length > this.maxDebugLogSize) {\r\n      this.debugLog.shift();\r\n    }\r\n    \r\n    console.log(`[StateTracker] ${message}`);\r\n  }\r\n  \r\n  /**\r\n   * Get debug log\r\n   * @returns {Array}\r\n   */\r\n  getDebugLog() {\r\n    return [...this.debugLog];\r\n  }\r\n  \r\n  /**\r\n   * Clear debug log\r\n   */\r\n  clearDebugLog() {\r\n    this.debugLog = [];\r\n  }\r\n}\r\n\r\n// Static counter for state IDs\r\nStateTracker._stateIdCounter = 0;\r\n\r\n\r\nexport {StateTracker};"],
  "mappings": "AA0BA,MAAMA,CAAa,CACjB,YAAYC,EAAS,CAAC,EAAG,CAEvB,KAAK,OAAS,CACZ,eAAgBA,EAAO,iBAAmB,GAC1C,eAAgBA,EAAO,iBAAmB,GAC1C,2BAA4BA,EAAO,4BAA8B,IACjE,mBAAoBA,EAAO,oBAAsB,GACjD,gBAAiBA,EAAO,kBAAoB,GAC5C,oBAAqBA,EAAO,qBAAuB,GACrD,EAGA,KAAK,aAAe,IAAI,IACxB,KAAK,oBAAsB,IAAI,IAG/B,KAAK,gBAAkB,IAAI,QAG3B,KAAK,SAAW,GAChB,KAAK,eAAiB,KACtB,KAAK,cAAgB,CAAC,EAGtB,KAAK,MAAQ,CACX,oBAAqB,EACrB,oBAAqB,EACrB,kBAAmB,EACnB,kBAAmB,EACnB,aAAc,EACd,wBAAyB,EACzB,sBAAuB,EACvB,iBAAkB,CACpB,EAGA,KAAK,SAAW,CAAC,EACjB,KAAK,gBAAkB,GACzB,CAMA,cAAcC,EAAS,CACrB,GAAK,KAAK,OAAO,eAIjB,IAAI,CAACA,EACH,MAAM,IAAI,MAAM,kCAAkC,EAIhD,KAAK,UAAY,KAAK,gBACxB,KAAK,cAAc,KAAK,CACtB,QAAS,KAAK,eACd,SAAU,KAAK,QACjB,CAAC,EAGH,KAAK,SAAW,GAChB,KAAK,eAAiBA,EAEtB,KAAK,MAAM,0BAEX,KAAK,IAAI,gCAAgCA,EAAQ,EAAE,EAAE,EACvD,CAKA,cAAe,CACb,GAAK,KAAK,OAAO,eASjB,IALI,KAAK,gBACP,KAAK,IAAI,gCAAgC,KAAK,eAAe,EAAE,EAAE,EAI/D,KAAK,cAAc,OAAS,EAAG,CACjC,MAAMC,EAAW,KAAK,cAAc,IAAI,EACxC,KAAK,eAAiBA,EAAS,QAC/B,KAAK,SAAWA,EAAS,QAC3B,MACE,KAAK,SAAW,GAChB,KAAK,eAAiB,KAGxB,KAAK,MAAM,wBACb,CAOA,iBAAiBC,EAAOC,EAAU,CAChC,GAAI,CAAC,KAAK,OAAO,gBAAkB,CAAC,KAAK,UAAY,CAAC,KAAK,eACzD,OAGF,GAAI,CAACD,GAAS,CAACC,EAAU,CACnB,KAAK,OAAO,oBACd,QAAQ,KAAK,qDAAqD,EAEpE,MACF,CAGA,MAAMC,EAAU,KAAK,WAAWF,CAAK,EAC/BG,EAAgB,GAAGD,CAAO,IAAID,CAAQ,GAGvC,KAAK,aAAa,IAAIE,CAAa,GACtC,KAAK,aAAa,IAAIA,EAAe,IAAI,GAAK,EAGhD,MAAMC,EAAa,KAAK,aAAa,IAAID,CAAa,EAGtD,GAAIC,EAAW,MAAQ,KAAK,OAAO,2BAA4B,CAC7D,QAAQ,KACN,+CAA+CD,CAAa,KACxDC,EAAW,IAAI,IAAI,KAAK,OAAO,0BAA0B,GAC/D,EACA,MACF,CAEAA,EAAW,IAAI,KAAK,cAAc,EAGlC,MAAMC,EAAY,KAAK,eAAe,GACjC,KAAK,oBAAoB,IAAIA,CAAS,GACzC,KAAK,oBAAoB,IAAIA,EAAW,IAAI,GAAK,EAEnD,KAAK,oBAAoB,IAAIA,CAAS,EAAE,IAAIF,CAAa,EAGrD,KAAK,OAAO,gBACd,KAAK,gBAAgB,IAAI,KAAK,eAAgB,CAC5C,GAAIE,EACJ,QAASH,EACT,SAAUD,EACV,UAAW,KAAK,IAAI,CACtB,CAAC,EAGH,KAAK,MAAM,sBAGX,MAAMK,EAAY,KAAK,qBAAqB,EACxCA,EAAY,KAAK,MAAM,mBACzB,KAAK,MAAM,iBAAmBA,GAI5B,KAAK,OAAO,iBACZA,EAAY,KAAK,OAAO,qBAC1B,QAAQ,KACN,oCAAoCA,CAAS,wBACzC,KAAK,OAAO,mBAAmB,GACrC,EAGF,KAAK,IACH,wBAAwB,KAAK,eAAe,EAAE,WAAMH,CAAa,EACnE,CACF,CAQA,cAAcH,EAAOC,EAAU,CAC7B,GAAI,CAACD,GAAS,CAACC,EACb,OAAO,IAAI,IAIb,MAAME,EAAgB,GADN,KAAK,WAAWH,CAAK,CACL,IAAIC,CAAQ,GAEtCG,EAAa,KAAK,aAAa,IAAID,CAAa,EAEtD,GAAI,CAACC,EACH,OAAO,IAAI,IAIb,MAAMG,EAAkB,IAAI,IAE5B,OAAAH,EAAW,QAAQN,GAAW,CACxBA,GAAWA,EAAQ,SACrBS,EAAgB,IAAIT,CAAO,CAE/B,CAAC,EAEMS,CACT,CAOA,uBAAuBT,EAAS,CAC9B,OAAKA,EAIE,KAAK,oBAAoB,IAAIA,EAAQ,EAAE,GAAK,IAAI,IAH9C,IAAI,GAIf,CAQA,qBAAqBE,EAAOC,EAAU,CACpC,MAAMG,EAAa,KAAK,cAAcJ,EAAOC,CAAQ,EAErD,OAAIG,EAAW,OAAS,EACf,GAGTA,EAAW,QAAQN,GAAW,CACxBA,EAAQ,SAAW,CAACA,EAAQ,QAC9BA,EAAQ,eAAe,EACvB,KAAK,MAAM,oBAEf,CAAC,EAED,KAAK,MAAM,oBAEX,KAAK,IACH,YAAYM,EAAW,IAAI,kBAAkB,KAAK,WAAWJ,CAAK,CAAC,IAAIC,CAAQ,SACjF,EAEOG,EAAW,KACpB,CAQA,sBAAsBJ,EAAOQ,EAAY,CACvC,GAAI,CAACA,GAAcA,EAAW,SAAW,EACvC,MAAO,GAGT,MAAMC,EAAgB,IAAI,IAE1B,OAAAD,EAAW,QAAQP,GAAY,CACV,KAAK,cAAcD,EAAOC,CAAQ,EAC1C,QAAQS,GAAMD,EAAc,IAAIC,CAAE,CAAC,CAChD,CAAC,EAEDD,EAAc,QAAQX,GAAW,CAC3BA,EAAQ,SAAW,CAACA,EAAQ,QAC9BA,EAAQ,eAAe,EACvB,KAAK,MAAM,oBAEf,CAAC,EAED,KAAK,MAAM,oBAEJW,EAAc,IACvB,CAMA,kBAAkBX,EAAS,CACzB,GAAI,CAACA,EACH,OAGF,MAAMO,EAAYP,EAAQ,GAGpBa,EAAc,KAAK,oBAAoB,IAAIN,CAAS,EAE1D,GAAI,CAACM,EACH,OAGF,IAAIC,EAAe,EAGnBD,EAAY,QAAQR,GAAiB,CACnC,MAAMC,EAAa,KAAK,aAAa,IAAID,CAAa,EAElDC,GAAcA,EAAW,IAAIN,CAAO,IACtCM,EAAW,OAAON,CAAO,EACzBc,IAGIR,EAAW,OAAS,GACtB,KAAK,aAAa,OAAOD,CAAa,EAG5C,CAAC,EAGD,KAAK,oBAAoB,OAAOE,CAAS,EAGzC,KAAK,gBAAgB,OAAOP,CAAO,EAEnC,KAAK,MAAM,qBAAuBc,EAElC,KAAK,IAAI,WAAWA,CAAY,6BAA6BP,CAAS,EAAE,CAC1E,CAOA,0BAA0BL,EAAOC,EAAU,CAEzC,MAAME,EAAgB,GADN,KAAK,WAAWH,CAAK,CACL,IAAIC,CAAQ,GAEtCG,EAAa,KAAK,aAAa,IAAID,CAAa,EAEtD,GAAI,CAACC,EACH,OAGF,MAAMS,EAAQT,EAAW,KAGzBA,EAAW,QAAQN,GAAW,CAC5B,MAAMa,EAAc,KAAK,oBAAoB,IAAIb,EAAQ,EAAE,EACvDa,GACFA,EAAY,OAAOR,CAAa,CAEpC,CAAC,EAGD,KAAK,aAAa,OAAOA,CAAa,EAEtC,KAAK,MAAM,qBAAuBU,CACpC,CAMA,uBAAuBb,EAAO,CAC5B,MAAME,EAAU,KAAK,WAAWF,CAAK,EAG/Bc,EAAe,CAAC,EAEtB,KAAK,aAAa,QAAQ,CAACV,EAAYW,IAAQ,CACzCA,EAAI,WAAW,GAAGb,CAAO,GAAG,IAC9BY,EAAa,KAAKC,CAAG,EAGrBX,EAAW,QAAQN,GAAW,CAC5B,MAAMa,EAAc,KAAK,oBAAoB,IAAIb,EAAQ,EAAE,EACvDa,GACFA,EAAY,OAAOI,CAAG,CAE1B,CAAC,EAEL,CAAC,EAEDD,EAAa,QAAQC,GAAO,CAC1B,KAAK,aAAa,OAAOA,CAAG,CAC9B,CAAC,EAED,KAAK,IAAI,sCAAsCb,CAAO,EAAE,CAC1D,CAKA,OAAQ,CACN,KAAK,aAAa,MAAM,EACxB,KAAK,oBAAoB,MAAM,EAC/B,KAAK,SAAW,GAChB,KAAK,eAAiB,KACtB,KAAK,cAAgB,CAAC,EAEtB,KAAK,IAAI,0BAA0B,CACrC,CAOA,WAAWF,EAAO,CAChB,OAAKA,GAKAA,EAAM,WACTA,EAAM,SAAW,SAAS,EAAEJ,EAAa,eAAe,IAGnDI,EAAM,UARJ,SASX,CAMA,sBAAuB,CACrB,IAAIgB,EAAQ,EACZ,YAAK,aAAa,QAAQZ,GAAc,CACtCY,GAASZ,EAAW,IACtB,CAAC,EACMY,CACT,CAMA,mBAAoB,CAClB,MAAMC,EAAO,CAAC,EAEd,YAAK,aAAa,QAAQ,CAACb,EAAYW,IAAQ,CAC7CE,EAAKF,CAAG,EAAI,MAAM,KAAKX,CAAU,EAAE,IAAIM,IAAO,CAC5C,GAAIA,EAAG,GACP,KAAMA,EAAG,YAAY,KACrB,QAASA,EAAG,OACd,EAAE,CACJ,CAAC,EAEMO,CACT,CAMA,yBAA0B,CACxB,MAAMC,EAAM,CAAC,EAEb,YAAK,oBAAoB,QAAQ,CAACC,EAAMd,IAAc,CACpDa,EAAIb,CAAS,EAAI,MAAM,KAAKc,CAAI,CAClC,CAAC,EAEMD,CACT,CAMA,YAAa,CACX,OAAO,KAAK,UAAY,KAAK,iBAAmB,IAClD,CAMA,mBAAoB,CAClB,OAAO,KAAK,cACd,CAMA,UAAW,CACT,MAAO,CACL,GAAG,KAAK,MACR,kBAAmB,KAAK,qBAAqB,EAC7C,qBAAsB,KAAK,aAAa,KACxC,gBAAiB,KAAK,oBAAoB,KAC1C,WAAY,KAAK,SACjB,mBAAoB,KAAK,cAAc,MACzC,CACF,CAMA,mBAAoB,CAClB,MAAO,CACL,MAAO,KAAK,SAAS,EACrB,eAAgB,KAAK,kBAAkB,EACvC,oBAAqB,KAAK,wBAAwB,EAClD,OAAQ,KAAK,OACb,UAAW,KAAK,IAAI,CACtB,CACF,CAKA,YAAa,CACX,KAAK,MAAQ,CACX,oBAAqB,EACrB,oBAAqB,EACrB,kBAAmB,EACnB,kBAAmB,EACnB,aAAc,EACd,wBAAyB,EACzB,sBAAuB,EACvB,iBAAkB,CACpB,CACF,CAMA,mBAAmBE,EAAS,CAC1B,KAAK,OAAO,eAAiBA,EAExBA,GACH,KAAK,aAAa,CAEtB,CAMA,IAAIC,EAAS,CACX,GAAI,CAAC,KAAK,OAAO,mBACf,OAGF,MAAMC,EAAW,CACf,UAAW,KAAK,IAAI,EACpB,QAASD,CACX,EAEA,KAAK,SAAS,KAAKC,CAAQ,EAGvB,KAAK,SAAS,OAAS,KAAK,iBAC9B,KAAK,SAAS,MAAM,EAGtB,QAAQ,IAAI,kBAAkBD,CAAO,EAAE,CACzC,CAMA,aAAc,CACZ,MAAO,CAAC,GAAG,KAAK,QAAQ,CAC1B,CAKA,eAAgB,CACd,KAAK,SAAW,CAAC,CACnB,CACF,CAGAzB,EAAa,gBAAkB",
  "names": ["StateTracker", "config", "element", "previous", "state", "property", "stateId", "dependencyKey", "dependents", "elementId", "totalDeps", "validDependents", "properties", "allDependents", "el", "elementDeps", "clearedCount", "count", "keysToDelete", "key", "total", "tree", "map", "deps", "enabled", "message", "logEntry"]
}
