{
  "version": 3,
  "sources": ["../src/update_batcher.js"],
  "sourcesContent": ["/**\r\n * FlutterJS Update Batcher\r\n * \r\n * Batches multiple setState calls into single update cycle.\r\n * Improves performance by:\r\n * - Preventing redundant rebuilds\r\n * - Batching DOM updates\r\n * - Reducing layout thrashing\r\n * \r\n * Strategy:\r\n * 1. Collect setState calls into queue\r\n * 2. Flush on microtask (Promise.resolve)\r\n * 3. Apply all updates to state\r\n * 4. Trigger single rebuild per element\r\n * 5. Merge all patches before DOM update\r\n */\r\n\r\nclass UpdateBatcher {\r\n  constructor(runtime) {\r\n    if (!runtime) {\r\n      throw new Error('Runtime instance is required for UpdateBatcher');\r\n    }\r\n    \r\n    this.runtime = runtime;\r\n    \r\n    // Pending updates queue\r\n    this.pendingUpdates = new Map();    // element \u2192 updateFn[]\r\n    this.updateScheduled = false;       // Is flush scheduled?\r\n    \r\n    // Configuration\r\n    this.config = {\r\n      enableBatching: true,\r\n      flushOnMicrotask: true,\r\n      maxBatchSize: 100,\r\n      debugMode: false\r\n    };\r\n    \r\n    // Statistics\r\n    this.stats = {\r\n      totalBatches: 0,\r\n      totalUpdates: 0,\r\n      updatesInLastBatch: 0,\r\n      averageUpdatesPerBatch: 0,\r\n      batchesSinceStart: 0,\r\n      largestBatchSize: 0,\r\n      flushScheduledCount: 0\r\n    };\r\n    \r\n    // Timing\r\n    this.lastFlushTime = 0;\r\n    this.lastFlushDuration = 0;\r\n  }\r\n  \r\n  /**\r\n   * Queue a state update\r\n   * @param {Element} element - Element being updated\r\n   * @param {Function} updateFn - State update function\r\n   * @throws {Error} If element or updateFn invalid\r\n   */\r\n  queueUpdate(element, updateFn) {\r\n    // Validation\r\n    if (!element) {\r\n      throw new Error('Element is required for queueUpdate');\r\n    }\r\n    \r\n    if (typeof updateFn !== 'function') {\r\n      throw new Error('Update function must be a function');\r\n    }\r\n    \r\n    // Check if batching disabled\r\n    if (!this.config.enableBatching) {\r\n      // Execute immediately\r\n      try {\r\n        updateFn.call(element.state);\r\n      } catch (error) {\r\n        console.error('[UpdateBatcher] Immediate update failed:', error);\r\n      }\r\n      element.markNeedsBuild();\r\n      return;\r\n    }\r\n    \r\n    // Initialize update list for element if needed\r\n    if (!this.pendingUpdates.has(element)) {\r\n      this.pendingUpdates.set(element, []);\r\n    }\r\n    \r\n    const updates = this.pendingUpdates.get(element);\r\n    \r\n    // Check batch size limit\r\n    if (updates.length >= this.config.maxBatchSize) {\r\n      if (this.config.debugMode) {\r\n        console.warn(\r\n          `[UpdateBatcher] Max batch size (${this.config.maxBatchSize}) ` +\r\n          `reached for element ${element.id}`\r\n        );\r\n      }\r\n    }\r\n    \r\n    // Add update to queue\r\n    updates.push(updateFn);\r\n    \r\n    // Schedule flush if not already scheduled\r\n    if (!this.updateScheduled) {\r\n      this.scheduleFlush();\r\n    }\r\n    \r\n    if (this.config.debugMode) {\r\n      console.log(\r\n        `[UpdateBatcher] Queued update for ${element.id} ` +\r\n        `(${updates.length} pending)`\r\n      );\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Schedule flush on next microtask\r\n   * Uses Promise for fast microtask execution\r\n   */\r\n  scheduleFlush() {\r\n    if (this.updateScheduled) {\r\n      return;\r\n    }\r\n    \r\n    this.updateScheduled = true;\r\n    this.stats.flushScheduledCount++;\r\n    \r\n    // Use microtask queue (faster than requestAnimationFrame)\r\n    Promise.resolve().then(() => {\r\n      this.flush();\r\n    });\r\n    \r\n    if (this.config.debugMode) {\r\n      console.log('[UpdateBatcher] Flush scheduled');\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Flush all pending updates\r\n   * Process all queued setState calls\r\n   */\r\n  flush() {\r\n    if (!this.updateScheduled) {\r\n      return; // Already flushed\r\n    }\r\n    \r\n    this.updateScheduled = false;\r\n    \r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // Get all pending updates\r\n      const entries = Array.from(this.pendingUpdates.entries());\r\n      \r\n      if (entries.length === 0) {\r\n        if (this.config.debugMode) {\r\n          console.log('[UpdateBatcher] Flush called but no pending updates');\r\n        }\r\n        return;\r\n      }\r\n      \r\n      let totalUpdates = 0;\r\n      \r\n      // Process each element's updates\r\n      for (const [element, updateFns] of entries) {\r\n        // Skip unmounted elements\r\n        if (!element.mounted) {\r\n          if (this.config.debugMode) {\r\n            console.warn(\r\n              `[UpdateBatcher] Skipping unmounted element ${element.id}`\r\n            );\r\n          }\r\n          this.pendingUpdates.delete(element);\r\n          continue;\r\n        }\r\n        \r\n        // Skip elements without state\r\n        if (!element.state) {\r\n          if (this.config.debugMode) {\r\n            console.warn(\r\n              `[UpdateBatcher] Skipping element without state: ${element.id}`\r\n            );\r\n          }\r\n          this.pendingUpdates.delete(element);\r\n          continue;\r\n        }\r\n        \r\n        // Apply all updates to state\r\n        for (const updateFn of updateFns) {\r\n          try {\r\n            updateFn.call(element.state);\r\n            totalUpdates++;\r\n          } catch (error) {\r\n            console.error(\r\n              `[UpdateBatcher] Update function failed for ${element.id}:`,\r\n              error\r\n            );\r\n            // Continue with next update\r\n          }\r\n        }\r\n        \r\n        // Mark element for rebuild (only once per element)\r\n        if (!element.dirty) {\r\n          element.markNeedsBuild();\r\n        }\r\n      }\r\n      \r\n      // Clear pending updates\r\n      this.pendingUpdates.clear();\r\n      \r\n      // Update statistics\r\n      this.recordFlush(totalUpdates, entries.length);\r\n      \r\n      const flushDuration = performance.now() - startTime;\r\n      this.lastFlushDuration = flushDuration;\r\n      this.lastFlushTime = Date.now();\r\n      \r\n      if (this.config.debugMode) {\r\n        console.log(\r\n          `[UpdateBatcher] Flushed ${totalUpdates} updates ` +\r\n          `(${entries.length} elements) in ${flushDuration.toFixed(2)}ms`\r\n        );\r\n      }\r\n      \r\n      // Warn if flush took too long\r\n      if (flushDuration > 16.67) { // 60 FPS target\r\n        console.warn(\r\n          `[UpdateBatcher] Slow flush: ${flushDuration.toFixed(2)}ms ` +\r\n          `(${totalUpdates} updates, ${entries.length} elements)`\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error('[UpdateBatcher] Flush failed:', error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Record flush statistics\r\n   * @param {number} updateCount - Number of updates applied\r\n   * @param {number} elementCount - Number of elements updated\r\n   */\r\n  recordFlush(updateCount, elementCount) {\r\n    this.stats.totalBatches++;\r\n    this.stats.batchesSinceStart++;\r\n    this.stats.totalUpdates += updateCount;\r\n    this.stats.updatesInLastBatch = updateCount;\r\n    \r\n    if (updateCount > this.stats.largestBatchSize) {\r\n      this.stats.largestBatchSize = updateCount;\r\n    }\r\n    \r\n    // Calculate average\r\n    if (this.stats.totalBatches > 0) {\r\n      this.stats.averageUpdatesPerBatch =\r\n        this.stats.totalUpdates / this.stats.totalBatches;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Clear pending updates for specific element\r\n   * @param {Element} element - Element to clear (optional)\r\n   */\r\n  clear(element) {\r\n    if (element) {\r\n      // Clear specific element\r\n      this.pendingUpdates.delete(element);\r\n      \r\n      if (this.config.debugMode) {\r\n        console.log(`[UpdateBatcher] Cleared updates for ${element.id}`);\r\n      }\r\n    } else {\r\n      // Clear all\r\n      const count = this.pendingUpdates.size;\r\n      this.pendingUpdates.clear();\r\n      \r\n      if (this.config.debugMode) {\r\n        console.log(`[UpdateBatcher] Cleared all pending updates (${count})`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get pending update count\r\n   * @param {Element} element - Optional, get count for specific element\r\n   * @returns {number}\r\n   */\r\n  getPendingCount(element) {\r\n    if (element) {\r\n      const updates = this.pendingUpdates.get(element);\r\n      return updates ? updates.length : 0;\r\n    }\r\n    \r\n    let total = 0;\r\n    this.pendingUpdates.forEach(updates => {\r\n      total += updates.length;\r\n    });\r\n    return total;\r\n  }\r\n  \r\n  /**\r\n   * Check if update scheduled\r\n   * @returns {boolean}\r\n   */\r\n  isScheduled() {\r\n    return this.updateScheduled;\r\n  }\r\n  \r\n  /**\r\n   * Get batched elements\r\n   * @returns {Element[]}\r\n   */\r\n  getBatchedElements() {\r\n    return Array.from(this.pendingUpdates.keys());\r\n  }\r\n  \r\n  /**\r\n   * Force immediate flush\r\n   * Used for testing or critical updates\r\n   */\r\n  forceFlush() {\r\n    if (this.config.debugMode) {\r\n      console.log('[UpdateBatcher] Force flush triggered');\r\n    }\r\n    \r\n    this.flush();\r\n  }\r\n  \r\n  /**\r\n   * Enable/disable batching\r\n   * @param {boolean} enabled\r\n   */\r\n  setBatchingEnabled(enabled) {\r\n    this.config.enableBatching = enabled;\r\n    \r\n    if (!enabled && this.updateScheduled) {\r\n      // Flush immediately if batching disabled\r\n      this.forceFlush();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Set debug mode\r\n   * @param {boolean} enabled\r\n   */\r\n  setDebugMode(enabled) {\r\n    this.config.debugMode = enabled;\r\n  }\r\n  \r\n  /**\r\n   * Get statistics\r\n   * @returns {Object}\r\n   */\r\n  getStats() {\r\n    return {\r\n      ...this.stats,\r\n      pendingElements: this.pendingUpdates.size,\r\n      totalPendingUpdates: this.getPendingCount(),\r\n      updateScheduled: this.updateScheduled,\r\n      lastFlushTime: this.lastFlushTime,\r\n      lastFlushDuration: this.lastFlushDuration\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get detailed report\r\n   * @returns {Object}\r\n   */\r\n  getDetailedReport() {\r\n    const elements = this.getBatchedElements();\r\n    const elementDetails = elements.map(el => ({\r\n      id: el.id,\r\n      type: el.constructor.name,\r\n      pendingUpdates: this.getPendingCount(el),\r\n      mounted: el.mounted,\r\n      depth: el.depth\r\n    }));\r\n    \r\n    return {\r\n      stats: this.getStats(),\r\n      batchedElements: elementDetails,\r\n      config: this.config,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Reset statistics\r\n   */\r\n  resetStats() {\r\n    this.stats = {\r\n      totalBatches: 0,\r\n      totalUpdates: 0,\r\n      updatesInLastBatch: 0,\r\n      averageUpdatesPerBatch: 0,\r\n      batchesSinceStart: 0,\r\n      largestBatchSize: 0,\r\n      flushScheduledCount: 0\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Dispose batcher\r\n   */\r\n  dispose() {\r\n    // Force final flush\r\n    if (this.updateScheduled) {\r\n      this.forceFlush();\r\n    }\r\n    \r\n    this.clear();\r\n    this.runtime = null;\r\n    \r\n    if (this.config.debugMode) {\r\n      console.log('[UpdateBatcher] Disposed');\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nexport {UpdateBatcher}\r\n"],
  "mappings": "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",
  "names": ["UpdateBatcher", "runtime", "element", "updateFn", "error", "updates", "startTime", "entries", "totalUpdates", "updateFns", "flushDuration", "updateCount", "elementCount", "count", "total", "enabled", "elementDetails", "el"]
}
