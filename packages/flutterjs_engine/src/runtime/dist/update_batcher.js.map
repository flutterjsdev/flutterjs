{
  "version": 3,
  "sources": ["../src/update_batcher.js"],
  "sourcesContent": ["/**\n * FlutterJS Update Batcher\n * \n * Batches multiple setState calls into single update cycle.\n * Improves performance by:\n * - Preventing redundant rebuilds\n * - Batching DOM updates\n * - Reducing layout thrashing\n * \n * Strategy:\n * 1. Collect setState calls into queue\n * 2. Flush on microtask (Promise.resolve)\n * 3. Apply all updates to state\n * 4. Trigger single rebuild per element\n * 5. Merge all patches before DOM update\n */\n\nclass UpdateBatcher {\n  constructor(runtime) {\n    if (!runtime) {\n      throw new Error('Runtime instance is required for UpdateBatcher');\n    }\n    \n    this.runtime = runtime;\n    \n    // Pending updates queue\n    this.pendingUpdates = new Map();    // element \u2192 updateFn[]\n    this.updateScheduled = false;       // Is flush scheduled?\n    \n    // Configuration\n    this.config = {\n      enableBatching: true,\n      flushOnMicrotask: true,\n      maxBatchSize: 100,\n      debugMode: false\n    };\n    \n    // Statistics\n    this.stats = {\n      totalBatches: 0,\n      totalUpdates: 0,\n      updatesInLastBatch: 0,\n      averageUpdatesPerBatch: 0,\n      batchesSinceStart: 0,\n      largestBatchSize: 0,\n      flushScheduledCount: 0\n    };\n    \n    // Timing\n    this.lastFlushTime = 0;\n    this.lastFlushDuration = 0;\n  }\n  \n  /**\n   * Queue a state update\n   * @param {Element} element - Element being updated\n   * @param {Function} updateFn - State update function\n   * @throws {Error} If element or updateFn invalid\n   */\n  queueUpdate(element, updateFn) {\n    // Validation\n    if (!element) {\n      throw new Error('Element is required for queueUpdate');\n    }\n    \n    if (typeof updateFn !== 'function') {\n      throw new Error('Update function must be a function');\n    }\n    \n    // Check if batching disabled\n    if (!this.config.enableBatching) {\n      // Execute immediately\n      try {\n        updateFn.call(element.state);\n      } catch (error) {\n        console.error('[UpdateBatcher] Immediate update failed:', error);\n      }\n      element.markNeedsBuild();\n      return;\n    }\n    \n    // Initialize update list for element if needed\n    if (!this.pendingUpdates.has(element)) {\n      this.pendingUpdates.set(element, []);\n    }\n    \n    const updates = this.pendingUpdates.get(element);\n    \n    // Check batch size limit\n    if (updates.length >= this.config.maxBatchSize) {\n      if (this.config.debugMode) {\n        console.warn(\n          `[UpdateBatcher] Max batch size (${this.config.maxBatchSize}) ` +\n          `reached for element ${element.id}`\n        );\n      }\n    }\n    \n    // Add update to queue\n    updates.push(updateFn);\n    \n    // Schedule flush if not already scheduled\n    if (!this.updateScheduled) {\n      this.scheduleFlush();\n    }\n    \n    if (this.config.debugMode) {\n      console.log(\n        `[UpdateBatcher] Queued update for ${element.id} ` +\n        `(${updates.length} pending)`\n      );\n    }\n  }\n  \n  /**\n   * Schedule flush on next microtask\n   * Uses Promise for fast microtask execution\n   */\n  scheduleFlush() {\n    if (this.updateScheduled) {\n      return;\n    }\n    \n    this.updateScheduled = true;\n    this.stats.flushScheduledCount++;\n    \n    // Use microtask queue (faster than requestAnimationFrame)\n    Promise.resolve().then(() => {\n      this.flush();\n    });\n    \n    if (this.config.debugMode) {\n      console.log('[UpdateBatcher] Flush scheduled');\n    }\n  }\n  \n  /**\n   * Flush all pending updates\n   * Process all queued setState calls\n   */\n  flush() {\n    if (!this.updateScheduled) {\n      return; // Already flushed\n    }\n    \n    this.updateScheduled = false;\n    \n    const startTime = performance.now();\n    \n    try {\n      // Get all pending updates\n      const entries = Array.from(this.pendingUpdates.entries());\n      \n      if (entries.length === 0) {\n        if (this.config.debugMode) {\n          console.log('[UpdateBatcher] Flush called but no pending updates');\n        }\n        return;\n      }\n      \n      let totalUpdates = 0;\n      \n      // Process each element's updates\n      for (const [element, updateFns] of entries) {\n        // Skip unmounted elements\n        if (!element.mounted) {\n          if (this.config.debugMode) {\n            console.warn(\n              `[UpdateBatcher] Skipping unmounted element ${element.id}`\n            );\n          }\n          this.pendingUpdates.delete(element);\n          continue;\n        }\n        \n        // Skip elements without state\n        if (!element.state) {\n          if (this.config.debugMode) {\n            console.warn(\n              `[UpdateBatcher] Skipping element without state: ${element.id}`\n            );\n          }\n          this.pendingUpdates.delete(element);\n          continue;\n        }\n        \n        // Apply all updates to state\n        for (const updateFn of updateFns) {\n          try {\n            updateFn.call(element.state);\n            totalUpdates++;\n          } catch (error) {\n            console.error(\n              `[UpdateBatcher] Update function failed for ${element.id}:`,\n              error\n            );\n            // Continue with next update\n          }\n        }\n        \n        // Mark element for rebuild (only once per element)\n        if (!element.dirty) {\n          element.markNeedsBuild();\n        }\n      }\n      \n      // Clear pending updates\n      this.pendingUpdates.clear();\n      \n      // Update statistics\n      this.recordFlush(totalUpdates, entries.length);\n      \n      const flushDuration = performance.now() - startTime;\n      this.lastFlushDuration = flushDuration;\n      this.lastFlushTime = Date.now();\n      \n      if (this.config.debugMode) {\n        console.log(\n          `[UpdateBatcher] Flushed ${totalUpdates} updates ` +\n          `(${entries.length} elements) in ${flushDuration.toFixed(2)}ms`\n        );\n      }\n      \n      // Warn if flush took too long\n      if (flushDuration > 16.67) { // 60 FPS target\n        console.warn(\n          `[UpdateBatcher] Slow flush: ${flushDuration.toFixed(2)}ms ` +\n          `(${totalUpdates} updates, ${entries.length} elements)`\n        );\n      }\n    } catch (error) {\n      console.error('[UpdateBatcher] Flush failed:', error);\n    }\n  }\n  \n  /**\n   * Record flush statistics\n   * @param {number} updateCount - Number of updates applied\n   * @param {number} elementCount - Number of elements updated\n   */\n  recordFlush(updateCount, elementCount) {\n    this.stats.totalBatches++;\n    this.stats.batchesSinceStart++;\n    this.stats.totalUpdates += updateCount;\n    this.stats.updatesInLastBatch = updateCount;\n    \n    if (updateCount > this.stats.largestBatchSize) {\n      this.stats.largestBatchSize = updateCount;\n    }\n    \n    // Calculate average\n    if (this.stats.totalBatches > 0) {\n      this.stats.averageUpdatesPerBatch =\n        this.stats.totalUpdates / this.stats.totalBatches;\n    }\n  }\n  \n  /**\n   * Clear pending updates for specific element\n   * @param {Element} element - Element to clear (optional)\n   */\n  clear(element) {\n    if (element) {\n      // Clear specific element\n      this.pendingUpdates.delete(element);\n      \n      if (this.config.debugMode) {\n        console.log(`[UpdateBatcher] Cleared updates for ${element.id}`);\n      }\n    } else {\n      // Clear all\n      const count = this.pendingUpdates.size;\n      this.pendingUpdates.clear();\n      \n      if (this.config.debugMode) {\n        console.log(`[UpdateBatcher] Cleared all pending updates (${count})`);\n      }\n    }\n  }\n  \n  /**\n   * Get pending update count\n   * @param {Element} element - Optional, get count for specific element\n   * @returns {number}\n   */\n  getPendingCount(element) {\n    if (element) {\n      const updates = this.pendingUpdates.get(element);\n      return updates ? updates.length : 0;\n    }\n    \n    let total = 0;\n    this.pendingUpdates.forEach(updates => {\n      total += updates.length;\n    });\n    return total;\n  }\n  \n  /**\n   * Check if update scheduled\n   * @returns {boolean}\n   */\n  isScheduled() {\n    return this.updateScheduled;\n  }\n  \n  /**\n   * Get batched elements\n   * @returns {Element[]}\n   */\n  getBatchedElements() {\n    return Array.from(this.pendingUpdates.keys());\n  }\n  \n  /**\n   * Force immediate flush\n   * Used for testing or critical updates\n   */\n  forceFlush() {\n    if (this.config.debugMode) {\n      console.log('[UpdateBatcher] Force flush triggered');\n    }\n    \n    this.flush();\n  }\n  \n  /**\n   * Enable/disable batching\n   * @param {boolean} enabled\n   */\n  setBatchingEnabled(enabled) {\n    this.config.enableBatching = enabled;\n    \n    if (!enabled && this.updateScheduled) {\n      // Flush immediately if batching disabled\n      this.forceFlush();\n    }\n  }\n  \n  /**\n   * Set debug mode\n   * @param {boolean} enabled\n   */\n  setDebugMode(enabled) {\n    this.config.debugMode = enabled;\n  }\n  \n  /**\n   * Get statistics\n   * @returns {Object}\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      pendingElements: this.pendingUpdates.size,\n      totalPendingUpdates: this.getPendingCount(),\n      updateScheduled: this.updateScheduled,\n      lastFlushTime: this.lastFlushTime,\n      lastFlushDuration: this.lastFlushDuration\n    };\n  }\n  \n  /**\n   * Get detailed report\n   * @returns {Object}\n   */\n  getDetailedReport() {\n    const elements = this.getBatchedElements();\n    const elementDetails = elements.map(el => ({\n      id: el.id,\n      type: el.constructor.name,\n      pendingUpdates: this.getPendingCount(el),\n      mounted: el.mounted,\n      depth: el.depth\n    }));\n    \n    return {\n      stats: this.getStats(),\n      batchedElements: elementDetails,\n      config: this.config,\n      timestamp: Date.now()\n    };\n  }\n  \n  /**\n   * Reset statistics\n   */\n  resetStats() {\n    this.stats = {\n      totalBatches: 0,\n      totalUpdates: 0,\n      updatesInLastBatch: 0,\n      averageUpdatesPerBatch: 0,\n      batchesSinceStart: 0,\n      largestBatchSize: 0,\n      flushScheduledCount: 0\n    };\n  }\n  \n  /**\n   * Dispose batcher\n   */\n  dispose() {\n    // Force final flush\n    if (this.updateScheduled) {\n      this.forceFlush();\n    }\n    \n    this.clear();\n    this.runtime = null;\n    \n    if (this.config.debugMode) {\n      console.log('[UpdateBatcher] Disposed');\n    }\n  }\n}\n\n\n\nexport {UpdateBatcher}\n"],
  "mappings": "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",
  "names": ["UpdateBatcher", "runtime", "element", "updateFn", "error", "updates", "startTime", "entries", "totalUpdates", "updateFns", "flushDuration", "updateCount", "elementCount", "count", "total", "enabled", "elementDetails", "el"]
}
