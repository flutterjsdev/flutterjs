{
  "version": 3,
  "sources": [
    "../src/build_context.js"
  ],
  "sourcesContent": [
    "/**\n * FlutterJS BuildContext\n * \n * BuildContext is the bridge between widgets and the framework.\n * It provides access to:\n * - Ancestor widgets and state\n * - Framework services (Theme, Navigator, MediaQuery)\n * - Inherited values (InheritedWidget data)\n * - Element and state references\n * \n * Key methods:\n * - findAncestorWidgetOfExactType(Type)\n * - findAncestorStateOfType(Type)\n * - dependOnInheritedWidgetOfExactType(Type)\n * - getService(name)\n * \n * Usage:\n * class MyWidget extends StatelessWidget {\n *   build(context) {\n *     final theme = Theme.of(context);\n *     final mediaQuery = MediaQuery.of(context);\n *     return Container(...);\n *   }\n * }\n */\n\nclass BuildContext {\n  /**\n   * Create a new BuildContext\n   * @param {Element} element - Element that owns this context\n   * @param {RuntimeEngine} runtime - Runtime engine reference\n   * @param {State} state - State object (optional, for StatefulWidget)\n   */\n  constructor(element, runtime, state = null) {\n    if (!element) {\n      throw new Error('Element is required for BuildContext');\n    }\n    \n    if (!runtime) {\n      throw new Error('Runtime is required for BuildContext');\n    }\n    \n    // Core references\n    this._element = element;\n    this._runtime = runtime;\n    this._state = state;\n    \n    // Cache for inherited widgets\n    this._inheritedCache = new Map();\n    \n    // Tracking\n    this._visited = new Set();      // For cycle detection\n    this._dependencies = new Set(); // For memory tracking\n  }\n  \n  /**\n   * Get the current widget\n   * @returns {Widget}\n   */\n  get widget() {\n    return this._element ? this._element.widget : null;\n  }\n  \n  /**\n   * Get the current state (StatefulWidget only)\n   * @returns {State|null}\n   */\n  get state() {\n    return this._state;\n  }\n  \n  /**\n   * Get the owning element\n   * @returns {Element}\n   */\n  get element() {\n    return this._element;\n  }\n  \n  /**\n   * Check if mounted\n   * @returns {boolean}\n   */\n  get mounted() {\n    return this._element ? this._element.mounted : false;\n  }\n  \n  /**\n   * Find ancestor widget of exact type\n   * Searches up the element tree for widget of specific type\n   * \n   * @param {Function} Type - Widget class to find\n   * @returns {Widget|null} - Found widget or null\n   * \n   * @example\n   * const appBar = context.findAncestorWidgetOfExactType(AppBar);\n   */\n  findAncestorWidgetOfExactType(Type) {\n    if (!Type) {\n      throw new Error('Widget type is required');\n    }\n    \n    let current = this._element.parent;\n    \n    while (current) {\n      const widget = current.widget;\n      \n      // Check exact type match\n      if (widget && widget.constructor === Type) {\n        return widget;\n      }\n      \n      current = current.parent;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Find ancestor widget of exact type (deprecated name variant)\n   * Alias for findAncestorWidgetOfExactType\n   */\n  findAncestorWidgetOfType(Type) {\n    return this.findAncestorWidgetOfExactType(Type);\n  }\n  \n  /**\n   * Find ancestor state of exact type\n   * Searches up the element tree for StatefulElement with state of specific type\n   * \n   * @param {Function} Type - State class to find\n   * @returns {State|null} - Found state or null\n   * \n   * @example\n   * const counterState = context.findAncestorStateOfType(CounterState);\n   */\n  findAncestorStateOfType(Type) {\n    if (!Type) {\n      throw new Error('State type is required');\n    }\n    \n    let current = this._element.parent;\n    \n    while (current) {\n      // Check if element has state\n      if (current.state) {\n        // Check exact type match\n        if (current.state.constructor === Type) {\n          return current.state;\n        }\n      }\n      \n      current = current.parent;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Find ancestor render object (DOM node)\n   * Gets the DOM reference for ancestor element\n   * \n   * @returns {HTMLElement|null} - DOM node or null\n   */\n  findRenderObject() {\n    let current = this._element.parent;\n    \n    while (current) {\n      if (current.domNode) {\n        return current.domNode;\n      }\n      current = current.parent;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Depend on InheritedWidget of exact type\n   * Finds and registers dependency on InheritedWidget\n   * This element will rebuild when InheritedWidget updates\n   * \n   * @param {Function} Type - InheritedWidget class to find\n   * @returns {InheritedWidget|null} - Found widget or null\n   * \n   * @example\n   * const theme = context.dependOnInheritedWidgetOfExactType(Theme);\n   * if (theme) {\n   *   return Container({ color: theme.data.primaryColor });\n   * }\n   */\n  dependOnInheritedWidgetOfExactType(Type) {\n    if (!Type) {\n      throw new Error('InheritedWidget type is required');\n    }\n    \n    // Check cache first\n    const cached = this._inheritedCache.get(Type);\n    if (cached !== undefined) {\n      return cached;\n    }\n    \n    let current = this._element.parent;\n    \n    while (current) {\n      // Check if this element is InheritedElement\n      if (this._isInheritedElement(current)) {\n        const widget = current.widget;\n        \n        if (widget && widget.constructor === Type) {\n          // Register dependency\n          if (current.addDependent) {\n            current.addDependent(this._element);\n          }\n          \n          // Cache result\n          this._inheritedCache.set(Type, widget);\n          this._dependencies.add(current);\n          \n          return widget;\n        }\n      }\n      \n      current = current.parent;\n    }\n    \n    // Cache null result too\n    this._inheritedCache.set(Type, null);\n    \n    return null;\n  }\n  \n  /**\n   * Convenience: Get Theme\n   * Shorthand for Theme.of(context)\n   * \n   * @returns {ThemeData|null}\n   * \n   * @example\n   * const theme = context.theme();\n   * if (theme) {\n   *   console.log(theme.primaryColor);\n   * }\n   */\n  theme() {\n    const themeWidget = this.dependOnInheritedWidgetOfExactType(\n      this._getThemeClass()\n    );\n    return themeWidget ? themeWidget.data : null;\n  }\n  \n  /**\n   * Convenience: Get MediaQuery\n   * Shorthand for MediaQuery.of(context)\n   * \n   * @returns {MediaQueryData|null}\n   * \n   * @example\n   * const mq = context.mediaQuery();\n   * if (mq) {\n   *   console.log(mq.size.width);\n   * }\n   */\n  mediaQuery() {\n    const mq = this.dependOnInheritedWidgetOfExactType(\n      this._getMediaQueryClass()\n    );\n    return mq ? mq.data : null;\n  }\n  \n  /**\n   * Convenience: Get Navigator\n   * \n   * @returns {NavigatorService|null}\n   */\n  navigator() {\n    return this.getService('navigator');\n  }\n  \n  /**\n   * Get framework service\n   * Accesses registered services from runtime\n   * \n   * @param {string} serviceName - Name of service\n   * @returns {*} - Service instance or null\n   * \n   * @example\n   * const navigator = context.getService('navigator');\n   * const theme = context.getService('theme');\n   */\n  getService(serviceName) {\n    if (!serviceName) {\n      throw new Error('Service name is required');\n    }\n    \n    if (!this._runtime || !this._runtime.serviceRegistry) {\n      return null;\n    }\n    \n    return this._runtime.serviceRegistry.get(serviceName) || null;\n  }\n  \n  /**\n   * Visit all ancestor elements\n   * Calls visitor function for each ancestor\n   * \n   * @param {Function} visitor - Callback function\n   *        Receives: element\n   *        Return false to stop traversal\n   * \n   * @example\n   * context.visitAncestorElements((element) => {\n   *   console.log(element.constructor.name);\n   *   // Return false to stop\n   * });\n   */\n  visitAncestorElements(visitor) {\n    if (typeof visitor !== 'function') {\n      throw new Error('Visitor must be a function');\n    }\n    \n    let current = this._element.parent;\n    \n    while (current) {\n      const shouldContinue = visitor(current);\n      \n      if (shouldContinue === false) {\n        break;\n      }\n      \n      current = current.parent;\n    }\n  }\n  \n  /**\n   * Get size of element\n   * Returns width and height of DOM element\n   * \n   * @returns {Object|null} - { width, height } or null\n   * \n   * @example\n   * const size = context.size;\n   * if (size) {\n   *   console.log(`${size.width}x${size.height}`);\n   * }\n   */\n  get size() {\n    const domNode = this._element ? this._element.domNode : null;\n    \n    if (!domNode) {\n      return null;\n    }\n    \n    return {\n      width: domNode.offsetWidth,\n      height: domNode.offsetHeight\n    };\n  }\n  \n  /**\n   * Get position of element\n   * Returns x, y offset from document\n   * \n   * @returns {Object|null} - { x, y } or null\n   */\n  get position() {\n    const domNode = this._element ? this._element.domNode : null;\n    \n    if (!domNode) {\n      return null;\n    }\n    \n    return {\n      x: domNode.offsetLeft,\n      y: domNode.offsetTop\n    };\n  }\n  \n  /**\n   * Get bounds of element\n   * Returns position and size\n   * \n   * @returns {Object|null} - { x, y, width, height } or null\n   */\n  get bounds() {\n    const size = this.size;\n    const position = this.position;\n    \n    if (!size || !position) {\n      return null;\n    }\n    \n    return {\n      x: position.x,\n      y: position.y,\n      width: size.width,\n      height: size.height\n    };\n  }\n  \n  /**\n   * Dispatch a custom event\n   * For communicating with other widgets\n   * \n   * @param {string} eventName - Event name\n   * @param {*} data - Event data\n   * \n   * @example\n   * context.dispatch('theme-changed', { theme: 'dark' });\n   */\n  dispatch(eventName, data) {\n    if (!eventName) {\n      throw new Error('Event name is required');\n    }\n    \n    // Dispatch to runtime or element\n    if (this._element && this._element.dispatch) {\n      this._element.dispatch(eventName, data);\n    }\n  }\n  \n  /**\n   * Get dependency information\n   * For debugging\n   * \n   * @returns {Object}\n   */\n  getDependencyInfo() {\n    return {\n      dependenciesCount: this._dependencies.size,\n      cachedInheritedWidgets: this._inheritedCache.size,\n      inheritedWidgetTypes: Array.from(this._inheritedCache.keys())\n        .map(Type => Type.name)\n    };\n  }\n  \n  /**\n   * Check if element is InheritedElement\n   * @private\n   */\n  _isInheritedElement(element) {\n    if (!element) return false;\n    \n    // Check by dependents property (MockInheritedElement has this)\n    return element.dependents !== undefined;\n  }\n  \n  /**\n   * Get Theme class\n   * @private\n   */\n  _getThemeClass() {\n    // Try to get from runtime or return a placeholder\n    if (this._runtime && this._runtime._ThemeClass) {\n      return this._runtime._ThemeClass;\n    }\n    \n    // Return a class that won't be found (graceful fallback)\n    return class ThemeClass {};\n  }\n  \n  /**\n   * Get MediaQuery class\n   * @private\n   */\n  _getMediaQueryClass() {\n    if (this._runtime && this._runtime._MediaQueryClass) {\n      return this._runtime._MediaQueryClass;\n    }\n    \n    return class MediaQueryClass {};\n  }\n  \n  /**\n   * Clear cache (for cleanup)\n   * @private\n   */\n  _clearCache() {\n    this._inheritedCache.clear();\n    this._dependencies.clear();\n    this._visited.clear();\n  }\n  \n  /**\n   * Dispose context\n   */\n  dispose() {\n    this._clearCache();\n    this._element = null;\n    this._runtime = null;\n    this._state = null;\n  }\n  \n  /**\n   * Get context information (for debugging)\n   * @returns {Object}\n   */\n  getInfo() {\n    return {\n      mounted: this.mounted,\n      widgetType: this.widget ? this.widget.constructor.name : null,\n      stateType: this.state ? this.state.constructor.name : null,\n      elementId: this._element ? this._element.id : null,\n      elementDepth: this._element ? this._element.depth : null,\n      size: this.size,\n      position: this.position,\n      dependencies: this.getDependencyInfo()\n    };\n  }\n}\n\n\nexport {BuildContext};\n"
  ],
  "mappings": "AA0BA,MAAMA,CAAa,CAOjB,YAAYC,EAASC,EAASC,EAAQ,KAAM,CAC1C,GAAI,CAACF,EACH,MAAM,IAAI,MAAM,sCAAsC,EAGxD,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,sCAAsC,EAIxD,KAAK,SAAWD,EAChB,KAAK,SAAWC,EAChB,KAAK,OAASC,EAGd,KAAK,gBAAkB,IAAI,IAG3B,KAAK,SAAW,IAAI,IACpB,KAAK,cAAgB,IAAI,GAC3B,CAMA,IAAI,QAAS,CACX,OAAO,KAAK,SAAW,KAAK,SAAS,OAAS,IAChD,CAMA,IAAI,OAAQ,CACV,OAAO,KAAK,MACd,CAMA,IAAI,SAAU,CACZ,OAAO,KAAK,QACd,CAMA,IAAI,SAAU,CACZ,OAAO,KAAK,SAAW,KAAK,SAAS,QAAU,EACjD,CAYA,8BAA8BC,EAAM,CAClC,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,yBAAyB,EAG3C,IAAIC,EAAU,KAAK,SAAS,OAE5B,KAAOA,GAAS,CACd,MAAMC,EAASD,EAAQ,OAGvB,GAAIC,GAAUA,EAAO,cAAgBF,EACnC,OAAOE,EAGTD,EAAUA,EAAQ,MACpB,CAEA,OAAO,IACT,CAMA,yBAAyBD,EAAM,CAC7B,OAAO,KAAK,8BAA8BA,CAAI,CAChD,CAYA,wBAAwBA,EAAM,CAC5B,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,wBAAwB,EAG1C,IAAIC,EAAU,KAAK,SAAS,OAE5B,KAAOA,GAAS,CAEd,GAAIA,EAAQ,OAENA,EAAQ,MAAM,cAAgBD,EAChC,OAAOC,EAAQ,MAInBA,EAAUA,EAAQ,MACpB,CAEA,OAAO,IACT,CAQA,kBAAmB,CACjB,IAAIA,EAAU,KAAK,SAAS,OAE5B,KAAOA,GAAS,CACd,GAAIA,EAAQ,QACV,OAAOA,EAAQ,QAEjBA,EAAUA,EAAQ,MACpB,CAEA,OAAO,IACT,CAgBA,mCAAmCD,EAAM,CACvC,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,kCAAkC,EAIpD,MAAMG,EAAS,KAAK,gBAAgB,IAAIH,CAAI,EAC5C,GAAIG,IAAW,OACb,OAAOA,EAGT,IAAIF,EAAU,KAAK,SAAS,OAE5B,KAAOA,GAAS,CAEd,GAAI,KAAK,oBAAoBA,CAAO,EAAG,CACrC,MAAMC,EAASD,EAAQ,OAEvB,GAAIC,GAAUA,EAAO,cAAgBF,EAEnC,OAAIC,EAAQ,cACVA,EAAQ,aAAa,KAAK,QAAQ,EAIpC,KAAK,gBAAgB,IAAID,EAAME,CAAM,EACrC,KAAK,cAAc,IAAID,CAAO,EAEvBC,CAEX,CAEAD,EAAUA,EAAQ,MACpB,CAGA,YAAK,gBAAgB,IAAID,EAAM,IAAI,EAE5B,IACT,CAcA,OAAQ,CACN,MAAMI,EAAc,KAAK,mCACvB,KAAK,eAAe,CACtB,EACA,OAAOA,EAAcA,EAAY,KAAO,IAC1C,CAcA,YAAa,CACX,MAAMC,EAAK,KAAK,mCACd,KAAK,oBAAoB,CAC3B,EACA,OAAOA,EAAKA,EAAG,KAAO,IACxB,CAOA,WAAY,CACV,OAAO,KAAK,WAAW,WAAW,CACpC,CAaA,WAAWC,EAAa,CACtB,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,0BAA0B,EAG5C,MAAI,CAAC,KAAK,UAAY,CAAC,KAAK,SAAS,gBAC5B,KAGF,KAAK,SAAS,gBAAgB,IAAIA,CAAW,GAAK,IAC3D,CAgBA,sBAAsBC,EAAS,CAC7B,GAAI,OAAOA,GAAY,WACrB,MAAM,IAAI,MAAM,4BAA4B,EAG9C,IAAIN,EAAU,KAAK,SAAS,OAE5B,KAAOA,GACkBM,EAAQN,CAAO,IAEf,IAIvBA,EAAUA,EAAQ,MAEtB,CAcA,IAAI,MAAO,CACT,MAAMO,EAAU,KAAK,SAAW,KAAK,SAAS,QAAU,KAExD,OAAKA,EAIE,CACL,MAAOA,EAAQ,YACf,OAAQA,EAAQ,YAClB,EANS,IAOX,CAQA,IAAI,UAAW,CACb,MAAMA,EAAU,KAAK,SAAW,KAAK,SAAS,QAAU,KAExD,OAAKA,EAIE,CACL,EAAGA,EAAQ,WACX,EAAGA,EAAQ,SACb,EANS,IAOX,CAQA,IAAI,QAAS,CACX,MAAMC,EAAO,KAAK,KACZC,EAAW,KAAK,SAEtB,MAAI,CAACD,GAAQ,CAACC,EACL,KAGF,CACL,EAAGA,EAAS,EACZ,EAAGA,EAAS,EACZ,MAAOD,EAAK,MACZ,OAAQA,EAAK,MACf,CACF,CAYA,SAASE,EAAWC,EAAM,CACxB,GAAI,CAACD,EACH,MAAM,IAAI,MAAM,wBAAwB,EAItC,KAAK,UAAY,KAAK,SAAS,UACjC,KAAK,SAAS,SAASA,EAAWC,CAAI,CAE1C,CAQA,mBAAoB,CAClB,MAAO,CACL,kBAAmB,KAAK,cAAc,KACtC,uBAAwB,KAAK,gBAAgB,KAC7C,qBAAsB,MAAM,KAAK,KAAK,gBAAgB,KAAK,CAAC,EACzD,IAAIZ,GAAQA,EAAK,IAAI,CAC1B,CACF,CAMA,oBAAoBH,EAAS,CAC3B,OAAKA,EAGEA,EAAQ,aAAe,OAHT,EAIvB,CAMA,gBAAiB,CAEf,OAAI,KAAK,UAAY,KAAK,SAAS,YAC1B,KAAK,SAAS,YAIhB,KAAiB,CAAC,CAC3B,CAMA,qBAAsB,CACpB,OAAI,KAAK,UAAY,KAAK,SAAS,iBAC1B,KAAK,SAAS,iBAGhB,KAAsB,CAAC,CAChC,CAMA,aAAc,CACZ,KAAK,gBAAgB,MAAM,EAC3B,KAAK,cAAc,MAAM,EACzB,KAAK,SAAS,MAAM,CACtB,CAKA,SAAU,CACR,KAAK,YAAY,EACjB,KAAK,SAAW,KAChB,KAAK,SAAW,KAChB,KAAK,OAAS,IAChB,CAMA,SAAU,CACR,MAAO,CACL,QAAS,KAAK,QACd,WAAY,KAAK,OAAS,KAAK,OAAO,YAAY,KAAO,KACzD,UAAW,KAAK,MAAQ,KAAK,MAAM,YAAY,KAAO,KACtD,UAAW,KAAK,SAAW,KAAK,SAAS,GAAK,KAC9C,aAAc,KAAK,SAAW,KAAK,SAAS,MAAQ,KACpD,KAAM,KAAK,KACX,SAAU,KAAK,SACf,aAAc,KAAK,kBAAkB,CACvC,CACF,CACF",
  "names": [
    "BuildContext",
    "element",
    "runtime",
    "state",
    "Type",
    "current",
    "widget",
    "cached",
    "themeWidget",
    "mq",
    "serviceName",
    "visitor",
    "domNode",
    "size",
    "position",
    "eventName",
    "data"
  ]
}