import{UpdateBatcher as u}from"./update_batcher.js";import{StateTracker as c}from"./state_tracker.js";class h{constructor(){this._element=null,this._widget=null,this._mounted=!1,this._updateQueued=!1,this._building=!1,this._initStateCalled=!1,this._disposeCalled=!1,this._buildCount=0,this._lastBuildTime=0}build(e){throw new Error(`${this.constructor.name}.build() must be implemented`)}initState(){}didUpdateWidget(e){}didChangeDependencies(){}dispose(){}didMount(){}setState(e){if(!this.mounted){console.warn(`[State] setState called on unmounted state (${this.constructor.name})`);return}if(this._building&&console.warn(`[State] setState called during build in ${this.constructor.name}`),typeof e=="function")try{e.call(this)}catch(t){throw console.error("[State] setState update function failed:",t),t}else if(typeof e=="object"&&e!==null)Object.assign(this,e);else if(e!=null)throw new Error("setState accepts function or object");this._element&&this._element.markNeedsBuild&&this._element.markNeedsBuild()}get context(){return this._element?this._element.buildContext():null}get mounted(){return this._mounted&&this._element&&this._element.mounted}get widget(){return this._widget}_markBuilding(e){this._building=e}_init(){if(!this._initStateCalled){this._initStateCalled=!0,this._mounted=!0;try{this.initState()}catch(e){throw console.error("[State] initState failed:",e),e}}}_dispose(){if(!this._disposeCalled){this._disposeCalled=!0,this._mounted=!1;try{this.dispose()}catch(e){console.error("[State] dispose failed:",e)}}}getStats(){return{mounted:this.mounted,buildCount:this._buildCount,lastBuildTime:this._lastBuildTime,initStateCalled:this._initStateCalled,disposeCalled:this._disposeCalled}}}class l{constructor(e){this.runtime=e,this.states=new Map,this.stateElements=new WeakMap,this.updateBatcher=new u(this),this.stateTracker=new c,this.config={enableBatching:!0,enableTracking:!0,warnOnSetStateDuringBuild:!0,debugMode:!1},this.stats={statesCreated:0,statesDisposed:0,setStateCalls:0,batchedUpdates:0}}register(e,t){if(!e||!t)throw new Error("State and element are required");const s=this.generateStateId(e);this.states.set(s,e),this.stateElements.set(e,t),e._element=t,this.stats.statesCreated++,this.config.debugMode&&console.log(`[StateManager] Registered state ${s}`)}unregister(e){if(!e)return;const t=this.generateStateId(e);e._disposeCalled||e._dispose(),this.states.delete(t),this.stateElements.delete(e),e._element=null,e._widget=null,this.stats.statesDisposed++,this.config.debugMode&&console.log(`[StateManager] Unregistered state ${t}`)}handleSetState(e,t){!e||!e.mounted||(this.stats.setStateCalls++,this.config.enableBatching?this.updateBatcher.queueUpdate(e._element,t):(t(),e._element.markNeedsBuild()))}generateStateId(e){return e._stateId||(e._stateId=`state_${++l._stateIdCounter}`),e._stateId}getElement(e){return this.stateElements.get(e)}getStats(){return{...this.stats,currentStates:this.states.size,batcher:this.updateBatcher.getStats(),tracker:this.stateTracker.getStats()}}clear(){this.states.forEach(e=>{e._disposeCalled||e._dispose()}),this.states.clear(),this.updateBatcher.clear(),this.stateTracker.clear()}dispose(){this.clear()}}l._stateIdCounter=0;class _ extends h{constructor(){super(),this._reactiveProperties=new Set,this._propertyValues=new Map}makeReactive(e,t){const s=`_${e}`;this._propertyValues.set(e,t),Object.defineProperty(this,e,{get(){if(this._element&&this._element.runtime){const i=this._element.runtime.stateManager;i&&i.stateTracker.tracking&&i.stateTracker.recordDependency(this,e)}return this._propertyValues.get(e)},set(i){if(this._propertyValues.get(e)!==i&&(this._propertyValues.set(e,i),this._element&&this._element.runtime)){const a=this._element.runtime.stateManager;a&&a.stateTracker.getDependents(this,e).forEach(n=>{n.mounted&&n.markNeedsBuild()})}},enumerable:!0,configurable:!0}),this._reactiveProperties.add(e)}getValue(e){return this._propertyValues.get(e)}setValue(e,t){this[e]=t}}class f{constructor(){this.observers=new Map}observe(e,t){if(!e||typeof t!="function")return;const s=e._stateId||"unknown";this.observers.has(s)||this.observers.set(s,[]),this.observers.get(s).push(t)}notify(e,t,s,i){const r=e._stateId||"unknown",a=this.observers.get(r);a&&a.forEach(d=>{try{d(e,t,s,i)}catch(n){console.error("[StateObserver] Observer callback failed:",n)}})}unobserve(e,t){const s=e._stateId||"unknown",i=this.observers.get(s);if(i)if(t){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}else this.observers.delete(s)}clear(){this.observers.clear()}}export{_ as ReactiveState,h as State,l as StateManager,f as StateObserver};
//# sourceMappingURL=state.js.map
