import{UpdateBatcher as c}from"./update_batcher.js";import{StateTracker as u}from"./state_tracker.js";class h{constructor(){this._element=null,this._widget=null,this._mounted=!1,this._updateQueued=!1,this._building=!1,this._initStateCalled=!1,this._disposeCalled=!1,this._didInitState=!1,this._didMount=!1,this._isActive=!1,this._buildCount=0,this._lastBuildTime=0}build(t){throw new Error(`${this.constructor.name}.build() must be implemented`)}initState(){}didUpdateWidget(t){}didChangeDependencies(){}dispose(){}didMount(){}activate(){}deactivate(){}reassemble(){}setState(t){if(!this.mounted){console.warn(`[State] setState called on unmounted state (${this.constructor.name})`);return}if(this._building&&console.warn(`[State] setState called during build in ${this.constructor.name}`),typeof t=="function")try{t.call(this)}catch(e){throw console.error("[State] setState update function failed:",e),e}else if(typeof t=="object"&&t!==null)Object.assign(this,t);else if(t!=null)throw new Error("setState accepts function or object");this._element&&this._element.markNeedsBuild&&this._element.markNeedsBuild()}get context(){return this._element?this._element.context:null}get mounted(){return this._mounted&&this._element&&this._element._mounted}get widget(){return this._widget}_markBuilding(t){this._building=t}_mount(t){if(!this._mounted){if(this._element=t,this._widget=t.widget,this._mounted=!0,this._isActive=!0,!this._didInitState){this._didInitState=!0;try{this.initState()}catch(e){throw console.error("[State] initState failed:",e),e}}try{this.didChangeDependencies()}catch(e){console.error("[State] didChangeDependencies failed:",e)}if(!this._didMount){this._didMount=!0;try{this.didMount()}catch(e){console.error("[State] didMount failed:",e)}}}}_unmount(){this._mounted&&(this._isActive=!1,this._mounted=!1)}_reactivate(){if(!this._isActive){this._isActive=!0;try{this.activate()}catch(t){console.error("[State] activate failed:",t)}}}_deactivate(){if(this._isActive){this._isActive=!1;try{this.deactivate()}catch(t){console.error("[State] deactivate failed:",t)}}}_updateWidget(t){this._widget=t}_init(){if(!this._initStateCalled){this._initStateCalled=!0,this._mounted=!0;try{this.initState()}catch(t){throw console.error("[State] initState failed:",t),t}}}_dispose(){if(!this._disposeCalled){this._disposeCalled=!0,this._mounted=!1,this._isActive=!1;try{this.dispose()}catch(t){console.error("[State] dispose failed:",t)}}}getStats(){return{mounted:this.mounted,buildCount:this._buildCount,lastBuildTime:this._lastBuildTime,initStateCalled:this._initStateCalled,disposeCalled:this._disposeCalled,isActive:this._isActive}}}class d{constructor(t){this.runtime=t,this.states=new Map,this.stateElements=new WeakMap,this.updateBatcher=new c(this),this.stateTracker=new u,this.config={enableBatching:!0,enableTracking:!0,warnOnSetStateDuringBuild:!0,debugMode:!1},this.stats={statesCreated:0,statesDisposed:0,setStateCalls:0,batchedUpdates:0}}register(t,e){if(!t||!e)throw new Error("State and element are required");const s=this.generateStateId(t);this.states.set(s,t),this.stateElements.set(t,e),t._element=e,this.stats.statesCreated++,this.config.debugMode&&console.log(`[StateManager] Registered state ${s}`)}unregister(t){if(!t)return;const e=this.generateStateId(t);t._disposeCalled||t._dispose(),this.states.delete(e),this.stateElements.delete(t),t._element=null,t._widget=null,this.stats.statesDisposed++,this.config.debugMode&&console.log(`[StateManager] Unregistered state ${e}`)}handleSetState(t,e){!t||!t.mounted||(this.stats.setStateCalls++,this.config.enableBatching?this.updateBatcher.queueUpdate(t._element,e):(e(),t._element.markNeedsBuild()))}generateStateId(t){return t._stateId||(t._stateId=`state_${++d._stateIdCounter}`),t._stateId}getElement(t){return this.stateElements.get(t)}getStats(){return{...this.stats,currentStates:this.states.size,batcher:this.updateBatcher.getStats(),tracker:this.stateTracker.getStats()}}clear(){this.states.forEach(t=>{t._disposeCalled||t._dispose()}),this.states.clear(),this.updateBatcher.clear(),this.stateTracker.clear()}dispose(){this.clear()}}d._stateIdCounter=0;class _ extends h{constructor(){super(),this._reactiveProperties=new Set,this._propertyValues=new Map}makeReactive(t,e){const s=`_${t}`;this._propertyValues.set(t,e),Object.defineProperty(this,t,{get(){if(this._element&&this._element.runtime){const i=this._element.runtime.stateManager;i&&i.stateTracker.tracking&&i.stateTracker.recordDependency(this,t)}return this._propertyValues.get(t)},set(i){if(this._propertyValues.get(t)!==i&&(this._propertyValues.set(t,i),this._element&&this._element.runtime)){const a=this._element.runtime.stateManager;a&&a.stateTracker.getDependents(this,t).forEach(n=>{n._mounted&&n.markNeedsBuild()})}},enumerable:!0,configurable:!0}),this._reactiveProperties.add(t)}getValue(t){return this._propertyValues.get(t)}setValue(t,e){this[t]=e}}class f{constructor(){this.observers=new Map}observe(t,e){if(!t||typeof e!="function")return;const s=t._stateId||"unknown";this.observers.has(s)||this.observers.set(s,[]),this.observers.get(s).push(e)}notify(t,e,s,i){const r=t._stateId||"unknown",a=this.observers.get(r);a&&a.forEach(l=>{try{l(t,e,s,i)}catch(n){console.error("[StateObserver] Observer callback failed:",n)}})}unobserve(t,e){const s=t._stateId||"unknown",i=this.observers.get(s);if(i)if(e){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}else this.observers.delete(s)}clear(){this.observers.clear()}}export{_ as ReactiveState,h as State,d as StateManager,f as StateObserver};
//# sourceMappingURL=state.js.map
