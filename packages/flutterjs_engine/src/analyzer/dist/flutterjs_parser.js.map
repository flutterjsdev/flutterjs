{
  "version": 3,
  "sources": ["../src/flutterjs_parser.js"],
  "sourcesContent": ["/**\n * FlutterJS Parser - Converts tokens to AST (FIXED VERSION)\n * Phase 1.2 MVP Implementation - Complete Fixes\n * \n * Final fix: parseParameterList handles UNDEFINED and NULL token types\n */\n\n\nimport { TokenType } from './lexer.js';\nimport { getLogger } from './flutterjs_logger.js';\n\n// ============================================================================\n// AST NODE CLASSES\n// ============================================================================\n\nclass ASTNode {\n  constructor(type, location) {\n    this.type = type;\n    this.location = location;\n  }\n}\n\nclass Program extends ASTNode {\n  constructor(body = [], location = null) {\n    super('Program', location);\n    this.body = body;\n  }\n}\n\nclass ImportDeclaration extends ASTNode {\n  constructor(specifiers = [], source = null, location = null) {\n    super('ImportDeclaration', location);\n    this.specifiers = specifiers;\n    this.source = source;\n  }\n}\n\nclass ImportSpecifier extends ASTNode {\n  constructor(imported = null, local = null, location = null) {\n    super('ImportSpecifier', location);\n    this.imported = imported;\n    this.local = local;\n  }\n}\n\nclass ClassDeclaration extends ASTNode {\n  constructor(id = null, superClass = null, body = null, location = null) {\n    super('ClassDeclaration', location);\n    this.id = id;\n    this.superClass = superClass;\n    this.body = body;\n  }\n}\n\nclass ClassBody extends ASTNode {\n  constructor(fields = [], methods = [], location = null) {\n    super('ClassBody', location);\n    this.fields = fields;\n    this.methods = methods;\n  }\n}\n\nclass FieldDeclaration extends ASTNode {\n  constructor(key = null, initialValue = null, location = null) {\n    super('FieldDeclaration', location);\n    this.key = key;\n    this.initialValue = initialValue;\n  }\n}\n\nclass MethodDeclaration extends ASTNode {\n  constructor(key = null, params = [], body = null, location = null) {\n    super('MethodDeclaration', location);\n    this.key = key;\n    this.params = params;\n    this.body = body;\n  }\n}\n\nclass Parameter extends ASTNode {\n  constructor(name = null, optional = false, defaultValue = null, location = null) {\n    super('Parameter', location);\n    this.name = name;\n    this.optional = optional;\n    this.defaultValue = defaultValue;\n  }\n}\n\nclass FunctionDeclaration extends ASTNode {\n  constructor(id = null, params = [], body = null, isAsync = false, location = null) {\n    super('FunctionDeclaration', location);\n    this.id = id;\n    this.params = params;\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\nclass BlockStatement extends ASTNode {\n  constructor(body = [], location = null) {\n    super('BlockStatement', location);\n    this.body = body;\n  }\n}\n\nclass ReturnStatement extends ASTNode {\n  constructor(argument = null, location = null) {\n    super('ReturnStatement', location);\n    this.argument = argument;\n  }\n}\n\nclass ExpressionStatement extends ASTNode {\n  constructor(expression = null, location = null) {\n    super('ExpressionStatement', location);\n    this.expression = expression;\n  }\n}\n\nclass Identifier extends ASTNode {\n  constructor(name = '', location = null) {\n    super('Identifier', location);\n    this.name = name;\n  }\n}\n\nclass Literal extends ASTNode {\n  constructor(value = null, raw = '', type = 'string', location = null) {\n    super('Literal', location);\n    this.value = value;\n    this.raw = raw;\n    this.literalType = type;\n  }\n}\n\nclass CallExpression extends ASTNode {\n  constructor(callee = null, args = [], location = null) {\n    super('CallExpression', location);\n    this.callee = callee;\n    this.args = args;\n  }\n}\n\nclass NewExpression extends ASTNode {\n  constructor(callee = null, args = [], location = null) {\n    super('NewExpression', location);\n    this.callee = callee;\n    this.args = args;\n    this.isConst = false;\n  }\n}\n\nclass ObjectLiteral extends ASTNode {\n  constructor(properties = [], location = null) {\n    super('ObjectLiteral', location);\n    this.properties = properties;\n  }\n}\n\nclass Property extends ASTNode {\n  constructor(key = null, value = null, location = null) {\n    super('Property', location);\n    this.key = key;\n    this.value = value;\n    this.shorthand = false;\n  }\n}\n\nclass ArrowFunctionExpression extends ASTNode {\n  constructor(params = [], body = null, location = null) {\n    super('ArrowFunctionExpression', location);\n    this.params = params;\n    this.body = body;\n  }\n}\n\nclass MemberExpression extends ASTNode {\n  constructor(object = null, property = null, computed = false, location = null) {\n    super('MemberExpression', location);\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n}\n\n// ============================================================================\n// PARSER CLASS\n// ============================================================================\n\nclass Parser {\n  constructor(tokens = [], options = {}) {\n    this.tokens = tokens;\n    this.current = 0;\n    this.errors = [];\n    this.options = { strict: false, ...options };\n    // NEW: Call stack tracking\n    this.callStack = [];\n\n    this.debugMode = true;\n  }\n\n  parse() {\n    const body = [];\n\n    while (!this.isAtEnd()) {\n      try {\n        const stmt = this.parseTopLevel();\n        if (stmt) {\n          body.push(stmt);\n        }\n      } catch (error) {\n        this.errors.push(error);\n        this.synchronize();\n      }\n    }\n\n    return new Program(body);\n  }\n\n  /**\n * Skip any comment tokens\n * Comments should be transparent to the parser\n */\n  skipComments() {\n    while (!this.isAtEnd() && this.check(TokenType.COMMENT)) {\n      this.advance();\n    }\n  }\n\n  /**\n   * Check if token is a comment\n   */\n  isComment() {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === TokenType.COMMENT;\n  }\n\n\n  parseTopLevel() {\n    this.skipComments();  // \u2190 ADD THIS LINE\n\n    if (this.isAtEnd()) return null;\n\n    if (this.isKeyword('import')) {\n      this.advance();\n      return this.parseImportDeclaration();\n    }\n\n    if (this.isKeyword('class')) {\n      this.advance();\n      return this.parseClassDeclaration();\n    }\n\n    if (this.isKeyword('function')) {\n      this.advance();\n      return this.parseFunctionDeclaration();\n    }\n\n    const expr = this.parseExpression();\n    this.consumeStatementEnd();\n    return new ExpressionStatement(expr, this.getLocation());\n  }\n  isKeyword(value) {\n    if (this.isAtEnd()) return false;\n    const token = this.peek();\n    return token.type === TokenType.KEYWORD && token.value === value;\n  }\n\n  isPunctuation(value) {\n    if (this.isAtEnd()) return false;\n    const token = this.peek();\n    return token.type === TokenType.PUNCTUATION && token.value === value;\n  }\n\n  isOperator(value) {\n    if (this.isAtEnd()) return false;\n    const token = this.peek();\n    return token.type === TokenType.OPERATOR && token.value === value;\n  }\n\n  parseImportDeclaration() {\n    const startLocation = this.getLocation();\n    const specifiers = [];\n\n    if (this.isPunctuation('{')) {\n      this.advance();\n      while (!this.isPunctuation('}') && !this.isAtEnd()) {\n        const name = this.consume(TokenType.IDENTIFIER, 'Expected identifier').value;\n        const imported = new Identifier(name);\n        let local = imported;\n\n        if (this.isKeyword('as')) {\n          this.advance();\n          const localName = this.consume(TokenType.IDENTIFIER, 'Expected identifier').value;\n          local = new Identifier(localName);\n        }\n\n        specifiers.push(new ImportSpecifier(imported, local));\n\n        if (!this.isPunctuation(',')) break;\n        this.advance();\n      }\n      this.consume(TokenType.PUNCTUATION, 'Expected }');\n    }\n\n    this.consume(TokenType.KEYWORD, 'Expected from');\n    const source = new Literal(\n      this.consume(TokenType.STRING, 'Expected string').value,\n      '',\n      'string'\n    );\n    this.consumeStatementEnd();\n\n    return new ImportDeclaration(specifiers, source, startLocation);\n  }\n\n  parseClassDeclaration() {\n    const logger = getLogger().createComponentLogger('Parser.parseClassDeclaration');\n    logger.startSession('parseClassDeclaration');\n    logger.trace(`  Current token: ${this.peek().value} (${this.peek().type})`);\n\n    const startLocation = this.getLocation();\n    const nameToken = this.consume(TokenType.IDENTIFIER, 'Expected class name');\n    const name = new Identifier(nameToken.value);\n    logger.trace(`  Class name: ${name.name}`);\n\n    let superClass = null;\n    if (this.isKeyword('extends')) {\n      this.advance();\n      const superName = this.consume(TokenType.IDENTIFIER, 'Expected superclass name').value;\n      superClass = new Identifier(superName);\n      logger.trace(`  Extends: ${superClass.name}`);\n\n      // Skip generic type parameters like <MyCounter>\n      if (this.isOperator('<')) {\n        this.advance();\n        this.consume(TokenType.IDENTIFIER, 'Expected type name');\n        this.consume(TokenType.OPERATOR, 'Expected >');\n      }\n    }\n\n    logger.trace(`  Looking for opening brace...`);\n    logger.trace(`  Current token: ${this.peek().value} (${this.peek().type})`);\n    this.consume(TokenType.PUNCTUATION, 'Expected {');\n\n    const fields = [];\n    const methods = [];\n\n    logger.trace(`  Parsing class body...`);\n    let itemCount = 0;\n\n    while (!this.isPunctuation('}') && !this.isAtEnd()) {\n      this.skipComments();  // \u2190 ADD THIS LINE - skip comments in class body\n\n      if (this.isPunctuation('}')) break;  // Check again after skipping comments\n\n      logger.trace(`    [item ${itemCount}] Current token: ${this.peek().value} (${this.peek().type})`);\n\n      // Skip semicolons\n      if (this.isPunctuation(';')) {\n        logger.trace(`    Skipping semicolon`);\n        this.advance();\n        continue;\n      }\n\n      // Check for constructor (always a method)\n      if (this.isKeyword('constructor')) {\n        logger.trace(`    Found constructor`);\n        methods.push(this.parseMethodDeclaration());\n        itemCount++;\n        continue;\n      }\n\n      // Check for field or method\n      if (this.check(TokenType.IDENTIFIER)) {\n        const currentPos = this.current;\n        const idToken = this.peek();\n        const fieldName = idToken.value;\n        logger.trace(`    Found identifier: ${fieldName}`);\n        this.advance();\n\n        // CASE 1: Field initializer - IDENTIFIER = value\n        if (this.isOperator('=')) {\n          logger.trace(`      -> This is a FIELD (followed by =)`);\n          this.current = currentPos; // Rewind\n          try {\n            fields.push(this.parseFieldDeclaration());\n            logger.trace(`      Field parsed successfully`);\n            itemCount++;\n            continue;\n          } catch (e) {\n            console.error(`      ERROR parsing field: ${e.message}`);\n            throw e;\n          }\n        }\n\n        // CASE 2: Method - IDENTIFIER ( params )\n        if (this.isPunctuation('(')) {\n          logger.trace(`      -> This is a METHOD (followed by '(')`);\n          this.current = currentPos; // Rewind\n          try {\n            methods.push(this.parseMethodDeclaration());\n            logger.trace(`      Method parsed successfully`);\n            itemCount++;\n            continue;\n          } catch (e) {\n            console.error(`      ERROR parsing method: ${e.message}`);\n            throw e;\n          }\n        }\n\n        logger.trace(`      -> Unknown pattern, skipping`);\n        this.advance();\n        continue;\n      }\n\n      // Skip unknown tokens\n      logger.trace(`    Skipping unknown token: ${this.peek().value}`);\n      this.advance();\n    }\n\n    logger.trace(`  Class body parsing complete. Found ${fields.length} fields, ${methods.length} methods`);\n\n    this.consume(TokenType.PUNCTUATION, 'Expected }');\n    const body = new ClassBody(fields, methods);\n    logger.trace(`[parseClassDeclaration] SUCCESS\\n`);\n    return new ClassDeclaration(name, superClass, body, startLocation);\n  }\n\n\n  parseMethodDeclaration() {\n    const logger = getLogger().createComponentLogger('Parser.parseMethodDeclaration');\n    logger.startSession(`      [parseMethodDeclaration] STARTING`);\n    logger.trace(`        Current: ${this.peek().value}`);\n\n    const startLocation = this.getLocation();\n\n    let methodName;\n    if (this.isKeyword('constructor')) {\n      methodName = 'constructor';\n      this.advance();\n    } else {\n      methodName = this.consume(TokenType.IDENTIFIER, 'Expected method name').value;\n    }\n\n    logger.trace(`        Method name: ${methodName}`);\n    const key = new Identifier(methodName);\n\n    this.consume(TokenType.PUNCTUATION, 'Expected (');\n    const params = this.parseParameterList();\n    logger.trace(`        Parameters: ${params.length}`);\n    this.consume(TokenType.PUNCTUATION, 'Expected )');\n\n    let body = null;\n    if (this.isOperator('=>')) {\n      logger.trace(`        Arrow function body`);\n      this.advance();\n      body = this.parseExpression();\n    } else if (this.isPunctuation('{')) {\n      logger.trace(`        Block body`);\n      this.advance();\n      body = this.parseBlock();\n    }\n\n    logger.trace(`      [parseMethodDeclaration] SUCCESS`);\n    return new MethodDeclaration(key, params, body, startLocation);\n  }\n  parseFieldDeclaration() {\n    console.log(`      [parseFieldDeclaration] STARTING`);\n    console.log(`        Current: ${this.peek().value}`);\n\n    const startLocation = this.getLocation();\n    const fieldName = this.consume(TokenType.IDENTIFIER, 'Expected field name').value;\n    const key = new Identifier(fieldName);\n    console.log(`        Field name: ${fieldName}`);\n\n    let initialValue = null;\n    if (this.isOperator('=')) {\n      console.log(`        Found = operator, parsing initializer...`);\n      this.advance();\n      try {\n        initialValue = this.parseExpression();\n        console.log(`        Initializer parsed: ${initialValue.type}`);\n      } catch (e) {\n        console.error(`        ERROR parsing initializer: ${e.message}`);\n        throw e;\n      }\n    }\n\n    this.consumeStatementEnd();\n    console.log(`      [parseFieldDeclaration] SUCCESS`);\n    return new FieldDeclaration(key, initialValue, startLocation);\n  }\n\n  parseFunctionDeclaration() {\n    const startLocation = this.getLocation();\n    const nameToken = this.consume(TokenType.IDENTIFIER, 'Expected function name');\n    const name = nameToken.value ? new Identifier(nameToken.value) : null;\n\n    this.consume(TokenType.PUNCTUATION, 'Expected (');\n    const params = this.parseParameterList();\n    this.consume(TokenType.PUNCTUATION, 'Expected )');\n\n    this.consume(TokenType.PUNCTUATION, 'Expected {');\n    const body = this.parseBlock();\n\n    return new FunctionDeclaration(name, params, body, false, startLocation);\n  }\n\n  /**\n   * Parse parameter list - FIXED to handle UNDEFINED and NULL token types\n   */\n  parseParameterList() {\n    const params = [];\n\n    while (!this.isPunctuation(')') && !this.isAtEnd()) {\n      const paramLocation = this.getLocation();\n\n      // Handle destructuring: { key = value }\n      if (this.isPunctuation('{')) {\n        this.advance();\n        while (!this.isPunctuation('}') && !this.isAtEnd()) {\n          const paramName = this.consume(TokenType.IDENTIFIER, 'Expected param name').value;\n          let defaultValue = null;\n\n          if (this.isOperator('=')) {\n            this.advance();\n            // FIXED: Check token type, not just keywords\n            const token = this.peek();\n\n            if (this.check(TokenType.IDENTIFIER)) {\n              defaultValue = new Identifier(this.advance().value);\n            } else if (this.check(TokenType.NUMBER)) {\n              defaultValue = new Literal(parseFloat(this.advance().value), '', 'number');\n            } else if (this.check(TokenType.UNDEFINED)) {\n              // FIXED: Handle UNDEFINED token type\n              this.advance();\n              defaultValue = new Literal(undefined, 'undefined', 'undefined');\n            } else if (this.check(TokenType.NULL)) {\n              // FIXED: Handle NULL token type\n              this.advance();\n              defaultValue = new Literal(null, 'null', 'null');\n            } else if (this.isKeyword('undefined')) {\n              this.advance();\n              defaultValue = new Literal(undefined, 'undefined', 'undefined');\n            } else if (this.isKeyword('null')) {\n              this.advance();\n              defaultValue = new Literal(null, 'null', 'null');\n            }\n          }\n\n          params.push(new Parameter(new Identifier(paramName), defaultValue !== null, defaultValue, paramLocation));\n\n          if (!this.isPunctuation(',')) break;\n          this.advance();\n        }\n        this.consume(TokenType.PUNCTUATION, 'Expected }');\n\n        // Handle = {} after destructuring\n        if (this.isOperator('=')) {\n          this.advance();\n          if (this.isPunctuation('{')) {\n            this.advance();\n            let braceDepth = 1;\n            while (braceDepth > 0 && !this.isAtEnd()) {\n              if (this.isPunctuation('{')) braceDepth++;\n              else if (this.isPunctuation('}')) braceDepth--;\n              if (braceDepth > 0) this.advance();\n            }\n            this.consume(TokenType.PUNCTUATION, 'Expected }');\n          }\n        }\n      } else if (this.check(TokenType.IDENTIFIER)) {\n        // Regular parameter\n        const paramName = this.consume(TokenType.IDENTIFIER, 'Expected param name').value;\n        let defaultValue = null;\n\n        if (this.isOperator('=')) {\n          this.advance();\n          const token = this.peek();\n\n          if (this.check(TokenType.IDENTIFIER)) {\n            defaultValue = new Identifier(this.advance().value);\n          } else if (this.check(TokenType.NUMBER)) {\n            defaultValue = new Literal(parseFloat(this.advance().value), '', 'number');\n          } else if (this.check(TokenType.UNDEFINED)) {\n            this.advance();\n            defaultValue = new Literal(undefined, 'undefined', 'undefined');\n          } else if (this.check(TokenType.NULL)) {\n            this.advance();\n            defaultValue = new Literal(null, 'null', 'null');\n          } else if (this.isKeyword('undefined')) {\n            this.advance();\n            defaultValue = new Literal(undefined, 'undefined', 'undefined');\n          } else if (this.isKeyword('null')) {\n            this.advance();\n            defaultValue = new Literal(null, 'null', 'null');\n          }\n        }\n\n        params.push(new Parameter(new Identifier(paramName), defaultValue !== null, defaultValue, paramLocation));\n      } else {\n        break;\n      }\n\n      if (!this.isPunctuation(',')) break;\n      this.advance();\n    }\n\n    return params;\n  }\n\n  parseBlock() {\n    console.log(`\\n[parseBlock] STARTING at token: ${this.peek().value}`);\n\n    const startLocation = this.getLocation();\n    const statements = [];\n\n    while (!this.isPunctuation('}') && !this.isAtEnd()) {\n      this.skipComments();  // \u2190 ADD THIS LINE - skip comments in block\n\n      if (this.isPunctuation('}')) break;  // Check again after skipping\n\n      console.log(`  [parseBlock] Current token: ${this.peek().value} (${this.peek().type})`);\n\n      if (this.isKeyword('return')) {\n        console.log(`    Found RETURN statement`);\n        this.advance();\n        let argument = null;\n\n        if (!this.isPunctuation(';') && !this.isPunctuation('}')) {\n          console.log(`    Parsing return argument...`);\n          try {\n            argument = this.parseExpression();\n            console.log(`    Return argument parsed successfully`);\n          } catch (error) {\n            console.error(`    \u274C ERROR parsing return argument: ${error.message}`);\n            console.error(`       Token was: ${this.peek().value}`);\n\n            // Skip to semicolon\n            while (!this.isPunctuation(';') && !this.isPunctuation('}') && !this.isAtEnd()) {\n              this.advance();\n            }\n          }\n        }\n\n        this.consumeStatementEnd();\n        statements.push(new ReturnStatement(argument, startLocation));\n\n      } else {\n        console.log(`    Parsing expression statement...`);\n        try {\n          const expr = this.parseExpression();\n          console.log(`    Expression parsed successfully: ${expr.type}`);\n          this.consumeStatementEnd();\n          statements.push(new ExpressionStatement(expr, startLocation));\n        } catch (error) {\n          console.error(`    \u274C ERROR parsing expression: ${error.message}`);\n          console.error(`       Token was: ${this.peek().value}`);\n\n          // Skip to next statement\n          while (!this.isPunctuation(';') && !this.isPunctuation('}') && !this.isAtEnd()) {\n            this.advance();\n          }\n          if (this.isPunctuation(';')) {\n            this.advance();\n          }\n        }\n      }\n    }\n\n    if (this.isPunctuation('}')) {\n      this.advance();\n    }\n\n    console.log(`[parseBlock] SUCCESS - ${statements.length} statements\\n`);\n    return new BlockStatement(statements, startLocation);\n  }\n\n  parseExpression() {\n    console.log(`    [parseExpression] Current token: ${this.peek().value}`);\n    try {\n      const result = this.parseAssignment();\n      console.log(`    [parseExpression] \u2713 Success, type: ${result.type}`);\n      return result;\n    } catch (e) {\n      console.error(`    [parseExpression] \u2717 Failed: ${e.message}`);\n      throw e;\n    }\n  }\n\n  parseAssignment() {\n    let expr = this.parseTernary();\n\n    if (this.isOperator('=')) {\n      this.advance();\n      const value = this.parseAssignment();\n      return { type: 'AssignmentExpression', left: expr, right: value };\n    }\n\n    return expr;\n  }\n\n  parseTernary() {\n    let expr = this.parseLogicalOr();\n\n    if (this.isOperator('?')) {\n      this.advance();\n      const consequent = this.parseExpression();\n      this.consume(TokenType.OPERATOR, 'Expected :');\n      const alternate = this.parseExpression();\n      return { type: 'ConditionalExpression', test: expr, consequent, alternate };\n    }\n\n    return expr;\n  }\n\n  parseLogicalOr() {\n    let expr = this.parseLogicalAnd();\n\n    while (this.isOperator('||')) {\n      this.advance();\n      const right = this.parseLogicalAnd();\n      expr = { type: 'LogicalExpression', operator: '||', left: expr, right };\n    }\n\n    return expr;\n  }\n\n  parseLogicalAnd() {\n    let expr = this.parseEquality();\n\n    while (this.isOperator('&&')) {\n      this.advance();\n      const right = this.parseEquality();\n      expr = { type: 'LogicalExpression', operator: '&&', left: expr, right };\n    }\n\n    return expr;\n  }\n\n  parseEquality() {\n    let expr = this.parseRelational();\n\n    while (this.isOperator('===') || this.isOperator('!==') || this.isOperator('==') || this.isOperator('!=')) {\n      const operator = this.advance().value;\n      const right = this.parseRelational();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n\n    return expr;\n  }\n\n  parseRelational() {\n    let expr = this.parseAdditive();\n\n    while (this.isOperator('<') || this.isOperator('>') || this.isOperator('<=') || this.isOperator('>=')) {\n      const operator = this.advance().value;\n      const right = this.parseAdditive();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n\n    return expr;\n  }\n\n  parseAdditive() {\n    let expr = this.parseMultiplicative();\n\n    while (this.isOperator('+') || this.isOperator('-')) {\n      const operator = this.advance().value;\n      const right = this.parseMultiplicative();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n\n    return expr;\n  }\n\n  parseMultiplicative() {\n    let expr = this.parseUnary();\n\n    while (this.isOperator('*') || this.isOperator('/') || this.isOperator('%')) {\n      const operator = this.advance().value;\n      const right = this.parseUnary();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n\n    return expr;\n  }\n\n  parseUnary() {\n    console.log(`        [parseUnary] Current: ${this.peek().value}`);\n\n    if (this.isOperator('!') || this.isOperator('-') || this.isOperator('+') || this.isOperator('~')) {\n      const operator = this.advance().value;\n      const expr = this.parseUnary();\n      return { type: 'UnaryExpression', operator, argument: expr };\n    }\n\n\n    console.log(`        [parseUnary] Calling parsePostfix`);\n    return this.parsePostfix();\n  }\n\n  parsePostfix() {\n    console.log(`        [parsePostfix] Starting, calling parseCall`);\n    let expr = this.parseCall();\n    console.log(`        [parsePostfix] parseCall returned: ${expr.type || expr.name}`);\n    console.log(`        [parsePostfix] Next token: ${this.peek().value}`);\n\n    while (true) {\n      if (this.isOperator('++') || this.isOperator('--')) {\n        const operator = this.advance().value;\n        expr = { type: 'UpdateExpression', operator, argument: expr, prefix: false };\n      } else if (this.isPunctuation('.')) {\n        console.log(`        [parsePostfix] Found . member access`);\n        this.advance();\n        const property = new Identifier(this.consume(TokenType.IDENTIFIER, 'Expected property').value);\n        expr = new MemberExpression(expr, property, false);\n        console.log(`        [parsePostfix] Created MemberExpression: ${expr.object.name}.${expr.property.name}`);\n      } else if (this.isPunctuation('[')) {\n        console.log(`        [parsePostfix] Found [ computed access`);\n        this.advance();\n        const property = this.parseExpression();\n        this.consume(TokenType.PUNCTUATION, 'Expected ]');\n        expr = new MemberExpression(expr, property, true);\n      } else {\n        console.log(`        [parsePostfix] No more postfix ops, returning ${expr.type}`);\n        break;\n      }\n    }\n\n    return expr;\n  }\n\n\n  parseCall() {\n    console.log(`        [parseCall] Starting, calling parsePrimary`);\n    let expr = this.parsePrimary();\n    console.log(`        [parseCall] parsePrimary returned: ${expr.type || expr.name}`);\n    console.log(`        [parseCall] Next token: ${this.peek().value} (${this.peek().type})`);\n\n    while (this.isPunctuation('(')) {\n      console.log(`        [parseCall] Found (, parsing function call`);\n      this.advance();\n      const args = this.parseArguments();\n      console.log(`        [parseCall] Parsed ${args.length} arguments`);\n      this.consume(TokenType.PUNCTUATION, 'Expected )');\n      expr = new CallExpression(expr, args);\n      console.log(`        [parseCall] Created CallExpression`);\n    }\n\n    console.log(`        [parseCall] Returning: ${expr.type}`);\n    return expr;\n  }\n\n  parsePrimary() {\n    console.log(`      [parsePrimary] Current: ${this.peek().value} (${this.peek().type})`);\n\n    // Handle 'this' keyword FIRST\n    if (this.isKeyword('this')) {\n      this.advance();\n      console.log(`      [parsePrimary] \u2713 this keyword`);\n      return new Identifier('this');\n    }\n\n    if (this.check(TokenType.STRING)) {\n      const token = this.advance();\n      console.log(`      [parsePrimary] \u2713 string literal: ${token.value}`);\n      return new Literal(token.value, token.value, 'string');\n    }\n\n    if (this.check(TokenType.NUMBER)) {\n      const token = this.advance();\n      console.log(`      [parsePrimary] \u2713 number literal: ${token.value}`);\n      return new Literal(parseFloat(token.value), token.value, 'number');\n    }\n\n    if (this.check(TokenType.BOOLEAN)) {\n      const token = this.advance();\n      console.log(`      [parsePrimary] \u2713 boolean: ${token.value}`);\n      return new Literal(token.value === 'true', token.value, 'boolean');\n    }\n\n    if (this.check(TokenType.NULL)) {\n      this.advance();\n      console.log(`      [parsePrimary] \u2713 null`);\n      return new Literal(null, 'null', 'null');\n    }\n\n    if (this.check(TokenType.UNDEFINED)) {\n      this.advance();\n      console.log(`      [parsePrimary] \u2713 undefined`);\n      return new Literal(undefined, 'undefined', 'undefined');\n    }\n\n    if (this.isKeyword('null')) {\n      this.advance();\n      console.log(`      [parsePrimary] \u2713 null keyword`);\n      return new Literal(null, 'null', 'null');\n    }\n\n    if (this.isKeyword('undefined')) {\n      this.advance();\n      console.log(`      [parsePrimary] \u2713 undefined keyword`);\n      return new Literal(undefined, 'undefined', 'undefined');\n    }\n\n    if (this.isPunctuation('(')) {\n      console.log(`      [parsePrimary] Found ( - checking for arrow function or grouped expr`);\n      const savedPos = this.current;\n      this.advance();\n\n      if (this.isPunctuation(')')) {\n        const nextPos = this.current + 1;\n        if (nextPos < this.tokens.length &&\n          this.tokens[nextPos].type === TokenType.OPERATOR &&\n          this.tokens[nextPos].value === '=>') {\n          console.log(`      [parsePrimary] \u2713 arrow function with no params: () => ...`);\n          this.consume(TokenType.PUNCTUATION, 'Expected )');\n          this.consume(TokenType.OPERATOR, 'Expected =>');\n          const body = this.parseExpression();\n          return new ArrowFunctionExpression([], body);\n        }\n      }\n\n      const expr = this.parseExpression();\n      this.consume(TokenType.PUNCTUATION, 'Expected )');\n\n      if (this.isOperator('=>')) {\n        console.log(`      [parsePrimary] \u2713 arrow function: (x) => ...`);\n        this.advance();\n        const body = this.parseExpression();\n        let params = [];\n        if (expr.type === 'Identifier') {\n          params = [new Parameter(expr, false, null)];\n        }\n        return new ArrowFunctionExpression(params, body);\n      }\n\n      console.log(`      [parsePrimary] \u2713 grouped expression`);\n      return expr;\n    }\n\n    if (this.isPunctuation('{')) {\n      console.log(`      [parsePrimary] \u2713 object literal`);\n      this.advance();\n      return this.parseObjectLiteral();\n    }\n\n    if (this.isPunctuation('[')) {\n      console.log(`      [parsePrimary] \u2713 array literal`);\n      this.advance();\n      const elements = [];\n      while (!this.isPunctuation(']') && !this.isAtEnd()) {\n        elements.push(this.parseExpression());\n        if (!this.isPunctuation(',')) break;\n        this.advance();\n      }\n      this.consume(TokenType.PUNCTUATION, 'Expected ]');\n      return { type: 'ArrayLiteral', elements };\n    }\n\n    if (this.isKeyword('new')) {\n      console.log(`      [parsePrimary] \u2713 new expression`);\n      this.advance();\n      const callee = new Identifier(this.consume(TokenType.IDENTIFIER, 'Expected class name').value);\n      this.consume(TokenType.PUNCTUATION, 'Expected (');\n      const args = this.parseArguments();\n      this.consume(TokenType.PUNCTUATION, 'Expected )');\n      return new NewExpression(callee, args);\n    }\n\n    if (this.isKeyword('const')) {\n      const savedPos = this.current;\n      this.advance();\n      if (this.isKeyword('new')) {\n        console.log(`      [parsePrimary] \u2713 const new expression`);\n        this.advance();\n        const callee = new Identifier(this.consume(TokenType.IDENTIFIER, 'Expected class name').value);\n        this.consume(TokenType.PUNCTUATION, 'Expected (');\n        const args = this.parseArguments();\n        this.consume(TokenType.PUNCTUATION, 'Expected )');\n        const expr = new NewExpression(callee, args);\n        expr.isConst = true;\n        return expr;\n      }\n      this.current = savedPos;\n    }\n\n    if (this.check(TokenType.IDENTIFIER)) {\n      const token = this.advance();\n      const ident = new Identifier(token.value);\n      console.log(`      [parsePrimary] \u2713 identifier: ${token.value}`);\n\n      if (this.isOperator('=>')) {\n        console.log(`      [parsePrimary] \u2713 arrow function: x => ...`);\n        this.advance();\n        const body = this.parseExpression();\n        return new ArrowFunctionExpression([new Parameter(ident)], body);\n      }\n\n      return ident;\n    }\n\n    // If we get here, we couldn't parse anything\n    console.error(`      [parsePrimary] \u274C FAILED - Cannot parse token: ${this.peek().value} (${this.peek().type})`);\n    throw this.error('Expected expression');\n  }\n\n\n  enterMethod(methodName) {\n    if (!this.callStack) this.callStack = [];\n    this.callStack.push({\n      method: methodName,\n      line: this.peek().line,\n      column: this.peek().column,\n      token: this.peek().value,\n    });\n  }\n\n  parseObjectLiteral() {\n    this.enterMethod('parseObjectLiteral');\n    const properties = [];\n\n    try {\n      while (!this.isPunctuation('}') && !this.isAtEnd()) {\n        if (this.isPunctuation(',')) {\n          this.advance();\n          continue;\n        }\n\n        let key = null;\n        let shorthand = false;\n\n        if (this.isPunctuation('[')) {\n          this.advance();\n          key = this.parseExpression();\n          this.consume(TokenType.PUNCTUATION, 'Expected ]');\n        } else if (this.check(TokenType.IDENTIFIER)) {\n          const token = this.advance();\n          key = new Identifier(token.value);\n\n          if (this.isPunctuation(',') || this.isPunctuation('}')) {\n            shorthand = true;\n          }\n        } else if (this.check(TokenType.STRING)) {\n          const token = this.advance();\n          key = new Literal(token.value, token.value, 'string');\n        } else {\n          this.advance();\n          continue;\n        }\n\n        let value = key;\n        if (!shorthand && this.isPunctuation(':')) {\n          this.advance();\n\n          try {\n            value = this.parseTernary();\n          } catch (error) {\n            if (error.parserError) {\n              this.reportParserError(error.parserError);\n            }\n            value = key;\n\n            while (!this.isPunctuation(',') && !this.isPunctuation('}') && !this.isAtEnd()) {\n              this.advance();\n            }\n          }\n        }\n\n        const prop = new Property(key, value);\n        prop.shorthand = shorthand;\n        properties.push(prop);\n\n        if (this.isPunctuation(',')) {\n          this.advance();\n        }\n      }\n\n      if (this.isPunctuation('}')) {\n        this.advance();\n      }\n\n      this.exitMethod('parseObjectLiteral');\n      return new ObjectLiteral(properties);\n    } catch (e) {\n      this.exitMethod('parseObjectLiteral');\n      throw e;\n    }\n  }\n  parseArguments() {\n    const args = [];\n\n    while (!this.isPunctuation(')') && !this.isAtEnd()) {\n      try {\n        // \u2B50 KEY FIX: Use parseTernary() instead of parseLogicalOr()\n        // This allows all operators except assignment\n        args.push(this.parseTernary());\n      } catch (error) {\n        break;\n      }\n\n      if (!this.isPunctuation(',')) break;\n      this.advance();\n    }\n\n    return args;\n  }\n\n  check(type) {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === type;\n  }\n\n  consume(type, message = '') {\n    if (this.check(type)) {\n      return this.advance();\n    }\n    throw this.error(message || `Expected ${type}`);\n  }\n\n  consumeStatementEnd() {\n    this.skipComments();  // \u2190 ADD THIS LINE\n\n    if (this.isPunctuation(';')) {\n      this.advance();\n    }\n\n    this.skipComments();  // \u2190 ADD THIS LINE - skip trailing comments too\n  }\n\n  advance() {\n    if (!this.isAtEnd()) {\n      this.current++;\n    }\n    return this.previous();\n  }\n\n  peek() {\n    return this.tokens[this.current];\n  }\n\n  peekAhead(n = 1) {\n    const pos = this.current + n;\n    if (pos >= this.tokens.length) {\n      return this.tokens[this.tokens.length - 1];\n    }\n    return this.tokens[pos];\n  }\n\n  previous() {\n    return this.tokens[this.current - 1];\n  }\n\n  isAtEnd() {\n    return this.peek().type === TokenType.EOF;\n  }\n\n  getLocation() {\n    const token = this.peek();\n    return { line: token.line, column: token.column };\n  }\n  /**\n  * Enhanced error reporting with full call stack\n  */\n  error(message) {\n    const token = this.peek();\n    const errorObj = new Error(\n      `Parse error at line ${token.line}, column ${token.column}: ${message}`\n    );\n    errorObj.parserError = {\n      message: `Parse error at line ${token.line}, column ${token.column}: ${message}`,\n      line: token.line,\n      column: token.column,\n      token: { type: token.type, value: token.value },\n      callStack: this.callStack ? [...this.callStack] : [],\n    };\n    return errorObj;\n  }\n  /**\n   * Get context around current token (5 tokens before and after)\n   */\n  getContext() {\n    const start = Math.max(0, this.current - 5);\n    const end = Math.min(this.tokens.length, this.current + 6);\n\n    return {\n      before: this.tokens.slice(start, this.current).map(t => `${t.value}(${t.type})`).join(' '),\n      current: `\u2192 ${this.peek().value}(${this.peek().type}) \u2190`,\n      after: this.tokens.slice(this.current + 1, end).map(t => `${t.value}(${t.type})`).join(' '),\n    };\n  }\n  /**\n   * Track when exiting a parser method\n   */\n  exitMethod(methodName) {\n    if (!this.callStack) this.callStack = [];\n    if (this.callStack.length > 0) {\n      const last = this.callStack[this.callStack.length - 1];\n      if (last.method === methodName) {\n        this.callStack.pop();\n      }\n    }\n  }\n\n  getTokenContext() {\n    const start = Math.max(0, this.current - 5);\n    const end = Math.min(this.tokens.length, this.current + 6);\n\n    const before = this.tokens\n      .slice(start, this.current)\n      .map(t => `${t.value}`)\n      .join(' ');\n\n    const after = this.tokens\n      .slice(this.current + 1, end)\n      .map(t => `${t.value}`)\n      .join(' ');\n\n    return {\n      before: before,\n      current: `\u2192 ${this.peek().value} \u2190`,\n      after: after,\n    };\n  }\n\n  synchronize() {\n    this.advance();\n    while (!this.isAtEnd()) {\n      if (this.isPunctuation(';')) {\n        this.advance();\n        return;\n      }\n      if (this.isKeyword('class') || this.isKeyword('function') || this.isKeyword('import')) {\n        return;\n      }\n      this.advance();\n    }\n  }\n\n  getErrors() {\n    return this.errors;\n  }\n\n  /**\n   * Report error with full context\n   */\n  reportError(error) {\n    this.errors.push(error);\n\n    if (this.debugMode) {\n      console.error('\\n\u274C PARSER ERROR DETECTED:\\n');\n      console.error(`Message: ${error.message}\\n`);\n\n      console.error('\uD83D\uDCCD Token Context:');\n      console.error(`  Before:  ${error.context.before}`);\n      console.error(`  Current: ${error.context.current}`);\n      console.error(`  After:   ${error.context.after}\\n`);\n\n      console.error('\uD83D\uDCDA Call Stack (where error came from):');\n      if (error.callStack.length === 0) {\n        console.error('  (top level)\\n');\n      } else {\n        error.callStack.forEach((frame, idx) => {\n          const arrow = idx === error.callStack.length - 1 ? '\u2192' : ' ';\n          console.error(`  ${arrow} ${idx + 1}. ${frame.method}()`);\n          console.error(`     at token: \"${frame.token}\" (line ${frame.line}, col ${frame.column})`);\n        });\n        console.error('');\n      }\n    }\n  }\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport {\n  Parser,\n  Program,\n  ImportDeclaration,\n  ImportSpecifier,\n  ClassDeclaration,\n  ClassBody,\n  FieldDeclaration,\n  MethodDeclaration,\n  Parameter,\n  FunctionDeclaration,\n  BlockStatement,\n  ReturnStatement,\n  ExpressionStatement,\n  Identifier,\n  Literal,\n  CallExpression,\n  NewExpression,\n  ObjectLiteral,\n  Property,\n  ArrowFunctionExpression,\n  MemberExpression,\n  ASTNode,\n};"],
  "mappings": "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",
  "names": ["TokenType", "getLogger", "ASTNode", "type", "location", "Program", "body", "ImportDeclaration", "specifiers", "source", "ImportSpecifier", "imported", "local", "ClassDeclaration", "id", "superClass", "ClassBody", "fields", "methods", "FieldDeclaration", "key", "initialValue", "MethodDeclaration", "params", "Parameter", "name", "optional", "defaultValue", "FunctionDeclaration", "isAsync", "BlockStatement", "ReturnStatement", "argument", "ExpressionStatement", "expression", "Identifier", "Literal", "value", "raw", "CallExpression", "callee", "args", "NewExpression", "ObjectLiteral", "properties", "Property", "ArrowFunctionExpression", "MemberExpression", "object", "property", "computed", "Parser", "tokens", "options", "stmt", "error", "expr", "token", "startLocation", "localName", "logger", "nameToken", "superName", "itemCount", "currentPos", "fieldName", "e", "methodName", "paramLocation", "paramName", "braceDepth", "statements", "result", "consequent", "alternate", "right", "operator", "savedPos", "nextPos", "elements", "ident", "shorthand", "prop", "message", "n", "pos", "errorObj", "start", "end", "t", "before", "after", "frame", "idx", "arrow"]
}
