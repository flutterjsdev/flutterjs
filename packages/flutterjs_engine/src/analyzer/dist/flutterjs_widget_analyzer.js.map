{
  "version": 3,
  "sources": ["../src/flutterjs_widget_analyzer.js"],
  "sourcesContent": ["/**\n * WidgetAnalyzer Enhancement - Track field references\n * \n * Understand that:\n *   _count = 0;        <- field declaration\n *   this._count        <- field reference\n * \n * These are the same thing!\n */\n\nimport { getLogger  } from './flutterjs_logger.js';\n\nclass WidgetAnalyzer {\n  constructor(ast, options = {}) {\n    this.ast = ast;\n    this.options = {\n      strict: false,\n      ...options,\n    };\n  this.logger = getLogger().createComponentLogger('WidgetAnalyzer');\n    this.widgets = new Map();        // key: className, value: Widget object\n    this.functions = new Map();      // key: functionName, value: Function object\n    this.imports = [];\n    this.externalDependencies = new Set();\n    this.entryPoint = null;\n    this.rootWidget = null;\n    this.widgetTree = null;\n    this.errors = [];\n  }\n\n  /**\n   * Main entry point - analyze entire AST\n   */\n  analyze() {\n    this.logger.startSession('WidgetAnalyzer');\n    if (!this.ast || !this.ast.body) {\n      throw new Error('Invalid AST provided');\n    }\n\n    this.logger.trace('[WidgetAnalyzer] Starting analysis...');\n\n    try {\n      // Phase 1: Extract all classes and functions\n      this.logger.trace('[WidgetAnalyzer] Phase 1: Extracting classes and functions...');\n      this.extractClassesAndFunctions();\n      this.logger.trace(`[WidgetAnalyzer]   Found ${this.widgets.size} classes in total`);\n\n      // Phase 2: Detect which classes are widgets\n      this.logger.trace('[WidgetAnalyzer] Phase 2: Detecting widgets...');\n      this.detectWidgets();\n      this.logger.trace(`[WidgetAnalyzer]   Detected widgets: ${Array.from(this.widgets.values()).filter(w => w.type !== 'class').length}`);\n\n      // Phase 3: Extract imports and dependencies\n      this.logger.trace('[WidgetAnalyzer] Phase 3: Extracting imports...');\n      this.extractImports();\n      this.logger.trace(`[WidgetAnalyzer]   Found ${this.imports.length} imports`);\n\n      // Phase 4: Find entry point\n      this.logger.trace('[WidgetAnalyzer] Phase 4: Finding entry point...');\n      this.findEntryPoint();\n      this.logger.trace(`[WidgetAnalyzer]   Entry point: ${this.entryPoint || 'NOT FOUND'}`);\n\n      // Phase 5: Build widget tree\n      this.logger.trace('[WidgetAnalyzer] Phase 5: Building widget tree...');\n      this.buildWidgetTree();\n      this.logger.trace(`[WidgetAnalyzer]   Tree root: ${this.rootWidget || 'NOT FOUND'}`);\n\n      this.logger.trace('[WidgetAnalyzer] Analysis complete\\n');\n\n      return this.getResults();\n    } catch (error) {\n      this.errors.push({\n        type: 'analysis-error',\n        message: error.message,\n        stack: error.stack,\n      });\n      return this.getResults();\n    }\n  }\n\n  /**\n   * Phase 1: Extract all classes and functions from AST\n   */\n  extractClassesAndFunctions() {\n    if (!this.ast.body) return;\n\n    for (const node of this.ast.body) {\n      if (node.type === 'ClassDeclaration') {\n        this.extractClassDeclaration(node);\n      } else if (node.type === 'FunctionDeclaration') {\n        this.extractFunctionDeclaration(node);\n      }\n    }\n  }\n\n  /**\n   * Extract a single class declaration\n   * Handles both field declarations and method declarations\n   */\n  extractClassDeclaration(classNode) {\n    const name = classNode.id?.name;\n    if (!name) return;\n\n    const superClass = classNode.superClass?.name || null;\n    const location = classNode.location;\n\n    const widget = {\n      name,\n      type: 'class',\n      location,\n      superClass,\n      constructor: null,\n      properties: [],      // Fields with their initial values\n      methods: [],\n      fieldReferences: {}, // Map of which methods use which fields\n      imports: [],\n      children: [],\n      linkedStateClass: null,\n    };\n\n    // Extract fields (declared with _count = 0; syntax)\n    if (classNode.body?.fields) {\n      classNode.body.fields.forEach((field) => {\n        const fieldName = field.key?.name;\n        const initialValue = field.initialValue ? this.expressionToString(field.initialValue) : null;\n\n        widget.properties.push({\n          name: fieldName,\n          initialValue: initialValue,\n          type: this.inferFieldType(field.initialValue),\n        });\n\n        // Track that this field exists\n        if (!widget.fieldReferences[fieldName]) {\n          widget.fieldReferences[fieldName] = [];\n        }\n      });\n    }\n\n    // Extract constructor\n    if (classNode.body?.methods) {\n      const constructorMethod = classNode.body.methods.find(\n        (m) => m.key?.name === 'constructor'\n      );\n      if (constructorMethod) {\n        widget.constructor = {\n          name: 'constructor',\n          params: constructorMethod.params || [],\n          location: constructorMethod.location,\n        };\n      }\n\n      // Extract other methods and track field usage\n      classNode.body.methods.forEach((method) => {\n        if (method.key?.name !== 'constructor') {\n          const methodName = method.key?.name;\n          const methodData = {\n            name: methodName,\n            params: method.params || [],\n            location: method.location,\n            hasBody: method.body !== null,\n            usesFields: [], // Which fields this method references\n          };\n\n          // Track field references in this method\n          if (method.body) {\n            const fieldRefs = this.findFieldReferencesInBody(method.body);\n            methodData.usesFields = fieldRefs;\n\n            // Update the field reference map\n            fieldRefs.forEach((fieldName) => {\n              if (widget.fieldReferences[fieldName]) {\n                widget.fieldReferences[fieldName].push(methodName);\n              }\n            });\n          }\n\n          widget.methods.push(methodData);\n        }\n      });\n    }\n\n    this.widgets.set(name, widget);\n    this.logger.trace(`[WidgetAnalyzer]     Extracted class: ${name} extends ${superClass}`);\n    if (widget.properties.length > 0) {\n      this.logger.trace(`[WidgetAnalyzer]       Fields: ${widget.properties.map(p => `${p.name}=${p.initialValue}`).join(', ')}`);\n    }\n  }\n\n  /**\n   * Find all field references (this._fieldName) in a method body\n   */\n  findFieldReferencesInBody(body) {\n    const fields = [];\n\n    // Simple traversal to find this.fieldName patterns\n    // This is a basic implementation - enhance as needed\n    const traverse = (node) => {\n      if (!node) return;\n\n      // Look for MemberExpression: this._fieldName\n      if (node.type === 'MemberExpression') {\n        if (node.object?.name === 'this' && node.property?.name) {\n          fields.push(node.property.name);\n        }\n      }\n\n      // Recursively traverse all node properties\n      for (const key in node) {\n        if (key !== 'location' && typeof node[key] === 'object') {\n          if (Array.isArray(node[key])) {\n            node[key].forEach(traverse);\n          } else {\n            traverse(node[key]);\n          }\n        }\n      }\n    };\n\n    traverse(body);\n    return [...new Set(fields)]; // Remove duplicates\n  }\n\n  /**\n   * Infer the type of a field from its initializer\n   */\n  inferFieldType(initialValue) {\n    if (!initialValue) return 'any';\n\n    if (initialValue.type === 'Literal') {\n      const val = initialValue.value;\n      if (typeof val === 'number') return 'int' | 'double';\n      if (typeof val === 'boolean') return 'bool';\n      if (typeof val === 'string') return 'String';\n      if (val === null) return 'null';\n    }\n\n    if (initialValue.type === 'Identifier') {\n      return initialValue.name;\n    }\n\n    if (initialValue.type === 'ArrayExpression') {\n      return 'List';\n    }\n\n    if (initialValue.type === 'ObjectExpression') {\n      return 'Map';\n    }\n\n    return 'dynamic';\n  }\n\n  /**\n   * Extract a function declaration\n   */\n  extractFunctionDeclaration(funcNode) {\n    const name = funcNode.id?.name || 'anonymous';\n    const location = funcNode.location;\n\n    const func = {\n      name,\n      type: 'function',\n      location,\n      params: funcNode.params?.map((p) => ({\n        name: p.name?.name || 'param',\n        optional: p.optional || false,\n      })) || [],\n      isAsync: funcNode.isAsync || false,\n      isEntryPoint: false,\n    };\n\n    this.functions.set(name, func);\n  }\n\n  /**\n   * Phase 2: Detect which classes are widgets\n   */\n  detectWidgets() {\n    this.widgets.forEach((widget) => {\n      if (!widget.superClass) {\n        widget.type = 'class';\n        return;\n      }\n\n      const superClass = widget.superClass;\n\n      if (superClass === 'StatelessWidget') {\n        widget.type = 'stateless';\n        this.logger.trace(`[WidgetAnalyzer]     ${widget.name} is StatelessWidget`);\n      } else if (superClass === 'StatefulWidget') {\n        widget.type = 'stateful';\n        this.logger.trace(`[WidgetAnalyzer]     ${widget.name} is StatefulWidget`);\n      } else if (superClass?.startsWith('State')) {\n        widget.type = 'state';\n        this.logger.trace(`[WidgetAnalyzer]     ${widget.name} is State class`);\n      } else {\n        widget.type = 'component';\n      }\n    });\n  }\n\n  /**\n   * Phase 3: Extract imports\n   */\n  extractImports() {\n    if (!this.ast.body) return;\n\n    this.ast.body.forEach((node) => {\n      if (node.type === 'ImportDeclaration') {\n        const source = node.source?.value;\n        const items = node.specifiers?.map((spec) => spec.imported?.name) || [];\n\n        this.imports.push({\n          source,\n          items,\n        });\n\n        this.externalDependencies.add(source);\n      }\n    });\n  }\n\n  /**\n   * Phase 4: Find entry point\n   */\n  findEntryPoint() {\n    if (this.functions.has('main')) {\n      this.entryPoint = 'main';\n      const mainFunc = this.functions.get('main');\n      mainFunc.isEntryPoint = true;\n\n      const mainAstNode = this.ast.body.find(\n        (n) => n.type === 'FunctionDeclaration' && n.id?.name === 'main'\n      );\n\n      if (mainAstNode?.body?.body) {\n        this.rootWidget = this.findRunAppWidget(mainAstNode.body.body);\n      }\n    }\n  }\n\n  /**\n   * Find which widget is passed to runApp()\n   */\n  findRunAppWidget(statements) {\n    for (const stmt of statements) {\n      if (stmt.type === 'ExpressionStatement' && stmt.expression?.type === 'CallExpression') {\n        const call = stmt.expression;\n        if (call.callee?.name === 'runApp' && call.args?.length > 0) {\n          return this.getWidgetNameFromExpression(call.args[0]);\n        }\n      }\n      if (stmt.type === 'ReturnStatement' && stmt.argument?.type === 'CallExpression') {\n        const call = stmt.argument;\n        if (call.callee?.name === 'runApp' && call.args?.length > 0) {\n          return this.getWidgetNameFromExpression(call.args[0]);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Extract widget name from expression\n   */\n  getWidgetNameFromExpression(expr) {\n    if (!expr) return null;\n\n    if (expr.type === 'NewExpression') {\n      return expr.callee?.name;\n    }\n\n    if (expr.type === 'CallExpression') {\n      return expr.callee?.name;\n    }\n\n    if (expr.type === 'Identifier') {\n      return expr.name;\n    }\n\n    return null;\n  }\n\n  /**\n   * Phase 5: Build widget tree\n   */\n  buildWidgetTree() {\n    if (!this.rootWidget || !this.widgets.has(this.rootWidget)) {\n      return;\n    }\n\n    const rootWidget = this.widgets.get(this.rootWidget);\n    this.widgetTree = {\n      widget: rootWidget,\n      depth: 0,\n      children: [],\n    };\n  }\n\n  /**\n   * Convert expression to string representation\n   */\n  expressionToString(expr) {\n    if (!expr) return null;\n\n    if (expr.type === 'Literal') {\n      return expr.value;\n    }\n\n    if (expr.type === 'Identifier') {\n      const name = expr.name;\n      if (name === 'true' || name === 'false') return name === 'true';\n      if (name === 'null') return null;\n      if (name === 'undefined') return undefined;\n      return name;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get results\n   */\n  getResults() {\n    const widgetArray = Array.from(this.widgets.values()).filter(\n      (w) => w.type === 'stateless' || w.type === 'stateful' || w.type === 'state' || w.type === 'component'\n    );\n\n    this.logger.trace(`[WidgetAnalyzer] getResults() returning ${widgetArray.length} widgets`);\n\n    return {\n      widgets: widgetArray,\n      functions: Array.from(this.functions.values()),\n      imports: this.imports,\n      externalDependencies: Array.from(this.externalDependencies),\n      entryPoint: this.entryPoint,\n      rootWidget: this.rootWidget,\n      widgetTree: this.widgetTree,\n      errors: this.errors,\n    };\n  }\n\n  /**\n   * Get summary statistics\n   */\n  getSummary() {\n    const widgets = Array.from(this.widgets.values());\n    const statelessCount = widgets.filter((w) => w.type === 'stateless').length;\n    const statefulCount = widgets.filter((w) => w.type === 'stateful').length;\n    const stateCount = widgets.filter((w) => w.type === 'state').length;\n\n    return {\n      totalWidgets: widgets.length,\n      statelessWidgets: statelessCount,\n      statefulWidgets: statefulCount,\n      stateClasses: stateCount,\n      totalFunctions: this.functions.size,\n      totalImports: this.imports.length,\n      externalPackages: this.externalDependencies.size,\n      entryPoint: this.entryPoint,\n      rootWidget: this.rootWidget,\n    };\n  }\n\n  /**\n   * Get all errors\n   */\n  getErrors() {\n    return this.errors;\n  }\n}\n\nexport { WidgetAnalyzer };"],
  "mappings": "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",
  "names": ["getLogger", "WidgetAnalyzer", "ast", "options", "w", "error", "node", "classNode", "name", "superClass", "location", "widget", "field", "fieldName", "initialValue", "constructorMethod", "m", "method", "methodName", "methodData", "fieldRefs", "p", "body", "fields", "traverse", "key", "val", "funcNode", "func", "source", "items", "spec", "mainFunc", "mainAstNode", "n", "statements", "stmt", "call", "expr", "rootWidget", "widgetArray", "widgets", "statelessCount", "statefulCount", "stateCount"]
}
