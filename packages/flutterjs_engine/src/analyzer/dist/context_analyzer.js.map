{
  "version": 3,
  "sources": ["../src/context_analyzer.js"],
  "sourcesContent": ["/**\n * FlutterJS Context Analyzer - Phase 3\n * Detects InheritedWidget, Provider, BuildContext usage patterns\n * Analyzes context flow and SSR compatibility\n * \n * Phase 3 focuses on: Context detection, Provider patterns, SSR analysis\n * Does NOT implement actual context providers (that's Phase 4+)\n */\nimport { getLogger } from './flutterjs_logger.js';\n\nimport {  InheritedWidgetMetadata,\n  ChangeNotifierAnalysis,\n  ProviderAnalysis,\n  ContextUsagePattern, } from  './context_analyzer_data.js';\nclass ContextAnalyzer {\n  constructor(ast, widgets = [], options = {}) {\n    this.ast = ast;\n    this.widgets = widgets;\n     this.logger = getLogger().createComponentLogger('ContextAnalyzer');\n    this.options = {\n      strict: false,\n      ...options,\n    };\n\n    // Results storage\n    this.inheritedWidgets = new Map();     // name -> InheritedWidgetMetadata\n    this.changeNotifiers = new Map();      // name -> ChangeNotifierAnalysis\n    this.providers = new Map();            // type -> ProviderAnalysis\n    this.contextAccessPoints = [];         // All places context is used\n    this.inheritedWidgetGraph = {};        // Inheritance relationships\n    this.providerGraph = {};               // Provider relationships\n    this.errors = [];\n  }\n\n  /**\n   * Main entry point - analyze context patterns\n   */\n  analyze() {\n      this.logger.startSession('ContextAnalysis');\n    this.logger.trace('[ContextAnalyzer] Starting analysis...\\n');\n      this.logger.startSession('WidgetAnalyzer');\n     this.logger.trace('[ContextAnalyzer] Starting analysis...\\n');\n\n    try {\n      // Phase 1: Detect InheritedWidget classes\n      this.detectInheritedWidgets();\n       this.logger.trace(`[ContextAnalyzer] Found ${this.inheritedWidgets.size} InheritedWidgets\\n`);\n\n      // Phase 2: Detect ChangeNotifier classes\n      this.detectChangeNotifiers();\n       this.logger.trace(`[ContextAnalyzer] Found ${this.changeNotifiers.size} ChangeNotifiers\\n`);\n\n      // Phase 3: Detect Provider patterns\n      this.detectProviders();\n       this.logger.trace(`[ContextAnalyzer] Found ${this.providers.size} Providers\\n`);\n\n      // Phase 4: Find context access points\n      this.findContextAccessPoints();\n       this.logger.trace(`[ContextAnalyzer] Found ${this.contextAccessPoints.length} context usage points\\n`);\n\n      // Phase 5: Build graphs\n      this.buildInheritedWidgetGraph();\n      this.buildProviderGraph();\n       this.logger.trace('[ContextAnalyzer] Built dependency graphs\\n');\n\n      return this.getResults();\n    } catch (error) {\n      this.errors.push(error);\n      console.error('[ContextAnalyzer] Error:', error.message);\n      return this.getResults();\n    }\n  }\n\n  /**\n   * Phase 1: Detect InheritedWidget classes\n   * \n   * Looks for:\n   * - class MyProvider extends InheritedWidget\n   * - Properties: data, child\n   * - Methods: of(), updateShouldNotify()\n   */\n  detectInheritedWidgets() {\n    if (!this.ast || !this.ast.body) return;\n\n    this.ast.body.forEach((node) => {\n      if (node.type !== 'ClassDeclaration') return;\n\n      const className = node.id?.name;\n      const superClass = node.superClass?.name;\n\n      // Check if extends InheritedWidget\n      if (!superClass || !superClass.includes('InheritedWidget')) return;\n\n       this.logger.trace(`[ContextAnalyzer.detectInheritedWidgets] Found: ${className}`);\n\n      const metadata = new InheritedWidgetMetadata(\n        className,\n        node.location,\n        superClass\n      );\n\n      // Extract properties\n      if (node.body?.fields) {\n        node.body.fields.forEach((field) => {\n          const fieldName = field.key?.name;\n          metadata.properties.push({\n            name: fieldName,\n            type: this.inferType(field.initialValue),\n            required: !this.hasDefaultValue(field),\n          });\n        });\n      }\n\n      // Extract static accessors (of() method)\n      if (node.body?.methods) {\n        node.body.methods.forEach((method) => {\n          const methodName = method.key?.name;\n\n          // Check for static accessor pattern\n          if (methodName === 'of' && this.isStaticAccessor(method)) {\n            metadata.staticAccessors.push({\n              name: methodName,\n              signature: `static ${methodName}(BuildContext context)`,\n              usesInheritedWidgetLookup: this.checksInheritedWidgetLookup(method),\n              location: method.location,\n            });\n          }\n\n          // Check for updateShouldNotify\n          if (methodName === 'updateShouldNotify') {\n            metadata.updateShouldNotifyImplemented = true;\n          }\n        });\n      }\n\n      this.inheritedWidgets.set(className, metadata);\n    });\n  }\n\n  /**\n   * Check if method is static (phase 3 simplified - assumes 'of' is usually static)\n   */\n  isStaticAccessor(method) {\n    // In a real implementation, check for @static decorator or static keyword\n    return method.key?.name === 'of';\n  }\n\n  /**\n   * Check if method body contains dependOnInheritedWidgetOfExactType call\n   */\n  checksInheritedWidgetLookup(method) {\n    if (!method.body) return false;\n\n    const code = JSON.stringify(method.body);\n    return code.includes('dependOnInheritedWidgetOfExactType') ||\n           code.includes('inheritedWidgetOfExactType');\n  }\n\n  /**\n   * Phase 2: Detect ChangeNotifier classes\n   * \n   * Looks for:\n   * - class MyNotifier extends ChangeNotifier\n   * - Methods that call notifyListeners()\n   * - Properties that get/set\n   */\n  detectChangeNotifiers() {\n    if (!this.ast || !this.ast.body) return;\n\n    this.ast.body.forEach((node) => {\n      if (node.type !== 'ClassDeclaration') return;\n\n      const className = node.id?.name;\n      const superClass = node.superClass?.name;\n\n      // Check if extends ChangeNotifier\n      if (!superClass || superClass !== 'ChangeNotifier') return;\n\n       this.logger.trace(`[ContextAnalyzer.detectChangeNotifiers] Found: ${className}`);\n\n      const analysis = new ChangeNotifierAnalysis(\n        className,\n        node.location\n      );\n\n      // Extract properties\n      if (node.body?.fields) {\n        node.body.fields.forEach((field) => {\n          const fieldName = field.key?.name;\n          analysis.properties.push({\n            name: fieldName,\n            type: this.inferType(field.initialValue),\n            initialValue: this.expressionToString(field.initialValue),\n          });\n        });\n      }\n\n      // Extract getters, methods, and notifyListeners calls\n      if (node.body?.methods) {\n        node.body.methods.forEach((method) => {\n          const methodName = method.key?.name;\n\n          // Check for getter pattern (get count => _count)\n          if (methodName && !method.params?.length && method.body) {\n            const isGetter = JSON.stringify(method).includes('return');\n            if (isGetter) {\n              analysis.getters.push({\n                name: methodName,\n                returnType: this.inferReturnType(method.body),\n                location: method.location,\n              });\n            }\n          }\n\n          // Check for notifyListeners call\n          const callsNotify = this.callsNotifyListeners(method.body);\n          if (callsNotify || methodName === 'increment' || methodName === 'decrement') {\n            const mutations = this.extractMutationsInMethod(method.body);\n            analysis.methods.push({\n              name: methodName,\n              callsNotifyListeners: callsNotify,\n              location: method.location,\n              mutations: mutations,\n            });\n          }\n        });\n      }\n\n      this.changeNotifiers.set(className, analysis);\n    });\n  }\n\n  /**\n   * Check if method calls notifyListeners()\n   */\n  callsNotifyListeners(body) {\n    if (!body) return false;\n    const code = JSON.stringify(body);\n    return code.includes('notifyListeners');\n  }\n\n  /**\n   * Extract field mutations in method (this._field = x, this._field++, etc.)\n   */\n  extractMutationsInMethod(body) {\n    const mutations = [];\n    if (!body) return mutations;\n\n    const code = JSON.stringify(body);\n    \n    // Simple pattern matching for mutations\n    const patterns = [\n      /this\\._(\\w+)\\s*[=+\\-*]/g,  // this._field = or +=, -=, etc.\n      /this\\.(\\w+)\\s*[=+\\-*]/g,   // this.field = or +=, -=, etc.\n    ];\n\n    patterns.forEach((pattern) => {\n      let match;\n      while ((match = pattern.exec(code)) !== null) {\n        mutations.push(match[1]);\n      }\n    });\n\n    return [...new Set(mutations)]; // Remove duplicates\n  }\n\n  /**\n   * Phase 3: Detect Provider<T> patterns\n   * \n   * Looks for:\n   * - Provider<CounterNotifier>(create: ..., child: ...)\n   * - Detects consumer patterns: context.watch(), context.read()\n   */\n  detectProviders() {\n    if (!this.ast || !this.ast.body) return;\n\n    this.ast.body.forEach((node) => {\n      if (node.type === 'ClassDeclaration') {\n        // Check if class contains Provider creation in build()\n        const buildMethod = node.body?.methods?.find((m) => m.key?.name === 'build');\n        if (buildMethod) {\n          this.findProvidersInMethod(buildMethod, node);\n        }\n      }\n\n      // Also check in function bodies\n      if (node.type === 'FunctionDeclaration') {\n        this.findProvidersInMethod(node, null);\n      }\n    });\n  }\n\n  /**\n   * Find Provider instantiations in a method\n   */\n  findProvidersInMethod(method, classNode) {\n    if (!method.body) return;\n\n    const body = method.body.type === 'BlockStatement' ? method.body.body : [method.body];\n\n    body.forEach((stmt) => {\n      this.findProvidersInStatement(stmt);\n    });\n  }\n\n  /**\n   * Recursively find Provider patterns in statements\n   */\n  findProvidersInStatement(stmt) {\n    if (!stmt) return;\n\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n      this.findProvidersInExpression(stmt.expression);\n    }\n\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\n      this.findProvidersInExpression(stmt.argument);\n    }\n\n    if (stmt.type === 'BlockStatement' && stmt.body) {\n      stmt.body.forEach((s) => this.findProvidersInStatement(s));\n    }\n  }\n\n  /**\n   * Find Provider patterns in expressions\n   * Looks for: new Provider<CounterNotifier>(...)\n   */\n  findProvidersInExpression(expr) {\n    if (!expr) return;\n\n    // Check for NewExpression: new Provider<T>(...)\n    if (expr.type === 'NewExpression') {\n      const calleeName = expr.callee?.name;\n\n      if (calleeName === 'Provider' || calleeName?.startsWith('Provider')) {\n        // Extract generic type: Provider<CounterNotifier>\n        const genericType = this.extractGenericType(expr);\n\n        if (genericType) {\n           this.logger.trace(`[ContextAnalyzer.detectProviders] Found Provider<${genericType}>`);\n\n          const analysis = new ProviderAnalysis(\n            `Provider<${genericType}>`,\n            expr.location,\n            genericType\n          );\n\n          // Extract create function\n          if (expr.args) {\n            expr.args.forEach((arg) => {\n              if (arg.type === 'ObjectLiteral') {\n                arg.properties?.forEach((prop) => {\n                  if (prop.key?.name === 'create') {\n                    analysis.createFunction = this.expressionToString(prop.value);\n                  }\n                  if (prop.key?.name === 'child') {\n                    // Child widget - may use this provider\n                  }\n                });\n              }\n            });\n          }\n\n          // Identify access patterns (watch, read, select)\n          this.identifyAccessPatterns(genericType, analysis);\n\n          this.providers.set(`Provider<${genericType}>`, analysis);\n        }\n      }\n    }\n\n    // Check call expressions\n    if (expr.type === 'CallExpression' && expr.args) {\n      expr.args.forEach((arg) => {\n        this.findProvidersInExpression(arg);\n      });\n    }\n\n    // Check object literals\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\n      expr.properties.forEach((prop) => {\n        this.findProvidersInExpression(prop.value);\n      });\n    }\n  }\n\n  /**\n   * Extract generic type from Provider<T>\n   * In simplified version, returns T or null\n   */\n  extractGenericType(expr) {\n    // In real implementation, parse the full generic syntax\n    // For now, look for the callee name pattern\n    const code = JSON.stringify(expr.callee);\n\n    // Simple heuristic: if it mentions Provider and contains type info\n    if (code.includes('Provider')) {\n      // Try to find type in expression string representation\n      const exprStr = this.expressionToString(expr.callee);\n      const match = exprStr.match(/Provider<(\\w+)>/);\n      return match ? match[1] : null;\n    }\n\n    return null;\n  }\n\n  /**\n   * Identify how this provider is consumed\n   */\n  identifyAccessPatterns(providerType, analysis) {\n    if (!this.ast || !this.ast.body) return;\n\n    // Search for context.watch(), context.read(), context.select()\n    this.ast.body.forEach((node) => {\n      if (node.type === 'ClassDeclaration') {\n        const buildMethod = node.body?.methods?.find((m) => m.key?.name === 'build');\n        if (buildMethod) {\n          this.scanForAccessPatterns(buildMethod, providerType, analysis);\n        }\n      }\n    });\n  }\n\n  /**\n   * Scan method for watch/read/select patterns\n   */\n  scanForAccessPatterns(method, providerType, analysis) {\n    if (!method.body) return;\n\n    const code = JSON.stringify(method.body);\n\n    // Check for access patterns\n    if (code.includes('context.watch')) {\n      analysis.accessPatterns.push('watch');\n    }\n    if (code.includes('context.read')) {\n      analysis.accessPatterns.push('read');\n    }\n    if (code.includes('context.select')) {\n      analysis.accessPatterns.push('select');\n    }\n\n    // Find consumer widgets\n    if (code.includes('Consumer')) {\n      analysis.accessPatterns.push('Consumer');\n    }\n  }\n\n  /**\n   * Phase 4: Find all context access points\n   * \n   * Maps:\n   * - Which widgets use context\n   * - How they access it (context.theme(), context.mediaQuery(), etc.)\n   * - SSR compatibility\n   */\n  findContextAccessPoints() {\n    if (!this.ast || !this.ast.body) return;\n\n    this.ast.body.forEach((node) => {\n      if (node.type !== 'ClassDeclaration') return;\n\n      const className = node.id?.name;\n      const buildMethod = node.body?.methods?.find((m) => m.key?.name === 'build');\n\n      if (buildMethod) {\n        const usagePoints = this.extractContextUsageInMethod(buildMethod, className);\n        this.contextAccessPoints.push(...usagePoints);\n      }\n    });\n  }\n\n  /**\n   * Extract all context.X() calls in a method\n   */\n  extractContextUsageInMethod(method, className) {\n    const usages = [];\n\n    if (!method.body) return usages;\n\n    const stmts = method.body.type === 'BlockStatement' ? method.body.body : [method.body];\n\n    stmts.forEach((stmt) => {\n      const foundUsages = this.findContextUsageInStatement(stmt, className);\n      usages.push(...foundUsages);\n    });\n\n    return usages;\n  }\n\n  /**\n   * Recursively find context usage patterns\n   */\n  findContextUsageInStatement(stmt, className) {\n    const usages = [];\n\n    if (!stmt) return usages;\n\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n      const stmtUsages = this.findContextUsageInExpression(stmt.expression, className);\n      usages.push(...stmtUsages);\n    }\n\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\n      const retUsages = this.findContextUsageInExpression(stmt.argument, className);\n      usages.push(...retUsages);\n    }\n\n    if (stmt.type === 'BlockStatement' && stmt.body) {\n      stmt.body.forEach((s) => {\n        const blockUsages = this.findContextUsageInStatement(s, className);\n        usages.push(...blockUsages);\n      });\n    }\n\n    return usages;\n  }\n\n  /**\n   * Find context usage in expressions\n   * Looks for: Theme.of(context), context.watch(), context.read(), etc.\n   */\n  findContextUsageInExpression(expr, className) {\n    const usages = [];\n\n    if (!expr) return usages;\n\n    const exprStr = JSON.stringify(expr);\n\n    // Pattern 1: Theme.of(context)\n    if (exprStr.includes('Theme.of') && exprStr.includes('context')) {\n      usages.push(new ContextUsagePattern(\n        'Theme.of(context)',\n        'inherited-widget-lookup',\n        expr.location,\n        'ThemeData',\n        true,\n        'Pure value access, no subscription required'\n      ));\n    }\n\n    // Pattern 2: context.theme()\n    if (exprStr.includes('context.theme')) {\n      usages.push(new ContextUsagePattern(\n        'context.theme()',\n        'context-service',\n        expr.location,\n        'ThemeData',\n        true,\n        'Service access during build'\n      ));\n    }\n\n    // Pattern 3: context.watch<T>()\n    if (exprStr.includes('context.watch')) {\n      usages.push(new ContextUsagePattern(\n        'context.watch<T>()',\n        'provider-watch',\n        expr.location,\n        'T',\n        false,\n        'Requires reactive subscription - not SSR safe'\n      ));\n    }\n\n    // Pattern 4: context.read<T>()\n    if (exprStr.includes('context.read')) {\n      usages.push(new ContextUsagePattern(\n        'context.read<T>()',\n        'provider-read',\n        expr.location,\n        'T',\n        true,\n        'Single read at render time - SSR safe'\n      ));\n    }\n\n    // Pattern 5: context.mediaQuery()\n    if (exprStr.includes('context.mediaQuery') || exprStr.includes('MediaQuery.of')) {\n      usages.push(new ContextUsagePattern(\n        'context.mediaQuery()',\n        'context-service',\n        expr.location,\n        'MediaQueryData',\n        true,\n        'Read-only responsive info'\n      ));\n    }\n\n    // Pattern 6: State mutations in handlers\n    if (exprStr.includes('notifyListeners') || exprStr.includes('increment')) {\n      usages.push(new ContextUsagePattern(\n        'notifyListeners()',\n        'global-state-mutation',\n        expr.location,\n        'void',\n        false,\n        'Mutations do not trigger re-render in SSR'\n      ));\n    }\n\n    // Recursively search nested expressions\n    if (expr.type === 'CallExpression' && expr.args) {\n      expr.args.forEach((arg) => {\n        const argUsages = this.findContextUsageInExpression(arg, className);\n        usages.push(...argUsages);\n      });\n    }\n\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\n      expr.properties.forEach((prop) => {\n        const propUsages = this.findContextUsageInExpression(prop.value, className);\n        usages.push(...propUsages);\n      });\n    }\n\n    if (expr.type === 'MemberExpression') {\n      const memberUsages = this.findContextUsageInExpression(expr.object, className);\n      usages.push(...memberUsages);\n    }\n\n    return usages;\n  }\n\n  /**\n   * Phase 5a: Build InheritedWidget graph\n   * Maps provider -> consumer relationships\n   */\n  buildInheritedWidgetGraph() {\n    this.inheritedWidgets.forEach((widget) => {\n      this.inheritedWidgetGraph[widget.name] = {\n        providedBy: this.findWhoProvides(widget.name),\n        consumedBy: this.findWhoConsumes(widget.name),\n        providedValue: widget.properties[0]?.type || 'unknown',\n        flowPath: this.traceContextFlow(widget.name),\n      };\n    });\n  }\n\n  /**\n   * Phase 5b: Build Provider graph\n   * Maps provider -> consumer relationships\n   */\n  buildProviderGraph() {\n    this.providers.forEach((provider) => {\n      const key = provider.providerType;\n      this.providerGraph[key] = {\n        providedBy: this.findWhoCreatesProvider(provider.providerType),\n        providedType: provider.valueType,\n        consumedBy: this.findWhoConsumesProvider(provider.providerType),\n        accessPatterns: provider.accessPatterns,\n        flowPath: this.traceProviderFlow(provider.providerType),\n      };\n    });\n  }\n\n  /**\n   * Find which widget provides this inherited widget\n   */\n  findWhoProvides(widgetName) {\n    // Simplified: return widget name of class that instantiates it\n    // In real implementation, search AST for instantiation\n    return 'MyApp';\n  }\n\n  /**\n   * Find which widgets consume this inherited widget\n   */\n  findWhoConsumes(widgetName) {\n    const consumers = [];\n    // Search for calls to widgetName.of()\n    this.contextAccessPoints.forEach((usage) => {\n      if (usage.pattern.includes(widgetName)) {\n        consumers.push(usage.dependent);\n      }\n    });\n    return consumers;\n  }\n\n  /**\n   * Find where this inherited widget's context flows\n   */\n  traceContextFlow(widgetName) {\n    // Simplified path tracing\n    return `${this.findWhoProvides(widgetName)} -> ${widgetName} -> ${this.findWhoConsumes(widgetName).join(', ')}`;\n  }\n\n  /**\n   * Find who creates this provider\n   */\n  findWhoCreatesProvider(providerType) {\n    // Simplified: return app root\n    return 'MyApp';\n  }\n\n  /**\n   * Find who consumes this provider\n   */\n  findWhoConsumesProvider(providerType) {\n    const consumers = [];\n    this.contextAccessPoints.forEach((usage) => {\n      if (usage.pattern.includes('watch') || usage.pattern.includes('read')) {\n        consumers.push(usage.dependent);\n      }\n    });\n    return consumers;\n  }\n\n  /**\n   * Find provider flow path through widget tree\n   */\n  traceProviderFlow(providerType) {\n    return `MyApp -> Provider -> MaterialApp -> [consumers]`;\n  }\n\n  /**\n   * Helper: Infer type from expression\n   */\n  inferType(expr) {\n    if (!expr) return 'any';\n    if (expr.type === 'Literal') {\n      const val = expr.value;\n      if (typeof val === 'string') return 'string';\n      if (typeof val === 'number') return 'number';\n      if (typeof val === 'boolean') return 'boolean';\n    }\n    return 'any';\n  }\n\n  /**\n   * Helper: Infer return type from method body\n   */\n  inferReturnType(body) {\n    // Simplified\n    return 'any';\n  }\n\n  /**\n   * Helper: Check if field has default value\n   */\n  hasDefaultValue(field) {\n    return field.initialValue !== null && field.initialValue !== undefined;\n  }\n\n  /**\n   * Helper: Convert expression to string\n   */\n  expressionToString(expr) {\n    if (!expr) return 'null';\n    if (expr.type === 'Identifier') return expr.name;\n    if (expr.type === 'Literal') return String(expr.value);\n    return JSON.stringify(expr).substring(0, 50);\n  }\n\n  /**\n   * Get analysis results\n   */\n  getResults() {\n    return {\n      inheritedWidgets: Array.from(this.inheritedWidgets.values()),\n      changeNotifiers: Array.from(this.changeNotifiers.values()),\n      providers: Array.from(this.providers.values()),\n      contextAccessPoints: this.contextAccessPoints,\n      inheritedWidgetGraph: this.inheritedWidgetGraph,\n      providerGraph: this.providerGraph,\n      errors: this.errors,\n    };\n  }\n}\n\nexport { ContextAnalyzer };\n"],
  "mappings": "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",
  "names": ["getLogger", "InheritedWidgetMetadata", "ChangeNotifierAnalysis", "ProviderAnalysis", "ContextUsagePattern", "ContextAnalyzer", "ast", "widgets", "options", "error", "node", "className", "superClass", "metadata", "field", "fieldName", "method", "methodName", "code", "analysis", "callsNotify", "mutations", "body", "pattern", "match", "buildMethod", "m", "classNode", "stmt", "s", "expr", "calleeName", "genericType", "arg", "prop", "providerType", "usagePoints", "usages", "foundUsages", "stmtUsages", "retUsages", "blockUsages", "exprStr", "argUsages", "propUsages", "memberUsages", "widget", "provider", "key", "widgetName", "consumers", "usage", "val"]
}
