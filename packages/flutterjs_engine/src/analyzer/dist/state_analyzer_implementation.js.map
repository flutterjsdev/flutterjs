{
  "version": 3,
  "sources": ["../src/state_analyzer_implementation.js"],
  "sourcesContent": ["/**\n * FlutterJS State Analyzer\n * Phase 2 Implementation\n * \n * Extracts state management information from StatefulWidget/State classes\n * No external dependencies - pure Node.js\n */\n\n// ============================================================================\n// STATE ANALYZER CLASS\n// ============================================================================\n\nclass StateAnalyzer {\n  constructor(ast, widgets, options = {}) {\n    this.ast = ast;\n    this.widgets = widgets; // from Phase 1 WidgetAnalyzer\n    this.options = {\n      strict: false,\n      ...options,\n    };\n\n    // Results storage\n    this.stateClasses = new Map();\n    this.stateFields = new Map();\n    this.setStateCalls = [];\n    this.lifecycleMethods = [];\n    this.eventHandlers = [];\n    this.dependencyGraph = null;\n    this.validationResults = [];\n    this.errors = [];\n  }\n\n  /**\n   * Main entry point - analyze all state-related code\n   */\n  analyze() {\n    if (!this.ast || !this.ast.body) {\n      throw new Error('Invalid AST provided');\n    }\n\n    try {\n      // Phase 1: Find and link StatefulWidget/State pairs\n      this.linkStatefulToState();\n\n      // Phase 2: Extract state fields from State classes\n      this.extractStateFields();\n\n      // Phase 3: Find setState calls\n      this.findSetStateCalls();\n\n      // Phase 4: Extract lifecycle methods\n      this.extractLifecycleMethods();\n\n      // Phase 5: Extract event handlers\n      this.extractEventHandlers();\n\n      // Phase 6: Build dependency graph\n      this.buildDependencyGraph();\n\n      // Phase 7: Validate everything\n      this.validateState();\n\n      return this.getResults();\n    } catch (error) {\n      this.errors.push(error);\n      return this.getResults();\n    }\n  }\n\n  /**\n   * Phase 1: Link StatefulWidget to State class\n   * \n   * StatefulWidget.createState() returns State class instance\n   * We need to find the return value and match it with State class\n   */\n  linkStatefulToState() {\n    this.widgets.forEach((widget) => {\n      if (widget.type !== 'stateful') return;\n\n      // Find the createState method\n      const createStateMethod = widget.methods.find(\n        (m) => m.name === 'createState'\n      );\n\n      if (!createStateMethod) {\n        this.errors.push({\n          type: 'missing-create-state',\n          widget: widget.name,\n          message: `StatefulWidget \"${widget.name}\" has no createState() method`,\n        });\n        return;\n      }\n\n      // Find the corresponding class declaration in AST\n      const widgetNode = this.ast.body.find(\n        (n) => n.type === 'ClassDeclaration' && n.id.name === widget.name\n      );\n\n      if (!widgetNode) return;\n\n      // Find what createState returns\n      const createStateNode = widgetNode.body.methods.find(\n        (m) => m.key.name === 'createState'\n      );\n\n      if (!createStateNode) return;\n\n      // Extract the returned State class name\n      const stateClassName = this.extractReturnedClassName(createStateNode.body);\n\n      if (!stateClassName) {\n        this.errors.push({\n          type: 'cannot-parse-create-state',\n          widget: widget.name,\n          message: `Cannot determine which State class is returned by ${widget.name}.createState()`,\n        });\n        return;\n      }\n\n      // Find the State class\n      const stateClassNode = this.ast.body.find(\n        (n) => n.type === 'ClassDeclaration' && n.id.name === stateClassName\n      );\n\n      if (!stateClassNode) {\n        this.errors.push({\n          type: 'missing-state-class',\n          widget: widget.name,\n          stateClass: stateClassName,\n          message: `State class \"${stateClassName}\" not found`,\n        });\n        return;\n      }\n\n      // Check if it extends State<Widget>\n      if (!stateClassNode.superClass || !stateClassNode.superClass.name.startsWith('State')) {\n        this.errors.push({\n          type: 'invalid-state-class',\n          stateClass: stateClassName,\n          message: `Class \"${stateClassName}\" does not extend State`,\n        });\n        return;\n      }\n\n      // Create StateClassMetadata\n      const stateMetadata = new StateClassMetadata(\n        stateClassName,\n        stateClassNode.location,\n        widget.name\n      );\n\n      this.stateClasses.set(stateClassName, {\n        astNode: stateClassNode,\n        metadata: stateMetadata,\n      });\n\n      // Link bidirectional\n      widget.linkedStateClass = stateClassName;\n    });\n  }\n\n  /**\n   * Extract the class name returned from a method\n   * Looks for: return new ClassName(); or return new ClassName();\n   */\n  extractReturnedClassName(methodBody) {\n    if (!methodBody) return null;\n\n    // Handle BlockStatement: { return new ClassName(); }\n    if (methodBody.type === 'BlockStatement' && methodBody.body) {\n      for (const stmt of methodBody.body) {\n        if (stmt.type === 'ReturnStatement' && stmt.argument) {\n          const className = this.getClassNameFromExpression(stmt.argument);\n          if (className) return className;\n        }\n      }\n    }\n\n    // Handle direct expression: return new ClassName();\n    if (methodBody.type === 'NewExpression') {\n      return methodBody.callee.name;\n    }\n\n    return null;\n  }\n\n  /**\n   * Extract class name from expression (new ClassName or ClassName)\n   */\n  getClassNameFromExpression(expr) {\n    if (!expr) return null;\n\n    if (expr.type === 'NewExpression' && expr.callee) {\n      return expr.callee.name;\n    }\n\n    if (expr.type === 'Identifier') {\n      return expr.name;\n    }\n\n    if (expr.type === 'CallExpression' && expr.callee) {\n      if (expr.callee.type === 'Identifier') {\n        return expr.callee.name;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Phase 2: Extract state fields from State classes\n   * \n   * State fields are class properties that can be mutated\n   * Examples: _count = 0, _isLoading = false\n   */\n  extractStateFields() {\n    this.stateClasses.forEach(({ astNode, metadata }) => {\n      if (!astNode.body || !astNode.body.fields) return;\n\n      astNode.body.fields.forEach((field) => {\n        const fieldName = field.key.name;\n        const initialValue = field.initialValue;\n\n        // Infer type from initial value\n        const type = this.inferFieldType(initialValue);\n\n        const stateField = new StateField(\n          fieldName,\n          type,\n          this.expressionToValue(initialValue),\n          initialValue ? initialValue.location : field.location\n        );\n\n        // Track in global map and in metadata\n        this.stateFields.set(`${metadata.name}.${fieldName}`, stateField);\n        metadata.stateFields.push(stateField);\n      });\n    });\n  }\n\n  /**\n   * Infer field type from initial value expression\n   */\n  inferFieldType(expr) {\n    if (!expr) return 'any';\n\n    if (expr.type === 'Literal') {\n      if (typeof expr.value === 'number') return 'number';\n      if (typeof expr.value === 'string') return 'string';\n      if (typeof expr.value === 'boolean') return 'boolean';\n      if (expr.value === null) return 'null';\n    }\n\n    if (expr.type === 'Identifier') {\n      const name = expr.name;\n      if (name === 'true' || name === 'false') return 'boolean';\n      if (name === 'null') return 'null';\n      if (name === 'undefined') return 'undefined';\n    }\n\n    // Array literal\n    if (expr.type === 'ArrayLiteral') return 'array';\n\n    // Object literal\n    if (expr.type === 'ObjectLiteral') return 'object';\n\n    // Function call - unknown return type\n    if (expr.type === 'CallExpression') return 'any';\n\n    return 'any';\n  }\n\n  /**\n   * Convert expression to actual value (for initialization)\n   */\n  expressionToValue(expr) {\n    if (!expr) return undefined;\n\n    if (expr.type === 'Literal') {\n      return expr.value;\n    }\n\n    if (expr.type === 'Identifier') {\n      const name = expr.name;\n      if (name === 'true') return true;\n      if (name === 'false') return false;\n      if (name === 'null') return null;\n      if (name === 'undefined') return undefined;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Phase 3: Find all setState() calls\n   */\n  findSetStateCalls() {\n    this.stateClasses.forEach(({ astNode, metadata }) => {\n      if (!astNode.body || !astNode.body.methods) return;\n\n      // Search all methods for setState calls\n      astNode.body.methods.forEach((method) => {\n        const setStateCalls = this.findSetStateInMethod(method, metadata.name);\n        this.setStateCalls.push(...setStateCalls);\n      });\n    });\n  }\n\n  /**\n   * Find setState calls within a method\n   */\n  findSetStateInMethod(method, stateClassName) {\n    const calls = [];\n    const methodName = method.key.name;\n\n    // Search method body for setState calls\n    if (method.body) {\n      const stmts = method.body.type === 'BlockStatement'\n        ? method.body.body\n        : [method.body];\n\n      stmts.forEach((stmt) => {\n        this.findSetStateInStatement(stmt, calls, methodName, stateClassName);\n      });\n    }\n\n    return calls;\n  }\n\n  /**\n   * Recursively find setState in statements\n   */\n  findSetStateInStatement(stmt, calls, methodName, stateClassName) {\n    if (!stmt) return;\n\n    // Handle expression statements\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n      this.findSetStateInExpression(stmt.expression, calls, methodName, stateClassName);\n    }\n\n    // Handle return statements\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\n      this.findSetStateInExpression(stmt.argument, calls, methodName, stateClassName);\n    }\n\n    // Handle blocks\n    if (stmt.type === 'BlockStatement' && stmt.body) {\n      stmt.body.forEach((s) => {\n        this.findSetStateInStatement(s, calls, methodName, stateClassName);\n      });\n    }\n  }\n\n  /**\n   * Find setState in expression tree\n   */\n  findSetStateInExpression(expr, calls, methodName, stateClassName) {\n    if (!expr) return;\n\n    // Check if this is a setState call: this.setState(callback)\n    if (expr.type === 'CallExpression') {\n      // Check if it's this.setState(...)\n      const isSetState = this.isSetStateCall(expr);\n\n      if (isSetState) {\n        const updatedFields = this.extractSetStateUpdates(expr, stateClassName);\n        const call = new StateUpdateCall(\n          expr.location,\n          methodName,\n          updatedFields,\n          stateClassName\n        );\n        calls.push(call);\n      }\n\n      // Also check arguments for nested setState calls\n      expr.args.forEach((arg) => {\n        this.findSetStateInExpression(arg, calls, methodName, stateClassName);\n      });\n    }\n\n    // Recursively check nested expressions\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\n      expr.properties.forEach((prop) => {\n        this.findSetStateInExpression(prop.value, calls, methodName, stateClassName);\n      });\n    }\n  }\n\n  /**\n   * Check if expression is this.setState(...)\n   */\n  isSetStateCall(expr) {\n    if (expr.type !== 'CallExpression') return false;\n    if (!expr.callee) return false;\n\n    // Check for member expression: this.setState\n    if (expr.callee.type === 'MemberExpression') {\n      const obj = expr.callee.object;\n      const prop = expr.callee.property;\n\n      // this.setState\n      if (obj.type === 'Identifier' && obj.name === 'this' &&\n        prop.type === 'Identifier' && prop.name === 'setState') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Extract which state fields are updated in setState\n   * setState(() => { this._count++; })\n   */\n  extractSetStateUpdates(setStateCall, stateClassName) {\n    const updated = [];\n\n    if (!setStateCall.args || setStateCall.args.length === 0) return updated;\n\n    // First argument is the callback: () => { ... }\n    const callback = setStateCall.args[0];\n\n    if (callback.type === 'ArrowFunctionExpression') {\n      // Extract body\n      const body = callback.body;\n\n      if (body.type === 'BlockStatement' && body.body) {\n        // Search for field mutations: this._field = value, this._field++, etc.\n        body.body.forEach((stmt) => {\n          const mutated = this.extractMutatedFields(stmt, stateClassName);\n          updated.push(...mutated);\n        });\n      } else if (body.type === 'UpdateExpression' || body.type === 'AssignmentExpression') {\n        // Direct mutation in arrow body\n        const mutated = this.extractMutatedFields(body, stateClassName);\n        updated.push(...mutated);\n      }\n    }\n\n    return [...new Set(updated)]; // Remove duplicates\n  }\n\n  /**\n   * Extract mutated fields from statement\n   * Looks for: this._field = x, this._field++, this._field += x\n   */\n  extractMutatedFields(stmt, stateClassName) {\n    const fields = [];\n\n    if (!stmt) return fields;\n\n    // Assignment: this._field = value\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n      const expr = stmt.expression;\n\n      if (expr.type === 'AssignmentExpression') {\n        const fieldName = this.getFieldNameFromTarget(expr.left);\n        if (fieldName) fields.push(fieldName);\n      }\n\n      // Update expression: this._field++, this._field--\n      if (expr.type === 'UpdateExpression') {\n        const fieldName = this.getFieldNameFromTarget(expr.argument);\n        if (fieldName) fields.push(fieldName);\n      }\n    }\n\n    // Direct assignment/update (arrow body)\n    if (stmt.type === 'AssignmentExpression') {\n      const fieldName = this.getFieldNameFromTarget(stmt.left);\n      if (fieldName) fields.push(fieldName);\n    }\n\n    if (stmt.type === 'UpdateExpression') {\n      const fieldName = this.getFieldNameFromTarget(stmt.argument);\n      if (fieldName) fields.push(fieldName);\n    }\n\n    return fields;\n  }\n\n  /**\n   * Get field name from assignment target\n   * Handles: this._field, obj.field, etc.\n   */\n  getFieldNameFromTarget(target) {\n    if (!target) return null;\n\n    // this._field\n    if (target.type === 'MemberExpression') {\n      const obj = target.object;\n      const prop = target.property;\n\n      // this._field\n      if (obj.type === 'Identifier' && obj.name === 'this' &&\n        prop.type === 'Identifier') {\n        return prop.name;\n      }\n    }\n\n    // _field (direct identifier)\n    if (target.type === 'Identifier') {\n      return target.name;\n    }\n\n    return null;\n  }\n\n  /**\n   * Phase 4: Extract lifecycle methods\n   * \n   * Lifecycle methods: initState, dispose, didUpdateWidget, build\n   */\n  extractLifecycleMethods() {\n    const lifecycleNames = ['initState', 'dispose', 'didUpdateWidget', 'build'];\n\n    this.stateClasses.forEach(({ astNode, metadata }) => {\n      if (!astNode.body || !astNode.body.methods) return;\n\n      astNode.body.methods.forEach((method) => {\n        const methodName = method.key.name;\n\n        if (lifecycleNames.includes(methodName)) {\n          const lifecycle = new LifecycleMethod(\n            methodName,\n            method.location,\n            method.params || [],\n            this.checkCallsSuper(method),\n            this.checkHasSideEffects(method)\n          );\n\n          this.lifecycleMethods.push(lifecycle);\n          metadata.lifecycleMethods.push(lifecycle);\n        }\n      });\n    });\n  }\n\n  /**\n   * Check if method calls super.methodName()\n   */\n  checkCallsSuper(method) {\n    if (!method.body) return false;\n\n    const stmts = method.body.type === 'BlockStatement'\n      ? method.body.body\n      : [method.body];\n\n    for (const stmt of stmts) {\n      if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n        const expr = stmt.expression;\n\n        // super.initState() pattern\n        if (expr.type === 'CallExpression' && expr.callee.type === 'MemberExpression') {\n          const obj = expr.callee.object;\n          const prop = expr.callee.property;\n\n          if (obj.type === 'Identifier' && obj.name === 'super' &&\n            prop.type === 'Identifier' && prop.name === method.key.name) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if method has side effects (console.log, assignments, etc.)\n   */\n  checkHasSideEffects(method) {\n    if (!method.body) return false;\n\n    const stmts = method.body.type === 'BlockStatement'\n      ? method.body.body\n      : [method.body];\n\n    for (const stmt of stmts) {\n      // Assignment has side effect\n      if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n        const expr = stmt.expression;\n\n        if (expr.type === 'AssignmentExpression' || expr.type === 'UpdateExpression') {\n          return true;\n        }\n\n        // Function calls might have side effects\n        if (expr.type === 'CallExpression') {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Phase 5: Extract event handlers from build method\n   * \n   * Looks for: onPressed: () => handler(), onChange: handler, etc.\n   */\n  extractEventHandlers() {\n    this.stateClasses.forEach(({ astNode, metadata }) => {\n      if (!astNode.body || !astNode.body.methods) return;\n\n      // Find build method\n      const buildMethod = astNode.body.methods.find((m) => m.key.name === 'build');\n      if (!buildMethod) return;\n\n      // Extract event handlers from the build method body\n      const handlers = this.findEventHandlersInMethod(buildMethod, metadata.name);\n      this.eventHandlers.push(...handlers);\n    });\n  }\n\n  /**\n   * Find event handlers in method body\n   */\n  findEventHandlersInMethod(method, stateClassName) {\n    const handlers = [];\n\n    if (!method.body) return handlers;\n\n    const stmts = method.body.type === 'BlockStatement'\n      ? method.body.body\n      : [method.body];\n\n    stmts.forEach((stmt) => {\n      this.findEventHandlersInStatement(stmt, handlers, stateClassName);\n    });\n\n    return handlers;\n  }\n\n  /**\n   * Recursively find event handlers in statements\n   */\n  findEventHandlersInStatement(stmt, handlers, stateClassName) {\n    if (!stmt) return;\n\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\n      this.findEventHandlersInExpression(stmt.expression, handlers, stateClassName);\n    }\n\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\n      this.findEventHandlersInExpression(stmt.argument, handlers, stateClassName);\n    }\n\n    if (stmt.type === 'BlockStatement' && stmt.body) {\n      stmt.body.forEach((s) => {\n        this.findEventHandlersInStatement(s, handlers, stateClassName);\n      });\n    }\n  }\n\n  /**\n   * Find event handlers in expressions\n   * Looks for: { onPressed: () => handler(), onChange: handler }\n   */\n  findEventHandlersInExpression(expr, handlers, stateClassName) {\n    if (!expr) return;\n\n    // Check object literals for event properties\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\n      expr.properties.forEach((prop) => {\n        // Property key is the event name (onPressed, onChange, etc.)\n        const eventName = this.getPropertyKey(prop.key);\n        const eventPattern = /^on[A-Z]/; // onPressed, onChange, etc.\n\n        if (eventPattern.test(eventName)) {\n          // Extract handler from property value\n          const handler = this.extractEventHandler(prop.value, stateClassName);\n\n          if (handler) {\n            handlers.push({\n              event: eventName,\n              handler: handler,\n              location: prop.location,\n              component: this.getComponentNameFromContext(expr),\n            });\n          }\n        }\n\n        // Also search nested values\n        this.findEventHandlersInExpression(prop.value, handlers, stateClassName);\n      });\n    }\n\n    // Check call expressions (widget calls)\n    if (expr.type === 'CallExpression' && expr.args) {\n      expr.args.forEach((arg) => {\n        this.findEventHandlersInExpression(arg, handlers, stateClassName);\n      });\n    }\n\n    // Check new expressions\n    if (expr.type === 'NewExpression' && expr.args) {\n      expr.args.forEach((arg) => {\n        this.findEventHandlersInExpression(arg, handlers, stateClassName);\n      });\n    }\n  }\n\n  /**\n   * Get property key from object property\n   */\n  getPropertyKey(keyExpr) {\n    if (!keyExpr) return null;\n\n    if (keyExpr.type === 'Identifier') {\n      return keyExpr.name;\n    }\n\n    if (keyExpr.type === 'Literal') {\n      return String(keyExpr.value);\n    }\n\n    return null;\n  }\n\n  /**\n   * Extract handler reference from property value\n   * Can be: () => handler(), handler, () => { ... }\n   */\n  extractEventHandler(value, stateClassName) {\n    if (!value) return null;\n\n    // Arrow function: () => handler()\n    if (value.type === 'ArrowFunctionExpression') {\n      if (value.body.type === 'CallExpression') {\n        const handlerName = this.getClassNameFromExpression(value.body.callee);\n        return handlerName;\n      }\n\n      // Check if body is identifier: () => handler\n      if (value.body.type === 'Identifier') {\n        return value.body.name;\n      }\n    }\n\n    // Direct identifier: handler\n    if (value.type === 'Identifier') {\n      return value.name;\n    }\n\n    // Member expression: this.handler\n    if (value.type === 'MemberExpression') {\n      if (value.property.type === 'Identifier') {\n        return value.property.name;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get component name (for context, since we don't have full widget info here)\n   */\n  getComponentNameFromContext(expr) {\n    // This is simplified - in a real scenario you'd track which widget\n    // contains this object literal\n    if (expr.type === 'CallExpression' && expr.callee) {\n      return this.getClassNameFromExpression(expr.callee);\n    }\n\n    return 'Unknown';\n  }\n\n  /**\n   * Phase 6: Build state dependency graph\n   * \n   * Maps:\n   * - stateToMethods: which methods use which state\n   * - methodToState: which state each method uses\n   * - eventToState: which state each event updates\n   */\n  buildDependencyGraph() {\n    this.dependencyGraph = new DependencyGraph();\n\n    // State to methods\n    this.stateFields.forEach((field, key) => {\n      const methods = this.findMethodsUsingField(field.name);\n      if (methods.length > 0) {\n        this.dependencyGraph.stateToMethods.set(field.name, methods);\n      }\n    });\n\n    // Methods to state\n    this.stateClasses.forEach(({ metadata }) => {\n      metadata.stateFields.forEach((field) => {\n        const methodsUsing = this.findMethodsReadingField(metadata.name, field.name);\n        if (methodsUsing.length > 0) {\n          this.dependencyGraph.methodToState.set(field.name, methodsUsing);\n        }\n      });\n    });\n\n    // Event to state\n    this.eventHandlers.forEach((event) => {\n      const stateChanged = this.findStateChangedByMethod(event.handler);\n      if (stateChanged.length > 0) {\n        this.dependencyGraph.eventToState.set(event.event, stateChanged);\n      }\n    });\n  }\n\n  /**\n   * Find methods that use a state field\n   */\n  findMethodsUsingField(fieldName) {\n    const methods = new Set();\n\n    this.setStateCalls.forEach((call) => {\n      if (call.updates.includes(fieldName)) {\n        methods.add(call.method);\n      }\n    });\n\n    // Also check if field is used in build (for reading)\n    this.stateClasses.forEach(({ astNode, metadata }) => {\n      if (!astNode.body || !astNode.body.methods) return;\n\n      const buildMethod = astNode.body.methods.find((m) => m.key.name === 'build');\n      if (buildMethod && this.methodUsesField(buildMethod, fieldName)) {\n        methods.add('build');\n      }\n    });\n\n    return Array.from(methods);\n  }\n\n  /**\n   * Check if method uses a field\n   */\n  methodUsesField(method, fieldName) {\n    if (!method.body) return false;\n\n    const stmts = method.body.type === 'BlockStatement'\n      ? method.body.body\n      : [method.body];\n\n    for (const stmt of stmts) {\n      if (this.statementUsesField(stmt, fieldName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if statement contains field reference\n   */\n  statementUsesField(stmt, fieldName) {\n    if (!stmt) return false;\n\n    // Simple search for this._fieldName pattern\n    const code = JSON.stringify(stmt);\n    return code.includes(fieldName);\n  }\n\n  /**\n   * Find methods that are triggered by reading state\n   */\n  findMethodsReadingField(stateClassName, fieldName) {\n    const methods = [];\n\n    this.stateClasses.forEach(({ metadata }) => {\n      if (metadata.name !== stateClassName) return;\n\n      metadata.stateFields.forEach((field) => {\n        if (field.name === fieldName) {\n          methods.push(...field.usedInMethods);\n        }\n      });\n    });\n\n    return methods;\n  }\n\n  /**\n   * Find state changed by a method\n   */\n  findStateChangedByMethod(methodName) {\n    const changed = new Set();\n\n    this.setStateCalls.forEach((call) => {\n      if (call.method === methodName) {\n        call.updates.forEach((update) => changed.add(update));\n      }\n    });\n\n    return Array.from(changed);\n  }\n\n  /**\n   * Phase 7: Validate all state patterns\n   */\n  validateState() {\n    this.validateSetStatePatterns();\n    this.validateStateFieldUsage();\n    this.validateLifecyclePatterns();\n    this.validateEventHandlers();\n  }\n\n  /**\n   * Validate setState usage patterns\n   */\n  validateSetStatePatterns() {\n    this.setStateCalls.forEach((call) => {\n      const issues = [];\n\n      // Check if called from valid context (State class method)\n      const stateClass = this.stateClasses.get(call.stateClassName);\n      if (!stateClass) {\n        issues.push({\n          type: 'invalid-context',\n          message: `setState called outside of ${call.stateClassName}`,\n        });\n      }\n\n      // Check if updates valid fields\n      if (call.updates.length === 0) {\n        issues.push({\n          type: 'empty-update',\n          message: 'setState called with no state updates',\n          severity: 'warning',\n        });\n      }\n\n      call.updates.forEach((field) => {\n        if (!this.stateFields.has(`${call.stateClassName}.${field}`)) {\n          issues.push({\n            type: 'unknown-field',\n            message: `setState updates unknown field \"${field}\"`,\n            field,\n          });\n        }\n      });\n\n      // Record validation\n      call.isValid = issues.length === 0;\n      call.issues = issues;\n    });\n  }\n\n  /**\n   * Validate state field usage\n   */\n  validateStateFieldUsage() {\n    this.stateFields.forEach((field, key) => {\n      const parts = key.split('.');\n      const stateClassName = parts[0];\n      const fieldName = parts[1];\n\n      // Check if field is used\n      if (!this.fieldIsUsed(fieldName, stateClassName)) {\n        this.validationResults.push({\n          type: 'unused-state-field',\n          severity: 'warning',\n          field: fieldName,\n          location: field.location,\n          message: `State field \"${fieldName}\" is defined but never used`,\n          suggestion: 'Remove unused field or implement its usage',\n        });\n      }\n\n      // Check if field is mutated outside setState\n      const mutationsOutsideSetState = this.findMutationsOutsideSetState(\n        fieldName,\n        stateClassName\n      );\n      if (mutationsOutsideSetState.length > 0) {\n        this.validationResults.push({\n          type: 'mutation-outside-setstate',\n          severity: 'error',\n          field: fieldName,\n          locations: mutationsOutsideSetState,\n          message: `State field \"${fieldName}\" is mutated outside setState()`,\n          suggestion: 'Always use setState() to update state fields',\n        });\n      }\n    });\n  }\n\n  /**\n   * Check if field is used anywhere\n   */\n  fieldIsUsed(fieldName, stateClassName) {\n    // Check if read in build\n    const stateClass = this.stateClasses.get(stateClassName);\n    if (!stateClass) return false;\n\n    const buildMethod = stateClass.astNode.body.methods.find(\n      (m) => m.key.name === 'build'\n    );\n\n    if (buildMethod && this.methodUsesField(buildMethod, fieldName)) {\n      return true;\n    }\n\n    // Check if modified in setState\n    return this.setStateCalls.some((call) => call.updates.includes(fieldName));\n  }\n\n  /**\n   * Find mutations outside setState\n   */\n  findMutationsOutsideSetState(fieldName, stateClassName) {\n    const locations = [];\n    const inSetState = new Set();\n\n    // Collect all fields modified in setState\n    this.setStateCalls.forEach((call) => {\n      call.updates.forEach((field) => {\n        inSetState.add(field);\n      });\n    });\n\n    // If field is only in setState, it's good\n    if (!inSetState.has(fieldName)) {\n      return locations;\n    }\n\n    // For now, we assume mutations are only through setState\n    // In a full implementation, you'd scan all methods for direct assignments\n    return locations;\n  }\n\n  /**\n   * Validate lifecycle patterns\n   */\n  validateLifecyclePatterns() {\n    this.stateClasses.forEach(({ metadata }) => {\n      const methodMap = {};\n\n      metadata.lifecycleMethods.forEach((method) => {\n        methodMap[method.name] = method;\n      });\n\n      // dispose should call super.dispose\n      if (methodMap.dispose && !methodMap.dispose.callsSuper) {\n        this.validationResults.push({\n          type: 'lifecycle-issue',\n          severity: 'error',\n          method: 'dispose',\n          location: methodMap.dispose.location,\n          message: 'dispose() should call super.dispose()',\n          suggestion: 'Add super.dispose() call at the end of dispose()',\n        });\n      }\n\n      // initState should call super.initState\n      if (methodMap.initState && !methodMap.initState.callsSuper) {\n        this.validationResults.push({\n          type: 'lifecycle-issue',\n          severity: 'warning',\n          method: 'initState',\n          location: methodMap.initState.location,\n          message: 'initState() should call super.initState()',\n          suggestion: 'Add super.initState() call',\n        });\n      }\n    });\n  }\n\n  /**\n   * Validate event handlers\n   */\n  validateEventHandlers() {\n    this.eventHandlers.forEach((handler) => {\n      // Check if handler method exists\n      const handlerExists = this.stateClasses.values().some((sc) => {\n        return sc.metadata.stateFields.some((f) => f.name === handler.handler) ||\n          sc.astNode.body.methods.some((m) => m.key.name === handler.handler);\n      });\n\n      if (!handlerExists && handler.handler) {\n        this.validationResults.push({\n          type: 'missing-handler',\n          severity: 'error',\n          handler: handler.handler,\n          event: handler.event,\n          location: handler.location,\n          message: `Event handler \"${handler.handler}\" not found`,\n          suggestion: `Create a method called ${handler.handler} in the State class`,\n        });\n      }\n    });\n  }\n\n  /**\n   * Get final results\n   */\n  getResults() {\n    return {\n      stateClasses: Array.from(this.stateClasses.entries()).map(([name, data]) => ({\n        name,\n        metadata: data.metadata,\n      })),\n      stateFields: Array.from(this.stateFields.values()),\n      setStateCalls: this.setStateCalls,\n      lifecycleMethods: this.lifecycleMethods,\n      eventHandlers: this.eventHandlers,\n      dependencyGraph: this.dependencyGraph,\n      validationResults: this.validationResults,\n      errors: this.errors,\n    };\n  }\n}\n\n// ============================================================================\n// DATA CLASSES\n// ============================================================================\n\nclass StateClassMetadata {\n  constructor(name, location, linkedStatefulWidget) {\n    this.name = name;\n    this.location = location;\n    this.linkedStatefulWidget = linkedStatefulWidget;\n    this.stateFields = [];\n    this.lifecycleMethods = [];\n    this.methods = [];\n  }\n}\n\nclass StateField {\n  constructor(name, type, initialValue, location) {\n    this.name = name;\n    this.type = type;\n    this.initialValue = initialValue;\n    this.location = location;\n    this.isMutable = true;\n    this.mutations = [];\n    this.usedInMethods = [];\n    this.usedInBuild = false;\n  }\n}\n\nclass LifecycleMethod {\n  constructor(name, location, params, callsSuper, hasSideEffects) {\n    this.name = name;\n    this.location = location;\n    this.params = params;\n    this.callsSuper = callsSuper;\n    this.hasSideEffects = hasSideEffects;\n  }\n}\n\nclass StateUpdateCall {\n  constructor(location, method, updates, stateClassName) {\n    this.location = location;\n    this.method = method;\n    this.updates = updates || [];\n    this.stateClassName = stateClassName;\n    this.isValid = true;\n    this.issues = [];\n  }\n}\n\nclass DependencyGraph {\n  constructor() {\n    this.stateToMethods = new Map();\n    this.methodToState = new Map();\n    this.eventToState = new Map();\n  }\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport {\n  StateAnalyzer,\n  StateClassMetadata,\n  StateField,\n  LifecycleMethod,\n  StateUpdateCall,\n  DependencyGraph,\n};"],
  "mappings": "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",
  "names": ["StateAnalyzer", "ast", "widgets", "options", "error", "widget", "m", "widgetNode", "n", "createStateNode", "stateClassName", "stateClassNode", "stateMetadata", "StateClassMetadata", "methodBody", "stmt", "className", "expr", "astNode", "metadata", "field", "fieldName", "initialValue", "type", "stateField", "StateField", "name", "method", "setStateCalls", "calls", "methodName", "s", "updatedFields", "call", "StateUpdateCall", "arg", "prop", "obj", "setStateCall", "updated", "callback", "body", "mutated", "fields", "target", "lifecycleNames", "lifecycle", "LifecycleMethod", "stmts", "buildMethod", "handlers", "eventName", "handler", "keyExpr", "value", "DependencyGraph", "key", "methods", "methodsUsing", "event", "stateChanged", "changed", "update", "issues", "parts", "mutationsOutsideSetState", "stateClass", "locations", "inSetState", "methodMap", "sc", "f", "data", "location", "linkedStatefulWidget", "params", "callsSuper", "hasSideEffects", "updates"]
}
