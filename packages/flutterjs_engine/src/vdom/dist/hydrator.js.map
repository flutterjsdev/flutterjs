{
  "version": 3,
  "sources": ["../src/hydrator.js"],
  "sourcesContent": ["/**\n * Hydrator - SSR to CSR Transition System\n * \n * Handles the hydration process:\n * 1. Takes SSR-rendered HTML\n * 2. Matches it with VNode tree\n * 3. Attaches event listeners\n * 4. Restores state bindings\n * 5. Calls ref callbacks\n * 6. Makes the app interactive\n */\n\nimport { VNodeRenderer } from './vnode_renderer.js';\n\nclass Hydrator {\n  /**\n   * Hydrate SSR-rendered DOM with VNode tree\n   * @param {HTMLElement} rootElement - Root element with SSR HTML\n   * @param {VNode} vnodeTree - VNode tree to hydrate with\n   * @param {Object} hydrationData - Metadata from SSR (optional)\n   * @returns {HTMLElement} Hydrated root element\n   */\n  static hydrate(rootElement, vnodeTree, hydrationData = null) {\n    if (!rootElement) {\n      throw new Error('Root element is required for hydration');\n    }\n\n    if (!vnodeTree) {\n      throw new Error('VNode tree is required for hydration');\n    }\n\n    // Load hydration data from script tag if not provided\n    if (!hydrationData) {\n      hydrationData = this.loadHydrationData();\n    }\n\n    // Validate hydration data\n    if (hydrationData && !this.validateHydrationData(hydrationData)) {\n      console.warn('Invalid hydration data, proceeding without it');\n      hydrationData = null;\n    }\n\n    // Match DOM nodes with VNodes\n    this.matchDOMToVNode(rootElement, vnodeTree);\n\n    // Attach event listeners\n    this.attachEventListeners(rootElement, vnodeTree, hydrationData);\n\n    // Restore refs\n    this.restoreRefs(rootElement, vnodeTree, hydrationData);\n\n    // Initialize state bindings\n    this.initializeStateBindings(rootElement, vnodeTree, hydrationData);\n\n    // Mark as hydrated\n    rootElement.setAttribute('data-hydrated', 'true');\n    rootElement._hydrated = true;\n\n    // Cleanup hydration data script\n    this.cleanupHydrationData();\n\n    return rootElement;\n  }\n\n  /**\n   * Match DOM nodes with VNode tree (recursive)\n   * @private\n   */\n  static matchDOMToVNode(domNode, vnode, path = '0') {\n    if (!domNode || !vnode) return;\n\n    // Text nodes\n    if (typeof vnode === 'string' || typeof vnode === 'number') {\n      // Text nodes are already rendered correctly\n      return;\n    }\n\n    // Skip non-VNode objects\n    if (!vnode.tag) return;\n\n    // Element nodes\n    if (domNode.nodeType === Node.ELEMENT_NODE) {\n      // Store bidirectional references\n      domNode._vnode = vnode;\n      vnode._element = domNode;\n      vnode._path = path;\n\n      // Verify tag matches (mismatch = hydration error)\n      if (domNode.tagName.toLowerCase() !== vnode.tag.toLowerCase()) {\n        console.warn(\n          `Hydration mismatch at path ${path}: ` +\n          `expected <${vnode.tag}>, got <${domNode.tagName.toLowerCase()}>`\n        );\n        // Could attempt recovery here, but for now just warn\n      }\n\n      // Match children recursively\n      if (vnode.children && vnode.children.length > 0) {\n        this.matchChildren(domNode, vnode.children, path);\n      }\n    }\n  }\n\n  /**\n   * Match child nodes\n   * @private\n   */\n  static matchChildren(parentDom, vnodeChildren, parentPath) {\n    const domChildren = Array.from(parentDom.childNodes);\n    let domIndex = 0;\n    let vnodeIndex = 0;\n\n    while (vnodeIndex < vnodeChildren.length && domIndex < domChildren.length) {\n      const domChild = domChildren[domIndex];\n      const vnodeChild = vnodeChildren[vnodeIndex];\n\n      // Skip whitespace-only text nodes in DOM\n      if (domChild.nodeType === Node.TEXT_NODE && !domChild.textContent.trim()) {\n        domIndex++;\n        continue;\n      }\n\n      // Skip null/undefined vnodes\n      if (vnodeChild === null || vnodeChild === undefined) {\n        vnodeIndex++;\n        continue;\n      }\n\n      const childPath = `${parentPath}.${vnodeIndex}`;\n\n      // Match text nodes\n      if (typeof vnodeChild === 'string' || typeof vnodeChild === 'number') {\n        if (domChild.nodeType === Node.TEXT_NODE) {\n          // Verify content matches\n          const vnodeText = String(vnodeChild);\n          const domText = domChild.textContent;\n          \n          if (vnodeText !== domText) {\n            console.warn(\n              `Text content mismatch at ${childPath}: ` +\n              `expected \"${vnodeText}\", got \"${domText}\"`\n            );\n          }\n        }\n        domIndex++;\n        vnodeIndex++;\n        continue;\n      }\n\n      // Match element nodes\n      if (vnodeChild.tag && domChild.nodeType === Node.ELEMENT_NODE) {\n        this.matchDOMToVNode(domChild, vnodeChild, childPath);\n        domIndex++;\n        vnodeIndex++;\n        continue;\n      }\n\n      // If we get here, there's a mismatch - skip both and continue\n      domIndex++;\n      vnodeIndex++;\n    }\n  }\n\n  /**\n   * Attach event listeners from VNode tree\n   * @private\n   */\n  static attachEventListeners(rootElement, vnode, hydrationData) {\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\n      return;\n    }\n\n    // Attach events on this node\n    if (vnode._element && vnode.events && Object.keys(vnode.events).length > 0) {\n      VNodeRenderer.applyEvents(vnode._element, vnode.events);\n    }\n\n    // Recursively attach events on children\n    if (vnode.children && Array.isArray(vnode.children)) {\n      vnode.children.forEach(child => {\n        this.attachEventListeners(rootElement, child, hydrationData);\n      });\n    }\n  }\n\n  /**\n   * Restore ref callbacks\n   * @private\n   */\n  static restoreRefs(rootElement, vnode, hydrationData) {\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\n      return;\n    }\n\n    // Call ref callback if present\n    if (vnode._element && vnode.ref && typeof vnode.ref === 'function') {\n      try {\n        vnode.ref(vnode._element);\n      } catch (error) {\n        console.error('Error calling ref callback:', error);\n      }\n    }\n\n    // Recursively restore refs on children\n    if (vnode.children && Array.isArray(vnode.children)) {\n      vnode.children.forEach(child => {\n        this.restoreRefs(rootElement, child, hydrationData);\n      });\n    }\n  }\n\n  /**\n   * Initialize state bindings\n   * @private\n   */\n  static initializeStateBindings(rootElement, vnode, hydrationData) {\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\n      return;\n    }\n\n    // Register state binding if present\n    if (vnode.isStateBinding && vnode._element) {\n      // Store binding information for later state updates\n      if (!rootElement._stateBindings) {\n        rootElement._stateBindings = [];\n      }\n\n      rootElement._stateBindings.push({\n        element: vnode._element,\n        widgetId: vnode.statefulWidgetId,\n        property: vnode.stateProperty,\n        updateFn: vnode.updateFn\n      });\n    }\n\n    // Recursively initialize state bindings on children\n    if (vnode.children && Array.isArray(vnode.children)) {\n      vnode.children.forEach(child => {\n        this.initializeStateBindings(rootElement, child, hydrationData);\n      });\n    }\n  }\n\n  /**\n   * Load hydration data from script tag\n   * @private\n   */\n  static loadHydrationData() {\n    if (typeof document === 'undefined') {\n      return null;\n    }\n\n    const script = document.getElementById('__FLUTTERJS_HYDRATION_DATA__');\n    if (!script) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(script.textContent);\n    } catch (error) {\n      console.error('Failed to parse hydration data:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate hydration data structure\n   * @private\n   */\n  static validateHydrationData(data) {\n    if (!data || typeof data !== 'object') {\n      return false;\n    }\n\n    // Check required fields\n    if (!data.version) {\n      return false;\n    }\n\n    // Check arrays exist\n    const requiredArrays = ['widgets', 'stateBindings', 'events', 'refs'];\n    for (const key of requiredArrays) {\n      if (!Array.isArray(data[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cleanup hydration data script tag\n   * @private\n   */\n  static cleanupHydrationData() {\n    if (typeof document === 'undefined') {\n      return;\n    }\n\n    const script = document.getElementById('__FLUTTERJS_HYDRATION_DATA__');\n    if (script && script.parentNode) {\n      script.parentNode.removeChild(script);\n    }\n  }\n\n  /**\n   * Check if element is hydrated\n   * @param {HTMLElement} element - Element to check\n   * @returns {boolean} True if hydrated\n   */\n  static isHydrated(element) {\n    return element && (element._hydrated === true || element.hasAttribute('data-hydrated'));\n  }\n\n  /**\n   * Generate hydration data from VNode tree\n   * @param {VNode} vnode - VNode tree\n   * @returns {Object} Hydration data\n   */\n  static generateHydrationData(vnode) {\n    const data = {\n      version: '1.0.0',\n      timestamp: Date.now(),\n      widgets: [],\n      stateBindings: [],\n      events: [],\n      refs: []\n    };\n\n    this.collectHydrationData(vnode, data, '0');\n\n    return data;\n  }\n\n  /**\n   * Collect hydration data recursively\n   * @private\n   */\n  static collectHydrationData(vnode, data, path) {\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\n      return;\n    }\n\n    // Collect widget metadata\n    if (vnode.metadata && vnode.metadata.widgetType) {\n      data.widgets.push({\n        path,\n        type: vnode.metadata.widgetType,\n        props: vnode.metadata.flutterProps || {},\n        key: vnode.key\n      });\n    }\n\n    // Collect state bindings\n    if (vnode.isStateBinding) {\n      data.stateBindings.push({\n        path,\n        widgetId: vnode.statefulWidgetId,\n        property: vnode.stateProperty\n      });\n    }\n\n    // Collect event handlers (just names, not functions)\n    if (vnode.events && Object.keys(vnode.events).length > 0) {\n      data.events.push({\n        path,\n        events: Object.keys(vnode.events)\n      });\n    }\n\n    // Collect refs\n    if (vnode.ref) {\n      data.refs.push({\n        path,\n        hasRef: true\n      });\n    }\n\n    // Recursively collect from children\n    if (vnode.children && Array.isArray(vnode.children)) {\n      vnode.children.forEach((child, index) => {\n        if (child && typeof child === 'object' && child.tag) {\n          this.collectHydrationData(child, data, `${path}.${index}`);\n        }\n      });\n    }\n  }\n\n  /**\n   * Partial hydration - hydrate only specific subtree\n   * @param {HTMLElement} element - Subtree root element\n   * @param {VNode} vnode - VNode for subtree\n   * @returns {HTMLElement} Hydrated element\n   */\n  static hydratePartial(element, vnode) {\n    if (!element || !vnode) {\n      throw new Error('Element and VNode required for partial hydration');\n    }\n\n    // Match and hydrate just this subtree\n    this.matchDOMToVNode(element, vnode);\n    this.attachEventListeners(element, vnode, null);\n    this.restoreRefs(element, vnode, null);\n    this.initializeStateBindings(element, vnode, null);\n\n    element.setAttribute('data-hydrated', 'true');\n    element._hydrated = true;\n\n    return element;\n  }\n\n  /**\n   * Dehydrate - remove all hydration (for testing/cleanup)\n   * @param {HTMLElement} element - Element to dehydrate\n   */\n  static dehydrate(element) {\n    if (!element) return;\n\n    // Remove event listeners\n    VNodeRenderer.cleanupEventListeners(element);\n\n    // Remove hydration markers\n    element.removeAttribute('data-hydrated');\n    delete element._hydrated;\n    delete element._stateBindings;\n\n    // Recursively dehydrate children\n    Array.from(element.children).forEach(child => {\n      this.dehydrate(child);\n    });\n  }\n\n  /**\n   * Verify hydration correctness\n   * @param {HTMLElement} rootElement - Root element\n   * @param {VNode} vnode - VNode tree\n   * @returns {Object} Verification report\n   */\n  static verifyHydration(rootElement, vnode) {\n    const report = {\n      success: true,\n      mismatches: [],\n      warnings: [],\n      stats: {\n        nodesChecked: 0,\n        nodesMatched: 0,\n        eventListenersAttached: 0,\n        refsRestored: 0,\n        stateBindings: 0\n      }\n    };\n\n    this.verifyNode(rootElement, vnode, report, '0');\n\n    report.success = report.mismatches.length === 0;\n\n    return report;\n  }\n\n  /**\n   * Verify single node\n   * @private\n   */\n  static verifyNode(domNode, vnode, report, path) {\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\n      return;\n    }\n\n    report.stats.nodesChecked++;\n\n    // Check if DOM node exists\n    if (!domNode) {\n      report.mismatches.push({\n        path,\n        type: 'missing-dom',\n        message: `DOM node missing for VNode <${vnode.tag}>`\n      });\n      return;\n    }\n\n    // Check if references are set\n    if (!domNode._vnode || !vnode._element) {\n      report.warnings.push({\n        path,\n        type: 'missing-reference',\n        message: 'VNode-DOM references not set'\n      });\n    } else {\n      report.stats.nodesMatched++;\n    }\n\n    // Check if tag matches\n    if (domNode.tagName.toLowerCase() !== vnode.tag.toLowerCase()) {\n      report.mismatches.push({\n        path,\n        type: 'tag-mismatch',\n        expected: vnode.tag,\n        actual: domNode.tagName.toLowerCase()\n      });\n    }\n\n    // Check if events are attached\n    if (vnode.events && Object.keys(vnode.events).length > 0) {\n      if (domNode._eventListeners) {\n        report.stats.eventListenersAttached += Object.keys(domNode._eventListeners).length;\n      } else {\n        report.warnings.push({\n          path,\n          type: 'missing-events',\n          message: 'Event listeners not attached'\n        });\n      }\n    }\n\n    // Check if ref was called\n    if (vnode.ref) {\n      report.stats.refsRestored++;\n    }\n\n    // Check state bindings\n    if (vnode.isStateBinding) {\n      report.stats.stateBindings++;\n    }\n\n    // Recursively verify children\n    if (vnode.children && Array.isArray(vnode.children)) {\n      const domChildren = Array.from(domNode.childNodes).filter(\n        child => child.nodeType === Node.ELEMENT_NODE\n      );\n\n      vnode.children.forEach((child, index) => {\n        if (child && typeof child === 'object' && child.tag) {\n          const domChild = domChildren[index];\n          this.verifyNode(domChild, child, report, `${path}.${index}`);\n        }\n      });\n    }\n  }\n\n  /**\n   * Get hydration statistics\n   * @param {HTMLElement} rootElement - Hydrated root element\n   * @returns {Object} Statistics\n   */\n  static getStats(rootElement) {\n    const stats = {\n      isHydrated: this.isHydrated(rootElement),\n      totalElements: 0,\n      elementsWithEvents: 0,\n      elementsWithRefs: 0,\n      stateBindings: 0\n    };\n\n    const countRecursive = (element) => {\n      if (!element || element.nodeType !== Node.ELEMENT_NODE) return;\n\n      stats.totalElements++;\n\n      if (element._eventListeners && Object.keys(element._eventListeners).length > 0) {\n        stats.elementsWithEvents++;\n      }\n\n      if (element._vnode && element._vnode.ref) {\n        stats.elementsWithRefs++;\n      }\n\n      Array.from(element.children).forEach(countRecursive);\n    };\n\n    countRecursive(rootElement);\n\n    if (rootElement._stateBindings) {\n      stats.stateBindings = rootElement._stateBindings.length;\n    }\n\n    return stats;\n  }\n}\n\n// Export\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Hydrator;\n}\nif (typeof window !== 'undefined') {\n  window.Hydrator = Hydrator;\n}\n\nexport {Hydrator}"],
  "mappings": "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",
  "names": ["VNodeRenderer", "Hydrator", "rootElement", "vnodeTree", "hydrationData", "domNode", "vnode", "path", "parentDom", "vnodeChildren", "parentPath", "domChildren", "domIndex", "vnodeIndex", "domChild", "vnodeChild", "childPath", "vnodeText", "domText", "child", "error", "script", "data", "requiredArrays", "key", "element", "index", "report", "stats", "countRecursive"]
}
