{
  "version": 3,
  "sources": ["../src/hydrator.js"],
  "sourcesContent": ["/**\r\n * Hydrator - SSR to CSR Transition System\r\n * \r\n * Handles the hydration process:\r\n * 1. Takes SSR-rendered HTML\r\n * 2. Matches it with VNode tree\r\n * 3. Attaches event listeners\r\n * 4. Restores state bindings\r\n * 5. Calls ref callbacks\r\n * 6. Makes the app interactive\r\n */\r\n\r\nimport { VNodeRenderer } from './vnode_renderer.js';\r\n\r\nclass Hydrator {\r\n  /**\r\n   * Hydrate SSR-rendered DOM with VNode tree\r\n   * @param {HTMLElement} rootElement - Root element with SSR HTML\r\n   * @param {VNode} vnodeTree - VNode tree to hydrate with\r\n   * @param {Object} hydrationData - Metadata from SSR (optional)\r\n   * @returns {HTMLElement} Hydrated root element\r\n   */\r\n  static hydrate(rootElement, vnodeTree, hydrationData = null) {\r\n    if (!rootElement) {\r\n      throw new Error('Root element is required for hydration');\r\n    }\r\n\r\n    if (!vnodeTree) {\r\n      throw new Error('VNode tree is required for hydration');\r\n    }\r\n\r\n    // Load hydration data from script tag if not provided\r\n    if (!hydrationData) {\r\n      hydrationData = this.loadHydrationData();\r\n    }\r\n\r\n    // Validate hydration data\r\n    if (hydrationData && !this.validateHydrationData(hydrationData)) {\r\n      console.warn('Invalid hydration data, proceeding without it');\r\n      hydrationData = null;\r\n    }\r\n\r\n    // Match DOM nodes with VNodes\r\n    this.matchDOMToVNode(rootElement, vnodeTree);\r\n\r\n    // Attach event listeners\r\n    this.attachEventListeners(rootElement, vnodeTree, hydrationData);\r\n\r\n    // Restore refs\r\n    this.restoreRefs(rootElement, vnodeTree, hydrationData);\r\n\r\n    // Initialize state bindings\r\n    this.initializeStateBindings(rootElement, vnodeTree, hydrationData);\r\n\r\n    // Mark as hydrated\r\n    rootElement.setAttribute('data-hydrated', 'true');\r\n    rootElement._hydrated = true;\r\n\r\n    // Cleanup hydration data script\r\n    this.cleanupHydrationData();\r\n\r\n    return rootElement;\r\n  }\r\n\r\n  /**\r\n   * Match DOM nodes with VNode tree (recursive)\r\n   * @private\r\n   */\r\n  static matchDOMToVNode(domNode, vnode, path = '0') {\r\n    if (!domNode || !vnode) return;\r\n\r\n    // Text nodes\r\n    if (typeof vnode === 'string' || typeof vnode === 'number') {\r\n      // Text nodes are already rendered correctly\r\n      return;\r\n    }\r\n\r\n    // Skip non-VNode objects\r\n    if (!vnode.tag) return;\r\n\r\n    // Element nodes\r\n    if (domNode.nodeType === Node.ELEMENT_NODE) {\r\n      // Store bidirectional references\r\n      domNode._vnode = vnode;\r\n      vnode._element = domNode;\r\n      vnode._path = path;\r\n\r\n      // Verify tag matches (mismatch = hydration error)\r\n      if (domNode.tagName.toLowerCase() !== vnode.tag.toLowerCase()) {\r\n        console.warn(\r\n          `Hydration mismatch at path ${path}: ` +\r\n          `expected <${vnode.tag}>, got <${domNode.tagName.toLowerCase()}>`\r\n        );\r\n        // Could attempt recovery here, but for now just warn\r\n      }\r\n\r\n      // Match children recursively\r\n      if (vnode.children && vnode.children.length > 0) {\r\n        this.matchChildren(domNode, vnode.children, path);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Match child nodes\r\n   * @private\r\n   */\r\n  static matchChildren(parentDom, vnodeChildren, parentPath) {\r\n    const domChildren = Array.from(parentDom.childNodes);\r\n    let domIndex = 0;\r\n    let vnodeIndex = 0;\r\n\r\n    while (vnodeIndex < vnodeChildren.length && domIndex < domChildren.length) {\r\n      const domChild = domChildren[domIndex];\r\n      const vnodeChild = vnodeChildren[vnodeIndex];\r\n\r\n      // Skip whitespace-only text nodes in DOM\r\n      if (domChild.nodeType === Node.TEXT_NODE && !domChild.textContent.trim()) {\r\n        domIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Skip null/undefined vnodes\r\n      if (vnodeChild === null || vnodeChild === undefined) {\r\n        vnodeIndex++;\r\n        continue;\r\n      }\r\n\r\n      const childPath = `${parentPath}.${vnodeIndex}`;\r\n\r\n      // Match text nodes\r\n      if (typeof vnodeChild === 'string' || typeof vnodeChild === 'number') {\r\n        if (domChild.nodeType === Node.TEXT_NODE) {\r\n          // Verify content matches\r\n          const vnodeText = String(vnodeChild);\r\n          const domText = domChild.textContent;\r\n          \r\n          if (vnodeText !== domText) {\r\n            console.warn(\r\n              `Text content mismatch at ${childPath}: ` +\r\n              `expected \"${vnodeText}\", got \"${domText}\"`\r\n            );\r\n          }\r\n        }\r\n        domIndex++;\r\n        vnodeIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Match element nodes\r\n      if (vnodeChild.tag && domChild.nodeType === Node.ELEMENT_NODE) {\r\n        this.matchDOMToVNode(domChild, vnodeChild, childPath);\r\n        domIndex++;\r\n        vnodeIndex++;\r\n        continue;\r\n      }\r\n\r\n      // If we get here, there's a mismatch - skip both and continue\r\n      domIndex++;\r\n      vnodeIndex++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach event listeners from VNode tree\r\n   * @private\r\n   */\r\n  static attachEventListeners(rootElement, vnode, hydrationData) {\r\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\r\n      return;\r\n    }\r\n\r\n    // Attach events on this node\r\n    if (vnode._element && vnode.events && Object.keys(vnode.events).length > 0) {\r\n      VNodeRenderer.applyEvents(vnode._element, vnode.events);\r\n    }\r\n\r\n    // Recursively attach events on children\r\n    if (vnode.children && Array.isArray(vnode.children)) {\r\n      vnode.children.forEach(child => {\r\n        this.attachEventListeners(rootElement, child, hydrationData);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore ref callbacks\r\n   * @private\r\n   */\r\n  static restoreRefs(rootElement, vnode, hydrationData) {\r\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\r\n      return;\r\n    }\r\n\r\n    // Call ref callback if present\r\n    if (vnode._element && vnode.ref && typeof vnode.ref === 'function') {\r\n      try {\r\n        vnode.ref(vnode._element);\r\n      } catch (error) {\r\n        console.error('Error calling ref callback:', error);\r\n      }\r\n    }\r\n\r\n    // Recursively restore refs on children\r\n    if (vnode.children && Array.isArray(vnode.children)) {\r\n      vnode.children.forEach(child => {\r\n        this.restoreRefs(rootElement, child, hydrationData);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize state bindings\r\n   * @private\r\n   */\r\n  static initializeStateBindings(rootElement, vnode, hydrationData) {\r\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\r\n      return;\r\n    }\r\n\r\n    // Register state binding if present\r\n    if (vnode.isStateBinding && vnode._element) {\r\n      // Store binding information for later state updates\r\n      if (!rootElement._stateBindings) {\r\n        rootElement._stateBindings = [];\r\n      }\r\n\r\n      rootElement._stateBindings.push({\r\n        element: vnode._element,\r\n        widgetId: vnode.statefulWidgetId,\r\n        property: vnode.stateProperty,\r\n        updateFn: vnode.updateFn\r\n      });\r\n    }\r\n\r\n    // Recursively initialize state bindings on children\r\n    if (vnode.children && Array.isArray(vnode.children)) {\r\n      vnode.children.forEach(child => {\r\n        this.initializeStateBindings(rootElement, child, hydrationData);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load hydration data from script tag\r\n   * @private\r\n   */\r\n  static loadHydrationData() {\r\n    if (typeof document === 'undefined') {\r\n      return null;\r\n    }\r\n\r\n    const script = document.getElementById('__FLUTTERJS_HYDRATION_DATA__');\r\n    if (!script) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(script.textContent);\r\n    } catch (error) {\r\n      console.error('Failed to parse hydration data:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate hydration data structure\r\n   * @private\r\n   */\r\n  static validateHydrationData(data) {\r\n    if (!data || typeof data !== 'object') {\r\n      return false;\r\n    }\r\n\r\n    // Check required fields\r\n    if (!data.version) {\r\n      return false;\r\n    }\r\n\r\n    // Check arrays exist\r\n    const requiredArrays = ['widgets', 'stateBindings', 'events', 'refs'];\r\n    for (const key of requiredArrays) {\r\n      if (!Array.isArray(data[key])) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Cleanup hydration data script tag\r\n   * @private\r\n   */\r\n  static cleanupHydrationData() {\r\n    if (typeof document === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    const script = document.getElementById('__FLUTTERJS_HYDRATION_DATA__');\r\n    if (script && script.parentNode) {\r\n      script.parentNode.removeChild(script);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if element is hydrated\r\n   * @param {HTMLElement} element - Element to check\r\n   * @returns {boolean} True if hydrated\r\n   */\r\n  static isHydrated(element) {\r\n    return element && (element._hydrated === true || element.hasAttribute('data-hydrated'));\r\n  }\r\n\r\n  /**\r\n   * Generate hydration data from VNode tree\r\n   * @param {VNode} vnode - VNode tree\r\n   * @returns {Object} Hydration data\r\n   */\r\n  static generateHydrationData(vnode) {\r\n    const data = {\r\n      version: '1.0.0',\r\n      timestamp: Date.now(),\r\n      widgets: [],\r\n      stateBindings: [],\r\n      events: [],\r\n      refs: []\r\n    };\r\n\r\n    this.collectHydrationData(vnode, data, '0');\r\n\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * Collect hydration data recursively\r\n   * @private\r\n   */\r\n  static collectHydrationData(vnode, data, path) {\r\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\r\n      return;\r\n    }\r\n\r\n    // Collect widget metadata\r\n    if (vnode.metadata && vnode.metadata.widgetType) {\r\n      data.widgets.push({\r\n        path,\r\n        type: vnode.metadata.widgetType,\r\n        props: vnode.metadata.flutterProps || {},\r\n        key: vnode.key\r\n      });\r\n    }\r\n\r\n    // Collect state bindings\r\n    if (vnode.isStateBinding) {\r\n      data.stateBindings.push({\r\n        path,\r\n        widgetId: vnode.statefulWidgetId,\r\n        property: vnode.stateProperty\r\n      });\r\n    }\r\n\r\n    // Collect event handlers (just names, not functions)\r\n    if (vnode.events && Object.keys(vnode.events).length > 0) {\r\n      data.events.push({\r\n        path,\r\n        events: Object.keys(vnode.events)\r\n      });\r\n    }\r\n\r\n    // Collect refs\r\n    if (vnode.ref) {\r\n      data.refs.push({\r\n        path,\r\n        hasRef: true\r\n      });\r\n    }\r\n\r\n    // Recursively collect from children\r\n    if (vnode.children && Array.isArray(vnode.children)) {\r\n      vnode.children.forEach((child, index) => {\r\n        if (child && typeof child === 'object' && child.tag) {\r\n          this.collectHydrationData(child, data, `${path}.${index}`);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Partial hydration - hydrate only specific subtree\r\n   * @param {HTMLElement} element - Subtree root element\r\n   * @param {VNode} vnode - VNode for subtree\r\n   * @returns {HTMLElement} Hydrated element\r\n   */\r\n  static hydratePartial(element, vnode) {\r\n    if (!element || !vnode) {\r\n      throw new Error('Element and VNode required for partial hydration');\r\n    }\r\n\r\n    // Match and hydrate just this subtree\r\n    this.matchDOMToVNode(element, vnode);\r\n    this.attachEventListeners(element, vnode, null);\r\n    this.restoreRefs(element, vnode, null);\r\n    this.initializeStateBindings(element, vnode, null);\r\n\r\n    element.setAttribute('data-hydrated', 'true');\r\n    element._hydrated = true;\r\n\r\n    return element;\r\n  }\r\n\r\n  /**\r\n   * Dehydrate - remove all hydration (for testing/cleanup)\r\n   * @param {HTMLElement} element - Element to dehydrate\r\n   */\r\n  static dehydrate(element) {\r\n    if (!element) return;\r\n\r\n    // Remove event listeners\r\n    VNodeRenderer.cleanupEventListeners(element);\r\n\r\n    // Remove hydration markers\r\n    element.removeAttribute('data-hydrated');\r\n    delete element._hydrated;\r\n    delete element._stateBindings;\r\n\r\n    // Recursively dehydrate children\r\n    Array.from(element.children).forEach(child => {\r\n      this.dehydrate(child);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Verify hydration correctness\r\n   * @param {HTMLElement} rootElement - Root element\r\n   * @param {VNode} vnode - VNode tree\r\n   * @returns {Object} Verification report\r\n   */\r\n  static verifyHydration(rootElement, vnode) {\r\n    const report = {\r\n      success: true,\r\n      mismatches: [],\r\n      warnings: [],\r\n      stats: {\r\n        nodesChecked: 0,\r\n        nodesMatched: 0,\r\n        eventListenersAttached: 0,\r\n        refsRestored: 0,\r\n        stateBindings: 0\r\n      }\r\n    };\r\n\r\n    this.verifyNode(rootElement, vnode, report, '0');\r\n\r\n    report.success = report.mismatches.length === 0;\r\n\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * Verify single node\r\n   * @private\r\n   */\r\n  static verifyNode(domNode, vnode, report, path) {\r\n    if (!vnode || typeof vnode !== 'object' || !vnode.tag) {\r\n      return;\r\n    }\r\n\r\n    report.stats.nodesChecked++;\r\n\r\n    // Check if DOM node exists\r\n    if (!domNode) {\r\n      report.mismatches.push({\r\n        path,\r\n        type: 'missing-dom',\r\n        message: `DOM node missing for VNode <${vnode.tag}>`\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Check if references are set\r\n    if (!domNode._vnode || !vnode._element) {\r\n      report.warnings.push({\r\n        path,\r\n        type: 'missing-reference',\r\n        message: 'VNode-DOM references not set'\r\n      });\r\n    } else {\r\n      report.stats.nodesMatched++;\r\n    }\r\n\r\n    // Check if tag matches\r\n    if (domNode.tagName.toLowerCase() !== vnode.tag.toLowerCase()) {\r\n      report.mismatches.push({\r\n        path,\r\n        type: 'tag-mismatch',\r\n        expected: vnode.tag,\r\n        actual: domNode.tagName.toLowerCase()\r\n      });\r\n    }\r\n\r\n    // Check if events are attached\r\n    if (vnode.events && Object.keys(vnode.events).length > 0) {\r\n      if (domNode._eventListeners) {\r\n        report.stats.eventListenersAttached += Object.keys(domNode._eventListeners).length;\r\n      } else {\r\n        report.warnings.push({\r\n          path,\r\n          type: 'missing-events',\r\n          message: 'Event listeners not attached'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check if ref was called\r\n    if (vnode.ref) {\r\n      report.stats.refsRestored++;\r\n    }\r\n\r\n    // Check state bindings\r\n    if (vnode.isStateBinding) {\r\n      report.stats.stateBindings++;\r\n    }\r\n\r\n    // Recursively verify children\r\n    if (vnode.children && Array.isArray(vnode.children)) {\r\n      const domChildren = Array.from(domNode.childNodes).filter(\r\n        child => child.nodeType === Node.ELEMENT_NODE\r\n      );\r\n\r\n      vnode.children.forEach((child, index) => {\r\n        if (child && typeof child === 'object' && child.tag) {\r\n          const domChild = domChildren[index];\r\n          this.verifyNode(domChild, child, report, `${path}.${index}`);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get hydration statistics\r\n   * @param {HTMLElement} rootElement - Hydrated root element\r\n   * @returns {Object} Statistics\r\n   */\r\n  static getStats(rootElement) {\r\n    const stats = {\r\n      isHydrated: this.isHydrated(rootElement),\r\n      totalElements: 0,\r\n      elementsWithEvents: 0,\r\n      elementsWithRefs: 0,\r\n      stateBindings: 0\r\n    };\r\n\r\n    const countRecursive = (element) => {\r\n      if (!element || element.nodeType !== Node.ELEMENT_NODE) return;\r\n\r\n      stats.totalElements++;\r\n\r\n      if (element._eventListeners && Object.keys(element._eventListeners).length > 0) {\r\n        stats.elementsWithEvents++;\r\n      }\r\n\r\n      if (element._vnode && element._vnode.ref) {\r\n        stats.elementsWithRefs++;\r\n      }\r\n\r\n      Array.from(element.children).forEach(countRecursive);\r\n    };\r\n\r\n    countRecursive(rootElement);\r\n\r\n    if (rootElement._stateBindings) {\r\n      stats.stateBindings = rootElement._stateBindings.length;\r\n    }\r\n\r\n    return stats;\r\n  }\r\n}\r\n\r\n\r\n\r\nexport {Hydrator}"],
  "mappings": "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",
  "names": ["VNodeRenderer", "Hydrator", "rootElement", "vnodeTree", "hydrationData", "domNode", "vnode", "path", "parentDom", "vnodeChildren", "parentPath", "domChildren", "domIndex", "vnodeIndex", "domChild", "vnodeChild", "childPath", "vnodeText", "domText", "child", "error", "script", "data", "requiredArrays", "key", "element", "index", "report", "stats", "countRecursive"]
}
