const h={IMMEDIATE:"immediate",HIGH:"high",NORMAL:"normal",LOW:"low"};class c{constructor(e,s=h.NORMAL,t=null,i=null){this.callback=e,this.priority=s,this.id=t||`update-${Date.now()}-${Math.random()}`,this.batchId=i,this.timestamp=Date.now(),this.attempts=0,this.lastError=null,this.sequence=l.globalSequence++}}class u{constructor(e=null){this.id=e||`batch-${Date.now()}-${Math.random()}`,this.updates=[],this.createdAt=Date.now(),this.status="pending"}add(e){if(!(e instanceof c))throw new Error("Must add UpdateRequest to batch");this.updates.push(e)}size(){return this.updates.length}clear(){this.updates=[]}}class l{static globalSequence=0;constructor(e={}){this.maxBatchSize=e.maxBatchSize||50,this.frameDeadline=e.frameDeadline||5,this.enableAutoFlushing=e.enableAutoFlushing!==!1,this.enablePrioritization=e.enablePrioritization!==!1,this.enableMetrics=e.enableMetrics!==!1,this.queues=new Map([[h.IMMEDIATE,[]],[h.HIGH,[]],[h.NORMAL,[]],[h.LOW,[]]]),this.currentBatch=new u("current"),this.pendingBatches=[],this.isProcessing=!1,this.frameScheduled=!1,this.onBeforeFlushed=e.onBeforeFlushed||null,this.onAfterFlushed=e.onAfterFlushed||null,this.onError=e.onError||null,this.metrics={totalUpdates:0,totalBatches:0,totalTime:0,averageTime:0,minTime:1/0,maxTime:0,errors:0,skipped:0},this.flush=this.flush.bind(this),this.scheduleFrame=this.scheduleFrame.bind(this)}schedule(e,s=h.NORMAL,t=null){if(typeof e!="function")throw new Error("Update callback must be a function");const i=new c(e,s,t),n=this.queues.get(s);if(!n)throw new Error(`Invalid priority: ${s}`);return n.push(i),s===h.IMMEDIATE?this.flush([i]):this.enableAutoFlushing&&!this.frameScheduled&&this.scheduleFrame(),i.id}scheduleBatch(e,s=h.NORMAL){if(!Array.isArray(e))throw new Error("Batch callbacks must be an array");const t=new u,i=this.queues.get(s);if(!i)throw new Error(`Invalid priority: ${s}`);return e.forEach((n,r)=>{const a=new c(n,s,`batch-${t.id}-${r}`,t.id);t.add(a),i.push(a)}),this.pendingBatches.push(t),this.enableAutoFlushing&&!this.frameScheduled&&this.scheduleFrame(),t.id}flush(e=null){if(this.isProcessing)return{success:!1,reason:"Already processing"};const s=performance.now();try{this.isProcessing=!0,this.frameScheduled=!1;let t=e;if(t||(t=this.getNextUpdates()),t.length===0)return{success:!0,processed:0,time:0};if(typeof this.onBeforeFlushed=="function")try{this.onBeforeFlushed(t)}catch(r){console.warn("onBeforeFlushed error:",r)}const i=[];if(t.forEach(r=>{try{r.attempts++,r.callback(),i.push({id:r.id,success:!0}),this.metrics.totalUpdates++}catch(a){if(r.lastError=a,i.push({id:r.id,success:!1,error:a}),this.metrics.errors++,typeof this.onError=="function")try{this.onError(a,r)}catch(d){console.error("onError handler error:",d)}else console.error("Update error:",a)}}),typeof this.onAfterFlushed=="function")try{this.onAfterFlushed(i)}catch(r){console.warn("onAfterFlushed error:",r)}const n=performance.now()-s;return this.metrics.totalTime+=n,this.metrics.minTime=Math.min(this.metrics.minTime,n),this.metrics.maxTime=Math.max(this.metrics.maxTime,n),this.metrics.averageTime=this.metrics.totalTime/Math.max(1,this.metrics.totalUpdates),this.metrics.totalBatches++,{success:!0,processed:i.filter(r=>r.success).length,failed:i.filter(r=>!r.success).length,results:i,time:n}}finally{this.isProcessing=!1}}scheduleFrame(){this.frameScheduled||(this.frameScheduled=!0,typeof requestAnimationFrame<"u"?requestAnimationFrame(()=>{this.flush()}):setTimeout(()=>{this.flush()},16))}getNextUpdates(){const e=[];if(this.enablePrioritization)for(const s of[h.IMMEDIATE,h.HIGH,h.NORMAL,h.LOW]){const t=this.queues.get(s);for(;t.length>0&&e.length<this.maxBatchSize;)e.push(t.shift())}else{const s=[];for(const t of this.queues.values())for(;t.length>0;)s.push(t.shift());for(s.sort((t,i)=>t.sequence-i.sequence);s.length>0&&e.length<this.maxBatchSize;)e.push(s.shift());for(const t of s)this.queues.get(t.priority).push(t)}return e}cancel(e){for(const s of this.queues.values()){const t=s.findIndex(i=>i.id===e);if(t!==-1)return s.splice(t,1),this.metrics.skipped++,!0}for(const s of this.pendingBatches){const t=s.updates.findIndex(i=>i.id===e);if(t!==-1)return s.updates.splice(t,1),this.metrics.skipped++,!0}return!1}cancelBatch(e){let s=0;for(const t of this.queues.values())for(let i=t.length-1;i>=0;i--)t[i].batchId===e&&(t.splice(i,1),s++,this.metrics.skipped++);for(let t=this.pendingBatches.length-1;t>=0;t--)if(this.pendingBatches[t].id===e){this.pendingBatches.splice(t,1);break}return s}flushAll(){let e={success:!0,totalProcessed:0,totalFailed:0,iterations:0,time:0};const s=performance.now();for(;this.hasUpdates();){const t=this.flush();if(!t.success){e.success=!1;break}if(e.totalProcessed+=t.processed,e.totalFailed+=t.failed,e.iterations++,e.iterations>1e3){e.success=!1,e.warning="Iteration limit reached";break}}return e.time=performance.now()-s,e}hasUpdates(){for(const e of this.queues.values())if(e.length>0)return!0;return this.pendingBatches.length>0||this.currentBatch.size()>0}getPendingCount(){let e=0;for(const s of this.queues.values())e+=s.length;for(const s of this.pendingBatches)e+=s.size();return e+=this.currentBatch.size(),e}getQueueStats(){const e={total:0,byPriority:{},batches:0};for(const[s,t]of this.queues)e.byPriority[s]=t.length,e.total+=t.length;return e.batches=this.pendingBatches.reduce((s,t)=>s+t.size(),0),e.total+=e.batches,e}getMetrics(){return{...this.metrics,pending:this.getPendingCount(),isProcessing:this.isProcessing}}reset(){this.queues.forEach(e=>e.length=0),this.pendingBatches.length=0,this.currentBatch.clear(),this.isProcessing=!1,this.frameScheduled=!1,this.metrics={totalUpdates:0,totalBatches:0,totalTime:0,averageTime:0,minTime:1/0,maxTime:0,errors:0,skipped:0}}clearMetrics(){this.metrics={totalUpdates:0,totalBatches:0,totalTime:0,averageTime:0,minTime:1/0,maxTime:0,errors:0,skipped:0}}drain(){const e=[];for(const s of this.queues.values())e.push(...s.splice(0));for(const s of this.pendingBatches)e.push(...s.updates.splice(0));return e.push(...this.currentBatch.updates.splice(0)),e}waitForFlush(){return new Promise(e=>{if(!this.hasUpdates()&&!this.isProcessing){e(!0);return}const s=()=>{!this.hasUpdates()&&!this.isProcessing?e(!0):requestAnimationFrame(s)};s()})}createUpdater(e=h.NORMAL){return(s,t=null)=>this.schedule(s,e,t)}}export{u as UpdateBatch,h as UpdatePriority,c as UpdateRequest,l as UpdateScheduler};
//# sourceMappingURL=update_scheduler.js.map
