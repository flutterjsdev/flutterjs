{
  "version": 3,
  "sources": ["../src/update_scheduler.js"],
  "sourcesContent": ["/**\r\n * UpdateScheduler - Batches and schedules DOM updates\r\n * \r\n * Coordinates multiple concurrent updates to minimize DOM thrashing and\r\n * repaints. Automatically batches updates and applies them during\r\n * requestAnimationFrame for optimal performance.\r\n * \r\n * Features:\r\n * - Update batching (group multiple updates)\r\n * - Automatic frame scheduling (requestAnimationFrame)\r\n * - Priority levels (immediate, normal, deferred)\r\n * - Concurrent update management\r\n * - Callback hooks (before/after)\r\n * - Update queuing and flushing\r\n * - Performance monitoring\r\n */\r\n\r\n/**\r\n * Update priority levels\r\n */\r\nconst UpdatePriority = {\r\n  IMMEDIATE: 'immediate',  // Execute immediately (no batching)\r\n  HIGH: 'high',            // Execute in next frame\r\n  NORMAL: 'normal',        // Execute in current or next frame\r\n  LOW: 'low'               // Execute when idle\r\n};\r\n\r\n/**\r\n * Update request object\r\n */\r\nclass UpdateRequest {\r\n  constructor(callback, priority = UpdatePriority.NORMAL, id = null, batchId = null) {\r\n    this.callback = callback;\r\n    this.priority = priority;\r\n    this.id = id || `update-${Date.now()}-${Math.random()}`;\r\n    this.batchId = batchId; // Track which batch this belongs to\r\n    this.timestamp = Date.now();\r\n    this.attempts = 0;\r\n    this.lastError = null;\r\n    this.sequence = UpdateScheduler.globalSequence++;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Update batch - groups related updates\r\n */\r\nclass UpdateBatch {\r\n  constructor(batchId = null) {\r\n    this.id = batchId || `batch-${Date.now()}-${Math.random()}`;\r\n    this.updates = [];\r\n    this.createdAt = Date.now();\r\n    this.status = 'pending'; // pending, processing, completed, failed\r\n  }\r\n\r\n  add(update) {\r\n    if (!(update instanceof UpdateRequest)) {\r\n      throw new Error('Must add UpdateRequest to batch');\r\n    }\r\n    this.updates.push(update);\r\n  }\r\n\r\n  size() {\r\n    return this.updates.length;\r\n  }\r\n\r\n  clear() {\r\n    this.updates = [];\r\n  }\r\n}\r\n\r\n/**\r\n * UpdateScheduler - Manages batching and scheduling of updates\r\n */\r\nclass UpdateScheduler {\r\n  // Class variable to track global insertion order\r\n  static globalSequence = 0;\r\n  constructor(options = {}) {\r\n    // Configuration\r\n    this.maxBatchSize = options.maxBatchSize || 50;\r\n    this.frameDeadline = options.frameDeadline || 5; // ms remaining in frame\r\n    this.enableAutoFlushing = options.enableAutoFlushing !== false;\r\n    this.enablePrioritization = options.enablePrioritization !== false;\r\n    this.enableMetrics = options.enableMetrics !== false;\r\n\r\n    // State\r\n    this.queues = new Map([\r\n      [UpdatePriority.IMMEDIATE, []],\r\n      [UpdatePriority.HIGH, []],\r\n      [UpdatePriority.NORMAL, []],\r\n      [UpdatePriority.LOW, []]\r\n    ]);\r\n\r\n    this.currentBatch = new UpdateBatch('current');\r\n    this.pendingBatches = [];\r\n    this.isProcessing = false;\r\n    this.frameScheduled = false;\r\n\r\n    // Callbacks\r\n    this.onBeforeFlushed = options.onBeforeFlushed || null;\r\n    this.onAfterFlushed = options.onAfterFlushed || null;\r\n    this.onError = options.onError || null;\r\n\r\n    // Metrics\r\n    this.metrics = {\r\n      totalUpdates: 0,\r\n      totalBatches: 0,\r\n      totalTime: 0,\r\n      averageTime: 0,\r\n      minTime: Infinity,\r\n      maxTime: 0,\r\n      errors: 0,\r\n      skipped: 0\r\n    };\r\n\r\n    // Bind methods\r\n    this.flush = this.flush.bind(this);\r\n    this.scheduleFrame = this.scheduleFrame.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Schedule an update to be processed\r\n   * @param {Function} callback - Function to execute\r\n   * @param {string} priority - Update priority level\r\n   * @param {string} id - Optional update ID\r\n   * @returns {string} Update ID\r\n   */\r\n  schedule(callback, priority = UpdatePriority.NORMAL, id = null) {\r\n    if (typeof callback !== 'function') {\r\n      throw new Error('Update callback must be a function');\r\n    }\r\n\r\n    const update = new UpdateRequest(callback, priority, id);\r\n    const queue = this.queues.get(priority);\r\n\r\n    if (!queue) {\r\n      throw new Error(`Invalid priority: ${priority}`);\r\n    }\r\n\r\n    // Add to appropriate queue\r\n    queue.push(update);\r\n\r\n    // Handle based on priority\r\n    if (priority === UpdatePriority.IMMEDIATE) {\r\n      this.flush([update]);\r\n    } else if (this.enableAutoFlushing && !this.frameScheduled) {\r\n      this.scheduleFrame();\r\n    }\r\n\r\n    return update.id;\r\n  }\r\n\r\n  /**\r\n   * Schedule multiple updates as a batch\r\n   * @param {Function[]} callbacks - Array of callbacks\r\n   * @param {string} priority - Priority for all updates\r\n   * @returns {string} Batch ID\r\n   */\r\n scheduleBatch(callbacks, priority = UpdatePriority.NORMAL) {\r\n  if (!Array.isArray(callbacks)) {\r\n    throw new Error('Batch callbacks must be an array');\r\n  }\r\n\r\n  const batch = new UpdateBatch();\r\n  const queue = this.queues.get(priority);\r\n\r\n  if (!queue) {\r\n    throw new Error(`Invalid priority: ${priority}`);\r\n  }\r\n\r\n  // Create updates with the specified priority and add them to the priority queue\r\n  callbacks.forEach((callback, index) => {\r\n    const update = new UpdateRequest(callback, priority, `batch-${batch.id}-${index}`, batch.id);\r\n    batch.add(update);\r\n    // IMPORTANT: Add to the priority queue, not just to batch\r\n    queue.push(update);\r\n  });\r\n\r\n  // Store batch reference for tracking\r\n  this.pendingBatches.push(batch);\r\n\r\n  if (this.enableAutoFlushing && !this.frameScheduled) {\r\n    this.scheduleFrame();\r\n  }\r\n\r\n  return batch.id;\r\n}\r\n\r\n  /**\r\n   * Flush (execute) all scheduled updates\r\n   * @param {UpdateRequest[]} updates - Specific updates to flush (or all)\r\n   * @returns {Object} Flush result\r\n   */\r\n  flush(updates = null) {\r\n    if (this.isProcessing) {\r\n      return { success: false, reason: 'Already processing' };\r\n    }\r\n\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      this.isProcessing = true;\r\n      this.frameScheduled = false;\r\n\r\n      // Get updates to process\r\n      let toProcess = updates;\r\n      if (!toProcess) {\r\n        toProcess = this.getNextUpdates();\r\n      }\r\n\r\n      if (toProcess.length === 0) {\r\n        return { success: true, processed: 0, time: 0 };\r\n      }\r\n\r\n      // Call before hook\r\n      if (typeof this.onBeforeFlushed === 'function') {\r\n        try {\r\n          this.onBeforeFlushed(toProcess);\r\n        } catch (error) {\r\n          console.warn('onBeforeFlushed error:', error);\r\n        }\r\n      }\r\n\r\n      // Execute updates\r\n      const results = [];\r\n      toProcess.forEach((update) => {\r\n        try {\r\n          update.attempts++;\r\n          update.callback();\r\n          results.push({ id: update.id, success: true });\r\n          this.metrics.totalUpdates++;\r\n        } catch (error) {\r\n          update.lastError = error;\r\n          results.push({ id: update.id, success: false, error });\r\n          this.metrics.errors++;\r\n\r\n          // Call error handler\r\n          if (typeof this.onError === 'function') {\r\n            try {\r\n              this.onError(error, update);\r\n            } catch (e) {\r\n              console.error('onError handler error:', e);\r\n            }\r\n          } else {\r\n            console.error('Update error:', error);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Call after hook\r\n      if (typeof this.onAfterFlushed === 'function') {\r\n        try {\r\n          this.onAfterFlushed(results);\r\n        } catch (error) {\r\n          console.warn('onAfterFlushed error:', error);\r\n        }\r\n      }\r\n\r\n      // Update metrics\r\n      const elapsedTime = performance.now() - startTime;\r\n      this.metrics.totalTime += elapsedTime;\r\n      this.metrics.minTime = Math.min(this.metrics.minTime, elapsedTime);\r\n      this.metrics.maxTime = Math.max(this.metrics.maxTime, elapsedTime);\r\n      this.metrics.averageTime = this.metrics.totalTime / Math.max(1, this.metrics.totalUpdates);\r\n      this.metrics.totalBatches++;\r\n\r\n      return {\r\n        success: true,\r\n        processed: results.filter(r => r.success).length,\r\n        failed: results.filter(r => !r.success).length,\r\n        results,\r\n        time: elapsedTime\r\n      };\r\n    } finally {\r\n      this.isProcessing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Schedule flush in next frame\r\n   */\r\n  scheduleFrame() {\r\n    if (this.frameScheduled) {\r\n      return;\r\n    }\r\n\r\n    this.frameScheduled = true;\r\n\r\n    if (typeof requestAnimationFrame !== 'undefined') {\r\n      requestAnimationFrame(() => {\r\n        this.flush();\r\n      });\r\n    } else {\r\n      // Fallback for non-browser environments\r\n      setTimeout(() => {\r\n        this.flush();\r\n      }, 16); // ~60fps\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get next batch of updates to process\r\n   * @private\r\n   */\r\n  getNextUpdates() {\r\n  const updates = [];\r\n\r\n  if (this.enablePrioritization) {\r\n    // Process queues in priority order: IMMEDIATE, HIGH, NORMAL, LOW\r\n    for (const priority of [\r\n      UpdatePriority.IMMEDIATE,\r\n      UpdatePriority.HIGH,\r\n      UpdatePriority.NORMAL,\r\n      UpdatePriority.LOW\r\n    ]) {\r\n      const queue = this.queues.get(priority);\r\n      while (queue.length > 0 && updates.length < this.maxBatchSize) {\r\n        updates.push(queue.shift());\r\n      }\r\n    }\r\n  } else {\r\n    // FIFO mode: Collect all updates and sort by sequence number\r\n    const allUpdates = [];\r\n\r\n    // Collect from all priority queues\r\n    for (const queue of this.queues.values()) {\r\n      while (queue.length > 0) {\r\n        allUpdates.push(queue.shift());\r\n      }\r\n    }\r\n\r\n    // Sort by sequence (insertion order)\r\n    allUpdates.sort((a, b) => a.sequence - b.sequence);\r\n\r\n    // Take up to maxBatchSize\r\n    while (allUpdates.length > 0 && updates.length < this.maxBatchSize) {\r\n      updates.push(allUpdates.shift());\r\n    }\r\n\r\n    // Re-queue remaining updates back to their queues\r\n    for (const update of allUpdates) {\r\n      const queue = this.queues.get(update.priority);\r\n      queue.push(update);\r\n    }\r\n  }\r\n\r\n  return updates;\r\n}\r\n\r\n\r\n\r\n  /**\r\n   * Cancel a scheduled update\r\n   * @param {string} updateId - Update ID to cancel\r\n   * @returns {boolean} Whether update was found and cancelled\r\n   */\r\n  cancel(updateId) {\r\n    for (const queue of this.queues.values()) {\r\n      const index = queue.findIndex(u => u.id === updateId);\r\n      if (index !== -1) {\r\n        queue.splice(index, 1);\r\n        this.metrics.skipped++;\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Try in pending batches\r\n    for (const batch of this.pendingBatches) {\r\n      const index = batch.updates.findIndex(u => u.id === updateId);\r\n      if (index !== -1) {\r\n        batch.updates.splice(index, 1);\r\n        this.metrics.skipped++;\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Cancel all updates in a batch\r\n   * @param {string} batchId - Batch ID to cancel\r\n   * @returns {number} Number of updates cancelled\r\n   */\r\n cancelBatch(batchId) {\r\n  let cancelled = 0;\r\n\r\n  // Cancel updates that belong to this batch by batchId field\r\n  for (const queue of this.queues.values()) {\r\n    for (let i = queue.length - 1; i >= 0; i--) {\r\n      if (queue[i].batchId === batchId) {\r\n        queue.splice(i, 1);\r\n        cancelled++;\r\n        this.metrics.skipped++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Remove the batch reference\r\n  for (let i = this.pendingBatches.length - 1; i >= 0; i--) {\r\n    if (this.pendingBatches[i].id === batchId) {\r\n      this.pendingBatches.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  return cancelled;\r\n}\r\n\r\n  /**\r\n   * Flush all pending updates synchronously\r\n   * @returns {Object} Flush result\r\n   */\r\n  flushAll() {\r\n    let totalResult = {\r\n      success: true,\r\n      totalProcessed: 0,\r\n      totalFailed: 0,\r\n      iterations: 0,\r\n      time: 0\r\n    };\r\n\r\n    const startTime = performance.now();\r\n\r\n    // Keep flushing until all queues are empty\r\n    while (this.hasUpdates()) {\r\n      const result = this.flush();\r\n      if (!result.success) {\r\n        totalResult.success = false;\r\n        break;\r\n      }\r\n\r\n      totalResult.totalProcessed += result.processed;\r\n      totalResult.totalFailed += result.failed;\r\n      totalResult.iterations++;\r\n\r\n      // Prevent infinite loops\r\n      if (totalResult.iterations > 1000) {\r\n        totalResult.success = false;\r\n        totalResult.warning = 'Iteration limit reached';\r\n        break;\r\n      }\r\n    }\r\n\r\n    totalResult.time = performance.now() - startTime;\r\n    return totalResult;\r\n  }\r\n\r\n  /**\r\n   * Check if there are pending updates\r\n   * @returns {boolean}\r\n   */\r\n  hasUpdates() {\r\n    // Check all priority queues\r\n    for (const queue of this.queues.values()) {\r\n      if (queue.length > 0) return true;\r\n    }\r\n\r\n    // Check pending batches\r\n    if (this.pendingBatches.length > 0) return true;\r\n\r\n    // Check current batch\r\n    if (this.currentBatch.size() > 0) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get number of pending updates\r\n   * @returns {number}\r\n   */\r\n  getPendingCount() {\r\n    let count = 0;\r\n\r\n    for (const queue of this.queues.values()) {\r\n      count += queue.length;\r\n    }\r\n\r\n    for (const batch of this.pendingBatches) {\r\n      count += batch.size();\r\n    }\r\n\r\n    count += this.currentBatch.size();\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Get queue statistics\r\n   * @returns {Object} Queue stats\r\n   */\r\n  getQueueStats() {\r\n    const stats = {\r\n      total: 0,\r\n      byPriority: {},\r\n      batches: 0\r\n    };\r\n\r\n    for (const [priority, queue] of this.queues) {\r\n      stats.byPriority[priority] = queue.length;\r\n      stats.total += queue.length;\r\n    }\r\n\r\n    stats.batches = this.pendingBatches.reduce((sum, b) => sum + b.size(), 0);\r\n    stats.total += stats.batches;\r\n\r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * Get performance metrics\r\n   * @returns {Object} Metrics\r\n   */\r\n  getMetrics() {\r\n    return {\r\n      ...this.metrics,\r\n      pending: this.getPendingCount(),\r\n      isProcessing: this.isProcessing\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset all state\r\n   */\r\n  reset() {\r\n    this.queues.forEach(queue => queue.length = 0);\r\n    this.pendingBatches.length = 0;\r\n    this.currentBatch.clear();\r\n    this.isProcessing = false;\r\n    this.frameScheduled = false;\r\n\r\n    // Reset metrics\r\n    this.metrics = {\r\n      totalUpdates: 0,\r\n      totalBatches: 0,\r\n      totalTime: 0,\r\n      averageTime: 0,\r\n      minTime: Infinity,\r\n      maxTime: 0,\r\n      errors: 0,\r\n      skipped: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear metrics only\r\n   */\r\n  clearMetrics() {\r\n    this.metrics = {\r\n      totalUpdates: 0,\r\n      totalBatches: 0,\r\n      totalTime: 0,\r\n      averageTime: 0,\r\n      minTime: Infinity,\r\n      maxTime: 0,\r\n      errors: 0,\r\n      skipped: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Drain all updates and return them without executing\r\n   * @returns {UpdateRequest[]}\r\n   */\r\n  drain() {\r\n    const updates = [];\r\n\r\n    for (const queue of this.queues.values()) {\r\n      updates.push(...queue.splice(0));\r\n    }\r\n\r\n    for (const batch of this.pendingBatches) {\r\n      updates.push(...batch.updates.splice(0));\r\n    }\r\n\r\n    updates.push(...this.currentBatch.updates.splice(0));\r\n\r\n    return updates;\r\n  }\r\n\r\n  /**\r\n   * Wait for all updates to complete\r\n   * @returns {Promise}\r\n   */\r\n  waitForFlush() {\r\n    return new Promise((resolve) => {\r\n      if (!this.hasUpdates() && !this.isProcessing) {\r\n        resolve(true);\r\n        return;\r\n      }\r\n\r\n      const checkComplete = () => {\r\n        if (!this.hasUpdates() && !this.isProcessing) {\r\n          resolve(true);\r\n        } else {\r\n          requestAnimationFrame(checkComplete);\r\n        }\r\n      };\r\n\r\n      checkComplete();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a priority-based updater\r\n   * Returns a function to easily schedule updates at a specific priority\r\n   * @param {string} priority - Default priority\r\n   * @returns {Function}\r\n   */\r\n  createUpdater(priority = UpdatePriority.NORMAL) {\r\n    return (callback, id = null) => this.schedule(callback, priority, id);\r\n  }\r\n}\r\n\r\n\r\nexport { UpdatePriority, UpdateRequest, UpdateBatch, UpdateScheduler }"],
  "mappings": "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",
  "names": ["UpdatePriority", "UpdateRequest", "callback", "priority", "id", "batchId", "UpdateScheduler", "UpdateBatch", "update", "options", "queue", "callbacks", "batch", "index", "updates", "startTime", "toProcess", "error", "results", "e", "elapsedTime", "allUpdates", "a", "b", "updateId", "u", "cancelled", "i", "totalResult", "result", "count", "stats", "sum", "resolve", "checkComplete"]
}
