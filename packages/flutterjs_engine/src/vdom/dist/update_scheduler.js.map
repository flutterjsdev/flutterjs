{
  "version": 3,
  "sources": ["../src/update_scheduler.js"],
  "sourcesContent": ["/**\n * UpdateScheduler - Batches and schedules DOM updates\n * \n * Coordinates multiple concurrent updates to minimize DOM thrashing and\n * repaints. Automatically batches updates and applies them during\n * requestAnimationFrame for optimal performance.\n * \n * Features:\n * - Update batching (group multiple updates)\n * - Automatic frame scheduling (requestAnimationFrame)\n * - Priority levels (immediate, normal, deferred)\n * - Concurrent update management\n * - Callback hooks (before/after)\n * - Update queuing and flushing\n * - Performance monitoring\n */\n\n/**\n * Update priority levels\n */\nconst UpdatePriority = {\n  IMMEDIATE: 'immediate',  // Execute immediately (no batching)\n  HIGH: 'high',            // Execute in next frame\n  NORMAL: 'normal',        // Execute in current or next frame\n  LOW: 'low'               // Execute when idle\n};\n\n/**\n * Update request object\n */\nclass UpdateRequest {\n  constructor(callback, priority = UpdatePriority.NORMAL, id = null, batchId = null) {\n    this.callback = callback;\n    this.priority = priority;\n    this.id = id || `update-${Date.now()}-${Math.random()}`;\n    this.batchId = batchId; // Track which batch this belongs to\n    this.timestamp = Date.now();\n    this.attempts = 0;\n    this.lastError = null;\n    this.sequence = UpdateScheduler.globalSequence++;\n  }\n}\n\n\n/**\n * Update batch - groups related updates\n */\nclass UpdateBatch {\n  constructor(batchId = null) {\n    this.id = batchId || `batch-${Date.now()}-${Math.random()}`;\n    this.updates = [];\n    this.createdAt = Date.now();\n    this.status = 'pending'; // pending, processing, completed, failed\n  }\n\n  add(update) {\n    if (!(update instanceof UpdateRequest)) {\n      throw new Error('Must add UpdateRequest to batch');\n    }\n    this.updates.push(update);\n  }\n\n  size() {\n    return this.updates.length;\n  }\n\n  clear() {\n    this.updates = [];\n  }\n}\n\n/**\n * UpdateScheduler - Manages batching and scheduling of updates\n */\nclass UpdateScheduler {\n  // Class variable to track global insertion order\n  static globalSequence = 0;\n  constructor(options = {}) {\n    // Configuration\n    this.maxBatchSize = options.maxBatchSize || 50;\n    this.frameDeadline = options.frameDeadline || 5; // ms remaining in frame\n    this.enableAutoFlushing = options.enableAutoFlushing !== false;\n    this.enablePrioritization = options.enablePrioritization !== false;\n    this.enableMetrics = options.enableMetrics !== false;\n\n    // State\n    this.queues = new Map([\n      [UpdatePriority.IMMEDIATE, []],\n      [UpdatePriority.HIGH, []],\n      [UpdatePriority.NORMAL, []],\n      [UpdatePriority.LOW, []]\n    ]);\n\n    this.currentBatch = new UpdateBatch('current');\n    this.pendingBatches = [];\n    this.isProcessing = false;\n    this.frameScheduled = false;\n\n    // Callbacks\n    this.onBeforeFlushed = options.onBeforeFlushed || null;\n    this.onAfterFlushed = options.onAfterFlushed || null;\n    this.onError = options.onError || null;\n\n    // Metrics\n    this.metrics = {\n      totalUpdates: 0,\n      totalBatches: 0,\n      totalTime: 0,\n      averageTime: 0,\n      minTime: Infinity,\n      maxTime: 0,\n      errors: 0,\n      skipped: 0\n    };\n\n    // Bind methods\n    this.flush = this.flush.bind(this);\n    this.scheduleFrame = this.scheduleFrame.bind(this);\n  }\n\n  /**\n   * Schedule an update to be processed\n   * @param {Function} callback - Function to execute\n   * @param {string} priority - Update priority level\n   * @param {string} id - Optional update ID\n   * @returns {string} Update ID\n   */\n  schedule(callback, priority = UpdatePriority.NORMAL, id = null) {\n    if (typeof callback !== 'function') {\n      throw new Error('Update callback must be a function');\n    }\n\n    const update = new UpdateRequest(callback, priority, id);\n    const queue = this.queues.get(priority);\n\n    if (!queue) {\n      throw new Error(`Invalid priority: ${priority}`);\n    }\n\n    // Add to appropriate queue\n    queue.push(update);\n\n    // Handle based on priority\n    if (priority === UpdatePriority.IMMEDIATE) {\n      this.flush([update]);\n    } else if (this.enableAutoFlushing && !this.frameScheduled) {\n      this.scheduleFrame();\n    }\n\n    return update.id;\n  }\n\n  /**\n   * Schedule multiple updates as a batch\n   * @param {Function[]} callbacks - Array of callbacks\n   * @param {string} priority - Priority for all updates\n   * @returns {string} Batch ID\n   */\n scheduleBatch(callbacks, priority = UpdatePriority.NORMAL) {\n  if (!Array.isArray(callbacks)) {\n    throw new Error('Batch callbacks must be an array');\n  }\n\n  const batch = new UpdateBatch();\n  const queue = this.queues.get(priority);\n\n  if (!queue) {\n    throw new Error(`Invalid priority: ${priority}`);\n  }\n\n  // Create updates with the specified priority and add them to the priority queue\n  callbacks.forEach((callback, index) => {\n    const update = new UpdateRequest(callback, priority, `batch-${batch.id}-${index}`, batch.id);\n    batch.add(update);\n    // IMPORTANT: Add to the priority queue, not just to batch\n    queue.push(update);\n  });\n\n  // Store batch reference for tracking\n  this.pendingBatches.push(batch);\n\n  if (this.enableAutoFlushing && !this.frameScheduled) {\n    this.scheduleFrame();\n  }\n\n  return batch.id;\n}\n\n  /**\n   * Flush (execute) all scheduled updates\n   * @param {UpdateRequest[]} updates - Specific updates to flush (or all)\n   * @returns {Object} Flush result\n   */\n  flush(updates = null) {\n    if (this.isProcessing) {\n      return { success: false, reason: 'Already processing' };\n    }\n\n    const startTime = performance.now();\n\n    try {\n      this.isProcessing = true;\n      this.frameScheduled = false;\n\n      // Get updates to process\n      let toProcess = updates;\n      if (!toProcess) {\n        toProcess = this.getNextUpdates();\n      }\n\n      if (toProcess.length === 0) {\n        return { success: true, processed: 0, time: 0 };\n      }\n\n      // Call before hook\n      if (typeof this.onBeforeFlushed === 'function') {\n        try {\n          this.onBeforeFlushed(toProcess);\n        } catch (error) {\n          console.warn('onBeforeFlushed error:', error);\n        }\n      }\n\n      // Execute updates\n      const results = [];\n      toProcess.forEach((update) => {\n        try {\n          update.attempts++;\n          update.callback();\n          results.push({ id: update.id, success: true });\n          this.metrics.totalUpdates++;\n        } catch (error) {\n          update.lastError = error;\n          results.push({ id: update.id, success: false, error });\n          this.metrics.errors++;\n\n          // Call error handler\n          if (typeof this.onError === 'function') {\n            try {\n              this.onError(error, update);\n            } catch (e) {\n              console.error('onError handler error:', e);\n            }\n          } else {\n            console.error('Update error:', error);\n          }\n        }\n      });\n\n      // Call after hook\n      if (typeof this.onAfterFlushed === 'function') {\n        try {\n          this.onAfterFlushed(results);\n        } catch (error) {\n          console.warn('onAfterFlushed error:', error);\n        }\n      }\n\n      // Update metrics\n      const elapsedTime = performance.now() - startTime;\n      this.metrics.totalTime += elapsedTime;\n      this.metrics.minTime = Math.min(this.metrics.minTime, elapsedTime);\n      this.metrics.maxTime = Math.max(this.metrics.maxTime, elapsedTime);\n      this.metrics.averageTime = this.metrics.totalTime / Math.max(1, this.metrics.totalUpdates);\n      this.metrics.totalBatches++;\n\n      return {\n        success: true,\n        processed: results.filter(r => r.success).length,\n        failed: results.filter(r => !r.success).length,\n        results,\n        time: elapsedTime\n      };\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  /**\n   * Schedule flush in next frame\n   */\n  scheduleFrame() {\n    if (this.frameScheduled) {\n      return;\n    }\n\n    this.frameScheduled = true;\n\n    if (typeof requestAnimationFrame !== 'undefined') {\n      requestAnimationFrame(() => {\n        this.flush();\n      });\n    } else {\n      // Fallback for non-browser environments\n      setTimeout(() => {\n        this.flush();\n      }, 16); // ~60fps\n    }\n  }\n\n  /**\n   * Get next batch of updates to process\n   * @private\n   */\n  getNextUpdates() {\n  const updates = [];\n\n  if (this.enablePrioritization) {\n    // Process queues in priority order: IMMEDIATE, HIGH, NORMAL, LOW\n    for (const priority of [\n      UpdatePriority.IMMEDIATE,\n      UpdatePriority.HIGH,\n      UpdatePriority.NORMAL,\n      UpdatePriority.LOW\n    ]) {\n      const queue = this.queues.get(priority);\n      while (queue.length > 0 && updates.length < this.maxBatchSize) {\n        updates.push(queue.shift());\n      }\n    }\n  } else {\n    // FIFO mode: Collect all updates and sort by sequence number\n    const allUpdates = [];\n\n    // Collect from all priority queues\n    for (const queue of this.queues.values()) {\n      while (queue.length > 0) {\n        allUpdates.push(queue.shift());\n      }\n    }\n\n    // Sort by sequence (insertion order)\n    allUpdates.sort((a, b) => a.sequence - b.sequence);\n\n    // Take up to maxBatchSize\n    while (allUpdates.length > 0 && updates.length < this.maxBatchSize) {\n      updates.push(allUpdates.shift());\n    }\n\n    // Re-queue remaining updates back to their queues\n    for (const update of allUpdates) {\n      const queue = this.queues.get(update.priority);\n      queue.push(update);\n    }\n  }\n\n  return updates;\n}\n\n\n\n  /**\n   * Cancel a scheduled update\n   * @param {string} updateId - Update ID to cancel\n   * @returns {boolean} Whether update was found and cancelled\n   */\n  cancel(updateId) {\n    for (const queue of this.queues.values()) {\n      const index = queue.findIndex(u => u.id === updateId);\n      if (index !== -1) {\n        queue.splice(index, 1);\n        this.metrics.skipped++;\n        return true;\n      }\n    }\n\n    // Try in pending batches\n    for (const batch of this.pendingBatches) {\n      const index = batch.updates.findIndex(u => u.id === updateId);\n      if (index !== -1) {\n        batch.updates.splice(index, 1);\n        this.metrics.skipped++;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Cancel all updates in a batch\n   * @param {string} batchId - Batch ID to cancel\n   * @returns {number} Number of updates cancelled\n   */\n cancelBatch(batchId) {\n  let cancelled = 0;\n\n  // Cancel updates that belong to this batch by batchId field\n  for (const queue of this.queues.values()) {\n    for (let i = queue.length - 1; i >= 0; i--) {\n      if (queue[i].batchId === batchId) {\n        queue.splice(i, 1);\n        cancelled++;\n        this.metrics.skipped++;\n      }\n    }\n  }\n\n  // Remove the batch reference\n  for (let i = this.pendingBatches.length - 1; i >= 0; i--) {\n    if (this.pendingBatches[i].id === batchId) {\n      this.pendingBatches.splice(i, 1);\n      break;\n    }\n  }\n\n  return cancelled;\n}\n\n  /**\n   * Flush all pending updates synchronously\n   * @returns {Object} Flush result\n   */\n  flushAll() {\n    let totalResult = {\n      success: true,\n      totalProcessed: 0,\n      totalFailed: 0,\n      iterations: 0,\n      time: 0\n    };\n\n    const startTime = performance.now();\n\n    // Keep flushing until all queues are empty\n    while (this.hasUpdates()) {\n      const result = this.flush();\n      if (!result.success) {\n        totalResult.success = false;\n        break;\n      }\n\n      totalResult.totalProcessed += result.processed;\n      totalResult.totalFailed += result.failed;\n      totalResult.iterations++;\n\n      // Prevent infinite loops\n      if (totalResult.iterations > 1000) {\n        totalResult.success = false;\n        totalResult.warning = 'Iteration limit reached';\n        break;\n      }\n    }\n\n    totalResult.time = performance.now() - startTime;\n    return totalResult;\n  }\n\n  /**\n   * Check if there are pending updates\n   * @returns {boolean}\n   */\n  hasUpdates() {\n    // Check all priority queues\n    for (const queue of this.queues.values()) {\n      if (queue.length > 0) return true;\n    }\n\n    // Check pending batches\n    if (this.pendingBatches.length > 0) return true;\n\n    // Check current batch\n    if (this.currentBatch.size() > 0) return true;\n\n    return false;\n  }\n\n  /**\n   * Get number of pending updates\n   * @returns {number}\n   */\n  getPendingCount() {\n    let count = 0;\n\n    for (const queue of this.queues.values()) {\n      count += queue.length;\n    }\n\n    for (const batch of this.pendingBatches) {\n      count += batch.size();\n    }\n\n    count += this.currentBatch.size();\n    return count;\n  }\n\n  /**\n   * Get queue statistics\n   * @returns {Object} Queue stats\n   */\n  getQueueStats() {\n    const stats = {\n      total: 0,\n      byPriority: {},\n      batches: 0\n    };\n\n    for (const [priority, queue] of this.queues) {\n      stats.byPriority[priority] = queue.length;\n      stats.total += queue.length;\n    }\n\n    stats.batches = this.pendingBatches.reduce((sum, b) => sum + b.size(), 0);\n    stats.total += stats.batches;\n\n    return stats;\n  }\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Metrics\n   */\n  getMetrics() {\n    return {\n      ...this.metrics,\n      pending: this.getPendingCount(),\n      isProcessing: this.isProcessing\n    };\n  }\n\n  /**\n   * Reset all state\n   */\n  reset() {\n    this.queues.forEach(queue => queue.length = 0);\n    this.pendingBatches.length = 0;\n    this.currentBatch.clear();\n    this.isProcessing = false;\n    this.frameScheduled = false;\n\n    // Reset metrics\n    this.metrics = {\n      totalUpdates: 0,\n      totalBatches: 0,\n      totalTime: 0,\n      averageTime: 0,\n      minTime: Infinity,\n      maxTime: 0,\n      errors: 0,\n      skipped: 0\n    };\n  }\n\n  /**\n   * Clear metrics only\n   */\n  clearMetrics() {\n    this.metrics = {\n      totalUpdates: 0,\n      totalBatches: 0,\n      totalTime: 0,\n      averageTime: 0,\n      minTime: Infinity,\n      maxTime: 0,\n      errors: 0,\n      skipped: 0\n    };\n  }\n\n  /**\n   * Drain all updates and return them without executing\n   * @returns {UpdateRequest[]}\n   */\n  drain() {\n    const updates = [];\n\n    for (const queue of this.queues.values()) {\n      updates.push(...queue.splice(0));\n    }\n\n    for (const batch of this.pendingBatches) {\n      updates.push(...batch.updates.splice(0));\n    }\n\n    updates.push(...this.currentBatch.updates.splice(0));\n\n    return updates;\n  }\n\n  /**\n   * Wait for all updates to complete\n   * @returns {Promise}\n   */\n  waitForFlush() {\n    return new Promise((resolve) => {\n      if (!this.hasUpdates() && !this.isProcessing) {\n        resolve(true);\n        return;\n      }\n\n      const checkComplete = () => {\n        if (!this.hasUpdates() && !this.isProcessing) {\n          resolve(true);\n        } else {\n          requestAnimationFrame(checkComplete);\n        }\n      };\n\n      checkComplete();\n    });\n  }\n\n  /**\n   * Create a priority-based updater\n   * Returns a function to easily schedule updates at a specific priority\n   * @param {string} priority - Default priority\n   * @returns {Function}\n   */\n  createUpdater(priority = UpdatePriority.NORMAL) {\n    return (callback, id = null) => this.schedule(callback, priority, id);\n  }\n}\n\n// Export\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = {\n    UpdateScheduler,\n    UpdateRequest,\n    UpdateBatch,\n    UpdatePriority\n  };\n}\nif (typeof window !== 'undefined') {\n  window.UpdateScheduler = UpdateScheduler;\n  window.UpdatePriority = UpdatePriority;\n}\n\nexport { UpdatePriority, UpdateRequest, UpdateBatch, UpdateScheduler }"],
  "mappings": "AAoBA,MAAMA,EAAiB,CACrB,UAAW,YACX,KAAM,OACN,OAAQ,SACR,IAAK,KACP,EAKA,MAAMC,CAAc,CAClB,YAAYC,EAAUC,EAAWH,EAAe,OAAQI,EAAK,KAAMC,EAAU,KAAM,CACjF,KAAK,SAAWH,EAChB,KAAK,SAAWC,EAChB,KAAK,GAAKC,GAAM,UAAU,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,CAAC,GACrD,KAAK,QAAUC,EACf,KAAK,UAAY,KAAK,IAAI,EAC1B,KAAK,SAAW,EAChB,KAAK,UAAY,KACjB,KAAK,SAAWC,EAAgB,gBAClC,CACF,CAMA,MAAMC,CAAY,CAChB,YAAYF,EAAU,KAAM,CAC1B,KAAK,GAAKA,GAAW,SAAS,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,CAAC,GACzD,KAAK,QAAU,CAAC,EAChB,KAAK,UAAY,KAAK,IAAI,EAC1B,KAAK,OAAS,SAChB,CAEA,IAAIG,EAAQ,CACV,GAAI,EAAEA,aAAkBP,GACtB,MAAM,IAAI,MAAM,iCAAiC,EAEnD,KAAK,QAAQ,KAAKO,CAAM,CAC1B,CAEA,MAAO,CACL,OAAO,KAAK,QAAQ,MACtB,CAEA,OAAQ,CACN,KAAK,QAAU,CAAC,CAClB,CACF,CAKA,MAAMF,CAAgB,CAEpB,OAAO,eAAiB,EACxB,YAAYG,EAAU,CAAC,EAAG,CAExB,KAAK,aAAeA,EAAQ,cAAgB,GAC5C,KAAK,cAAgBA,EAAQ,eAAiB,EAC9C,KAAK,mBAAqBA,EAAQ,qBAAuB,GACzD,KAAK,qBAAuBA,EAAQ,uBAAyB,GAC7D,KAAK,cAAgBA,EAAQ,gBAAkB,GAG/C,KAAK,OAAS,IAAI,IAAI,CACpB,CAACT,EAAe,UAAW,CAAC,CAAC,EAC7B,CAACA,EAAe,KAAM,CAAC,CAAC,EACxB,CAACA,EAAe,OAAQ,CAAC,CAAC,EAC1B,CAACA,EAAe,IAAK,CAAC,CAAC,CACzB,CAAC,EAED,KAAK,aAAe,IAAIO,EAAY,SAAS,EAC7C,KAAK,eAAiB,CAAC,EACvB,KAAK,aAAe,GACpB,KAAK,eAAiB,GAGtB,KAAK,gBAAkBE,EAAQ,iBAAmB,KAClD,KAAK,eAAiBA,EAAQ,gBAAkB,KAChD,KAAK,QAAUA,EAAQ,SAAW,KAGlC,KAAK,QAAU,CACb,aAAc,EACd,aAAc,EACd,UAAW,EACX,YAAa,EACb,QAAS,IACT,QAAS,EACT,OAAQ,EACR,QAAS,CACX,EAGA,KAAK,MAAQ,KAAK,MAAM,KAAK,IAAI,EACjC,KAAK,cAAgB,KAAK,cAAc,KAAK,IAAI,CACnD,CASA,SAASP,EAAUC,EAAWH,EAAe,OAAQI,EAAK,KAAM,CAC9D,GAAI,OAAOF,GAAa,WACtB,MAAM,IAAI,MAAM,oCAAoC,EAGtD,MAAMM,EAAS,IAAIP,EAAcC,EAAUC,EAAUC,CAAE,EACjDM,EAAQ,KAAK,OAAO,IAAIP,CAAQ,EAEtC,GAAI,CAACO,EACH,MAAM,IAAI,MAAM,qBAAqBP,CAAQ,EAAE,EAIjD,OAAAO,EAAM,KAAKF,CAAM,EAGbL,IAAaH,EAAe,UAC9B,KAAK,MAAM,CAACQ,CAAM,CAAC,EACV,KAAK,oBAAsB,CAAC,KAAK,gBAC1C,KAAK,cAAc,EAGdA,EAAO,EAChB,CAQD,cAAcG,EAAWR,EAAWH,EAAe,OAAQ,CAC1D,GAAI,CAAC,MAAM,QAAQW,CAAS,EAC1B,MAAM,IAAI,MAAM,kCAAkC,EAGpD,MAAMC,EAAQ,IAAIL,EACZG,EAAQ,KAAK,OAAO,IAAIP,CAAQ,EAEtC,GAAI,CAACO,EACH,MAAM,IAAI,MAAM,qBAAqBP,CAAQ,EAAE,EAIjD,OAAAQ,EAAU,QAAQ,CAACT,EAAUW,IAAU,CACrC,MAAML,EAAS,IAAIP,EAAcC,EAAUC,EAAU,SAASS,EAAM,EAAE,IAAIC,CAAK,GAAID,EAAM,EAAE,EAC3FA,EAAM,IAAIJ,CAAM,EAEhBE,EAAM,KAAKF,CAAM,CACnB,CAAC,EAGD,KAAK,eAAe,KAAKI,CAAK,EAE1B,KAAK,oBAAsB,CAAC,KAAK,gBACnC,KAAK,cAAc,EAGdA,EAAM,EACf,CAOE,MAAME,EAAU,KAAM,CACpB,GAAI,KAAK,aACP,MAAO,CAAE,QAAS,GAAO,OAAQ,oBAAqB,EAGxD,MAAMC,EAAY,YAAY,IAAI,EAElC,GAAI,CACF,KAAK,aAAe,GACpB,KAAK,eAAiB,GAGtB,IAAIC,EAAYF,EAKhB,GAJKE,IACHA,EAAY,KAAK,eAAe,GAG9BA,EAAU,SAAW,EACvB,MAAO,CAAE,QAAS,GAAM,UAAW,EAAG,KAAM,CAAE,EAIhD,GAAI,OAAO,KAAK,iBAAoB,WAClC,GAAI,CACF,KAAK,gBAAgBA,CAAS,CAChC,OAASC,EAAO,CACd,QAAQ,KAAK,yBAA0BA,CAAK,CAC9C,CAIF,MAAMC,EAAU,CAAC,EA0BjB,GAzBAF,EAAU,QAASR,GAAW,CAC5B,GAAI,CACFA,EAAO,WACPA,EAAO,SAAS,EAChBU,EAAQ,KAAK,CAAE,GAAIV,EAAO,GAAI,QAAS,EAAK,CAAC,EAC7C,KAAK,QAAQ,cACf,OAASS,EAAO,CAMd,GALAT,EAAO,UAAYS,EACnBC,EAAQ,KAAK,CAAE,GAAIV,EAAO,GAAI,QAAS,GAAO,MAAAS,CAAM,CAAC,EACrD,KAAK,QAAQ,SAGT,OAAO,KAAK,SAAY,WAC1B,GAAI,CACF,KAAK,QAAQA,EAAOT,CAAM,CAC5B,OAASW,EAAG,CACV,QAAQ,MAAM,yBAA0BA,CAAC,CAC3C,MAEA,QAAQ,MAAM,gBAAiBF,CAAK,CAExC,CACF,CAAC,EAGG,OAAO,KAAK,gBAAmB,WACjC,GAAI,CACF,KAAK,eAAeC,CAAO,CAC7B,OAASD,EAAO,CACd,QAAQ,KAAK,wBAAyBA,CAAK,CAC7C,CAIF,MAAMG,EAAc,YAAY,IAAI,EAAIL,EACxC,YAAK,QAAQ,WAAaK,EAC1B,KAAK,QAAQ,QAAU,KAAK,IAAI,KAAK,QAAQ,QAASA,CAAW,EACjE,KAAK,QAAQ,QAAU,KAAK,IAAI,KAAK,QAAQ,QAASA,CAAW,EACjE,KAAK,QAAQ,YAAc,KAAK,QAAQ,UAAY,KAAK,IAAI,EAAG,KAAK,QAAQ,YAAY,EACzF,KAAK,QAAQ,eAEN,CACL,QAAS,GACT,UAAWF,EAAQ,OAAO,GAAK,EAAE,OAAO,EAAE,OAC1C,OAAQA,EAAQ,OAAO,GAAK,CAAC,EAAE,OAAO,EAAE,OACxC,QAAAA,EACA,KAAME,CACR,CACF,QAAE,CACA,KAAK,aAAe,EACtB,CACF,CAKA,eAAgB,CACV,KAAK,iBAIT,KAAK,eAAiB,GAElB,OAAO,sBAA0B,IACnC,sBAAsB,IAAM,CAC1B,KAAK,MAAM,CACb,CAAC,EAGD,WAAW,IAAM,CACf,KAAK,MAAM,CACb,EAAG,EAAE,EAET,CAMA,gBAAiB,CACjB,MAAMN,EAAU,CAAC,EAEjB,GAAI,KAAK,qBAEP,UAAWX,IAAY,CACrBH,EAAe,UACfA,EAAe,KACfA,EAAe,OACfA,EAAe,GACjB,EAAG,CACD,MAAMU,EAAQ,KAAK,OAAO,IAAIP,CAAQ,EACtC,KAAOO,EAAM,OAAS,GAAKI,EAAQ,OAAS,KAAK,cAC/CA,EAAQ,KAAKJ,EAAM,MAAM,CAAC,CAE9B,KACK,CAEL,MAAMW,EAAa,CAAC,EAGpB,UAAWX,KAAS,KAAK,OAAO,OAAO,EACrC,KAAOA,EAAM,OAAS,GACpBW,EAAW,KAAKX,EAAM,MAAM,CAAC,EAQjC,IAHAW,EAAW,KAAK,CAACC,EAAGC,IAAMD,EAAE,SAAWC,EAAE,QAAQ,EAG1CF,EAAW,OAAS,GAAKP,EAAQ,OAAS,KAAK,cACpDA,EAAQ,KAAKO,EAAW,MAAM,CAAC,EAIjC,UAAWb,KAAUa,EACL,KAAK,OAAO,IAAIb,EAAO,QAAQ,EACvC,KAAKA,CAAM,CAErB,CAEA,OAAOM,CACT,CASE,OAAOU,EAAU,CACf,UAAWd,KAAS,KAAK,OAAO,OAAO,EAAG,CACxC,MAAMG,EAAQH,EAAM,UAAUe,GAAKA,EAAE,KAAOD,CAAQ,EACpD,GAAIX,IAAU,GACZ,OAAAH,EAAM,OAAOG,EAAO,CAAC,EACrB,KAAK,QAAQ,UACN,EAEX,CAGA,UAAWD,KAAS,KAAK,eAAgB,CACvC,MAAMC,EAAQD,EAAM,QAAQ,UAAUa,GAAKA,EAAE,KAAOD,CAAQ,EAC5D,GAAIX,IAAU,GACZ,OAAAD,EAAM,QAAQ,OAAOC,EAAO,CAAC,EAC7B,KAAK,QAAQ,UACN,EAEX,CAEA,MAAO,EACT,CAOD,YAAYR,EAAS,CACpB,IAAIqB,EAAY,EAGhB,UAAWhB,KAAS,KAAK,OAAO,OAAO,EACrC,QAAS,EAAIA,EAAM,OAAS,EAAG,GAAK,EAAG,IACjCA,EAAM,CAAC,EAAE,UAAYL,IACvBK,EAAM,OAAO,EAAG,CAAC,EACjBgB,IACA,KAAK,QAAQ,WAMnB,QAASC,EAAI,KAAK,eAAe,OAAS,EAAGA,GAAK,EAAGA,IACnD,GAAI,KAAK,eAAeA,CAAC,EAAE,KAAOtB,EAAS,CACzC,KAAK,eAAe,OAAOsB,EAAG,CAAC,EAC/B,KACF,CAGF,OAAOD,CACT,CAME,UAAW,CACT,IAAIE,EAAc,CAChB,QAAS,GACT,eAAgB,EAChB,YAAa,EACb,WAAY,EACZ,KAAM,CACR,EAEA,MAAMb,EAAY,YAAY,IAAI,EAGlC,KAAO,KAAK,WAAW,GAAG,CACxB,MAAMc,EAAS,KAAK,MAAM,EAC1B,GAAI,CAACA,EAAO,QAAS,CACnBD,EAAY,QAAU,GACtB,KACF,CAOA,GALAA,EAAY,gBAAkBC,EAAO,UACrCD,EAAY,aAAeC,EAAO,OAClCD,EAAY,aAGRA,EAAY,WAAa,IAAM,CACjCA,EAAY,QAAU,GACtBA,EAAY,QAAU,0BACtB,KACF,CACF,CAEA,OAAAA,EAAY,KAAO,YAAY,IAAI,EAAIb,EAChCa,CACT,CAMA,YAAa,CAEX,UAAWlB,KAAS,KAAK,OAAO,OAAO,EACrC,GAAIA,EAAM,OAAS,EAAG,MAAO,GAO/B,OAHI,KAAK,eAAe,OAAS,GAG7B,KAAK,aAAa,KAAK,EAAI,CAGjC,CAMA,iBAAkB,CAChB,IAAIoB,EAAQ,EAEZ,UAAWpB,KAAS,KAAK,OAAO,OAAO,EACrCoB,GAASpB,EAAM,OAGjB,UAAWE,KAAS,KAAK,eACvBkB,GAASlB,EAAM,KAAK,EAGtB,OAAAkB,GAAS,KAAK,aAAa,KAAK,EACzBA,CACT,CAMA,eAAgB,CACd,MAAMC,EAAQ,CACZ,MAAO,EACP,WAAY,CAAC,EACb,QAAS,CACX,EAEA,SAAW,CAAC5B,EAAUO,CAAK,IAAK,KAAK,OACnCqB,EAAM,WAAW5B,CAAQ,EAAIO,EAAM,OACnCqB,EAAM,OAASrB,EAAM,OAGvB,OAAAqB,EAAM,QAAU,KAAK,eAAe,OAAO,CAACC,EAAKT,IAAMS,EAAMT,EAAE,KAAK,EAAG,CAAC,EACxEQ,EAAM,OAASA,EAAM,QAEdA,CACT,CAMA,YAAa,CACX,MAAO,CACL,GAAG,KAAK,QACR,QAAS,KAAK,gBAAgB,EAC9B,aAAc,KAAK,YACrB,CACF,CAKA,OAAQ,CACN,KAAK,OAAO,QAAQrB,GAASA,EAAM,OAAS,CAAC,EAC7C,KAAK,eAAe,OAAS,EAC7B,KAAK,aAAa,MAAM,EACxB,KAAK,aAAe,GACpB,KAAK,eAAiB,GAGtB,KAAK,QAAU,CACb,aAAc,EACd,aAAc,EACd,UAAW,EACX,YAAa,EACb,QAAS,IACT,QAAS,EACT,OAAQ,EACR,QAAS,CACX,CACF,CAKA,cAAe,CACb,KAAK,QAAU,CACb,aAAc,EACd,aAAc,EACd,UAAW,EACX,YAAa,EACb,QAAS,IACT,QAAS,EACT,OAAQ,EACR,QAAS,CACX,CACF,CAMA,OAAQ,CACN,MAAMI,EAAU,CAAC,EAEjB,UAAWJ,KAAS,KAAK,OAAO,OAAO,EACrCI,EAAQ,KAAK,GAAGJ,EAAM,OAAO,CAAC,CAAC,EAGjC,UAAWE,KAAS,KAAK,eACvBE,EAAQ,KAAK,GAAGF,EAAM,QAAQ,OAAO,CAAC,CAAC,EAGzC,OAAAE,EAAQ,KAAK,GAAG,KAAK,aAAa,QAAQ,OAAO,CAAC,CAAC,EAE5CA,CACT,CAMA,cAAe,CACb,OAAO,IAAI,QAASmB,GAAY,CAC9B,GAAI,CAAC,KAAK,WAAW,GAAK,CAAC,KAAK,aAAc,CAC5CA,EAAQ,EAAI,EACZ,MACF,CAEA,MAAMC,EAAgB,IAAM,CACtB,CAAC,KAAK,WAAW,GAAK,CAAC,KAAK,aAC9BD,EAAQ,EAAI,EAEZ,sBAAsBC,CAAa,CAEvC,EAEAA,EAAc,CAChB,CAAC,CACH,CAQA,cAAc/B,EAAWH,EAAe,OAAQ,CAC9C,MAAO,CAACE,EAAUE,EAAK,OAAS,KAAK,SAASF,EAAUC,EAAUC,CAAE,CACtE,CACF,CAGI,OAAO,OAAW,KAAe,OAAO,UAC1C,OAAO,QAAU,CACf,gBAAAE,EACA,cAAAL,EACA,YAAAM,EACA,eAAAP,CACF,GAEE,OAAO,OAAW,MACpB,OAAO,gBAAkBM,EACzB,OAAO,eAAiBN",
  "names": ["UpdatePriority", "UpdateRequest", "callback", "priority", "id", "batchId", "UpdateScheduler", "UpdateBatch", "update", "options", "queue", "callbacks", "batch", "index", "updates", "startTime", "toProcess", "error", "results", "e", "elapsedTime", "allUpdates", "a", "b", "updateId", "u", "cancelled", "i", "totalResult", "result", "count", "stats", "sum", "resolve", "checkComplete"]
}
