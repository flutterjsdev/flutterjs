// ============================================================================
// VNODE DIFFER - Compares old and new VNode trees and generates patches
// Layer: RECONCILIATION
// Implements efficient diffing like React's reconciliation algorithm
// ============================================================================

import { VNode } from './vnode.js';
import { VNodeRenderer } from "./vnode_renderer.js";

/**
 * Patch types generated by differ
 */
const PatchType = {
  CREATE: 'CREATE',          // New node added
  REMOVE: 'REMOVE',          // Node removed
  REPLACE: 'REPLACE',        // Node type changed
  UPDATE_PROPS: 'UPDATE_PROPS',  // Props changed
  UPDATE_TEXT: 'UPDATE_TEXT',    // Text content changed
  UPDATE_EVENTS: 'UPDATE_EVENTS', // Event handlers changed
  REORDER: 'REORDER'         // Children reordered
};

class Patch {
  constructor(type, index, node, value = null) {
    this.type = type;
    this.index = index;        // Position in parent's children
    this.node = node;          // VNode or old VNode
    this.value = value;        // New value (props, events, etc.)
  }
}

class VNodeDiffer {
  /**
   * Diff two VNode trees and generate patches
   * Returns array of Patch objects that can be applied to DOM
   */
  static diff(oldVNode, newVNode, index = 0) {
    const patches = [];

    // Helper to log patches (remove in production)
    const logPatches = (p, source) => {
      if (p.length > 0) {
        console.log(`[VNodeDiffer] ðŸ©¹ Generated ${p.length} patches from ${source}:`,
          p.map(x => `${x.type} @ ${x.index} (${x.node?.tag || 'text'})`).join(', '));
      }
    };

    // Handle null/undefined cases
    if (!oldVNode && !newVNode) {
      return patches;
    }

    // New node added
    if (!oldVNode && newVNode) {
      patches.push(new Patch(PatchType.CREATE, index, newVNode));
      return patches;
    }

    // Node removed
    if (oldVNode && !newVNode) {
      patches.push(new Patch(PatchType.REMOVE, index, oldVNode));
      return patches;
    }

    // Handle text nodes
    if (typeof oldVNode === 'string' || typeof oldVNode === 'number') {
      if (oldVNode !== newVNode) {
        patches.push(
          new Patch(PatchType.UPDATE_TEXT, index, oldVNode, newVNode)
        );
      }
      return patches;
    }

    // Both are VNodes - check if same type
    if (oldVNode instanceof VNode && newVNode instanceof VNode) {
      if (oldVNode.tag !== newVNode.tag) {
        // Completely different elements
        patches.push(new Patch(PatchType.REPLACE, index, oldVNode, newVNode));
        logPatches(patches, 'diffVNode');
        return patches;
      }

      // Same element type - check children and props
      const propPatches = this.diffProps(oldVNode, newVNode, index);
      patches.push(...propPatches);

      const eventPatches = this.diffEvents(oldVNode, newVNode, index);
      patches.push(...eventPatches);

      const childPatches = this.diffChildren(
        oldVNode.children,
        newVNode.children,
        index
      );
      patches.push(...childPatches);

      return patches;
    }

    // Fallback: replace if completely different
    patches.push(new Patch(PatchType.REPLACE, index, oldVNode, newVNode));
    logPatches(patches, 'fallback');
    return patches;
  }

  /**
   * Diff props between old and new VNode
   */
  static diffProps(oldVNode, newVNode, index) {
    const patches = [];
    const oldProps = oldVNode.props || {};
    const newProps = newVNode.props || {};

    // Check if props changed
    const propsChanged = this.hasPropsChanged(oldProps, newProps);
    if (propsChanged) {
      patches.push(
        new Patch(PatchType.UPDATE_PROPS, index, oldVNode, {
          old: oldProps,
          new: newProps
        })
      );
    }

    return patches;
  }

  /**
   * Diff events between old and new VNode
   */
  static diffEvents(oldVNode, newVNode, index) {
    const patches = [];
    const oldEvents = oldVNode.events || {};
    const newEvents = newVNode.events || {};

    const eventsChanged = this.hasEventsChanged(oldEvents, newEvents);
    if (eventsChanged) {
      patches.push(
        new Patch(PatchType.UPDATE_EVENTS, index, oldVNode, {
          old: oldEvents,
          new: newEvents
        })
      );
    }

    return patches;
  }

  /**
   * Diff children using key-based or position-based reconciliation
   */
  static diffChildren(oldChildren = [], newChildren = [], parentIndex) {
    const patches = [];

    // Use keys for reconciliation if available
    const oldKeyed = this.groupByKey(oldChildren);
    const newKeyed = this.groupByKey(newChildren);

    const maxLen = Math.max(oldChildren.length, newChildren.length);

    for (let i = 0; i < maxLen; i++) {
      const oldChild = oldChildren[i];
      const newChild = newChildren[i];
      const childIndex = `${parentIndex}.${i}`;

      if (!oldChild && newChild) {
        // New child added
        patches.push(new Patch(PatchType.CREATE, childIndex, newChild));
      } else if (oldChild && !newChild) {
        // Child removed
        patches.push(new Patch(PatchType.REMOVE, childIndex, oldChild));
      } else if (oldChild && newChild) {
        // Recursively diff
        const childPatches = this.diff(oldChild, newChild, childIndex);
        patches.push(...childPatches);
      }
    }

    return patches;
  }

  /**
   * Group VNodes by key for efficient reconciliation
   */
  static groupByKey(vnodes = []) {
    const keyed = new Map();
    const unkeyed = [];

    vnodes.forEach(vnode => {
      if (vnode instanceof VNode && vnode.key) {
        keyed.set(vnode.key, vnode);
      } else {
        unkeyed.push(vnode);
      }
    });

    return { keyed, unkeyed };
  }

  /**
   * Check if props have changed
   */
  static hasPropsChanged(oldProps, newProps) {
    const allKeys = new Set([
      ...Object.keys(oldProps),
      ...Object.keys(newProps)
    ]);

    for (const key of allKeys) {
      if (oldProps[key] !== newProps[key]) {
        return true;
      }
    }

    return false;
  }

  /**
   * Check if events have changed
   */
  static hasEventsChanged(oldEvents, newEvents) {
    const allKeys = new Set([
      ...Object.keys(oldEvents),
      ...Object.keys(newEvents)
    ]);

    for (const key of allKeys) {
      if (oldEvents[key] !== newEvents[key]) {
        return true;
      }
    }

    return false;
  }

  /**
   * Apply patches to DOM
   * Called after diff to update actual DOM
   */
  static applyPatches(domElement, patches, vNodeMap = new Map()) {
    patches.forEach(patch => {
      const targetElement = this.findElement(domElement, patch.index);

      if (!targetElement) {
        console.warn(`Could not find element at index ${patch.index}`);
        return;
      }

      switch (patch.type) {
        case PatchType.CREATE:
          this.applyCreate(targetElement, patch);
          break;

        case PatchType.REMOVE:
          this.applyRemove(targetElement, patch);
          break;

        case PatchType.REPLACE:
          this.applyReplace(targetElement, patch);
          break;

        case PatchType.UPDATE_PROPS:
          this.applyUpdateProps(targetElement, patch);
          break;

        case PatchType.UPDATE_TEXT:
          this.applyUpdateText(targetElement, patch);
          break;

        case PatchType.UPDATE_EVENTS:
          this.applyUpdateEvents(targetElement, patch);
          break;

        case PatchType.REORDER:
          this.applyReorder(targetElement, patch);
          break;
      }
    });
  }

  /**
   * Find DOM element by index path
   * Index format: "0.1.2" means: root's 0th child's 1st child's 2nd child
   */
  static findElement(root, index) {
    if (index === 0 || index === '0') {
      return root;
    }

    const path = String(index).split('.');
    let current = root;

    for (const step of path) {
      const childIndex = parseInt(step);
      current = current.childNodes[childIndex];

      if (!current) {
        return null;
      }
    }

    return current;
  }

  /**
   * Apply CREATE patch
   */
  static applyCreate(parent, patch) {


    const newDom = VNodeRenderer.createDOMNode(patch.node);

    if (parent.childNodes.length === 0) {
      parent.appendChild(newDom);
    } else {
      const childIndex = parseInt(String(patch.index).split('.').pop());
      if (childIndex < parent.childNodes.length) {
        parent.insertBefore(newDom, parent.childNodes[childIndex]);
      } else {
        parent.appendChild(newDom);
      }
    }
  }

  /**
   * Apply REMOVE patch
   */
  static applyRemove(parent, patch) {
    const childIndex = parseInt(String(patch.index).split('.').pop());
    if (parent.childNodes[childIndex]) {
      parent.removeChild(parent.childNodes[childIndex]);
    }
  }

  /**
   * Apply REPLACE patch
   */
  static applyReplace(parent, patch) {

    const childIndex = parseInt(String(patch.index).split('.').pop());
    const oldChild = parent.childNodes[childIndex];

    if (oldChild) {
      const newDom = VNodeRenderer.createDOMNode(patch.value);
      parent.replaceChild(newDom, oldChild);
    }
  }

  /**
   * Apply UPDATE_PROPS patch
   */
  static applyUpdateProps(element, patch) {

    VNodeRenderer.updateProps(element, patch.value.old, patch.value.new);
  }

  /**
   * Apply UPDATE_TEXT patch
   */
  static applyUpdateText(element, patch) {
    element.textContent = String(patch.value);
  }

  /**
   * Apply UPDATE_EVENTS patch
   */
  static applyUpdateEvents(element, patch) {

    VNodeRenderer.updateEvents(element, patch.value.old, patch.value.new);
  }

  /**
   * Apply REORDER patch
   */
  static applyReorder(parent, patch) {
    // Reorder children according to new indices
    const newOrder = patch.value;
    const fragment = document.createDocumentFragment();

    newOrder.forEach(index => {
      fragment.appendChild(parent.childNodes[index]);
    });

    parent.appendChild(fragment);
  }

  /**
   * Get statistics about patches (for debugging)
   */
  static getStats(patches) {
    const stats = {
      total: patches.length,
      creates: 0,
      removes: 0,
      replaces: 0,
      updates: 0
    };

    patches.forEach(patch => {
      if (patch.type === PatchType.CREATE) stats.creates++;
      else if (patch.type === PatchType.REMOVE) stats.removes++;
      else if (patch.type === PatchType.REPLACE) stats.replaces++;
      else stats.updates++;
    });

    return stats;
  }
}


export { VNodeDiffer, Patch, PatchType };