/**
 * PatchApplier - Applies VNode patches to actual DOM
 * 
 * Transforms patches generated by VNodeDiffer into real DOM mutations.
 * Handles:
 * - Element creation, removal, replacement
 * - Property and style updates
 * - Event handler attachment/removal
 * - Text content updates
 * - Memory cleanup
 * - Batch operations for performance
 */

import { VNode } from './vnode.js';
import { VNodeRenderer } from './vnode-renderer.js';
import { PatchType } from './vnode-differ.js';

/**
 * PatchApplier - Applies patches to DOM with performance optimizations
 */
class PatchApplier {
  /**
   * Apply patches to DOM in order
   * Handles all patch types and maintains DOM consistency
   * 
   * @param {HTMLElement} rootElement - Root DOM element
   * @param {Patch[]} patches - Array of patches from VNodeDiffer
   * @param {Object} options - Application options
   * @returns {Object} Result with stats
   */
  static apply(rootElement, patches, options = {}) {
    if (!rootElement || !Array.isArray(patches)) {
      console.warn('Invalid apply arguments');
      return { success: false, patchesApplied: 0 };
    }

    const {
      batchSize = Infinity,  // Group patches by type for efficiency
      trackChanges = false,  // Track which elements changed
      measureTime = false    // Measure application time
    } = options;

    const startTime = measureTime ? performance.now() : 0;
    const changedElements = trackChanges ? new Set() : null;
    let patchesApplied = 0;

    try {
      // Group patches by element to minimize DOM traversals
      const patchesByElement = this.groupPatchesByElement(patches);

      // Apply patches in optimal order:
      // 1. Removes (bottom-up to preserve indices)
      // 2. Creates (add new elements)
      // 3. Replaces (full replacement)
      // 4. Updates (minimal changes)
      
      const orderedPatches = this.orderPatches(patches);

      orderedPatches.forEach((patch, index) => {
        try {
          const targetElement = this.findElementByIndex(rootElement, patch.index);

          if (!targetElement && patch.type !== PatchType.CREATE) {
            console.warn(`Element not found at ${patch.index}`);
            return;
          }

          // Apply the patch
          const changed = this.applyPatch(rootElement, targetElement, patch);

          if (trackChanges && changed) {
            changedElements.add(changed);
          }

          patchesApplied++;
        } catch (error) {
          console.error(`Error applying patch ${index} (${patch.type}):`, error);
        }
      });

      const endTime = measureTime ? performance.now() : 0;

      return {
        success: true,
        patchesApplied,
        totalPatches: patches.length,
        changedElements: changedElements ? changedElements.size : 0,
        timeMs: measureTime ? (endTime - startTime).toFixed(2) : 0
      };
    } catch (error) {
      console.error('Fatal error applying patches:', error);
      return { success: false, patchesApplied, error: error.message };
    }
  }

  /**
   * Apply single patch to DOM
   * @private
   * @returns {HTMLElement|null} Changed element or null
   */
  static applyPatch(rootElement, targetElement, patch) {
    switch (patch.type) {
      case PatchType.CREATE:
        return this.applyCreate(rootElement, patch);

      case PatchType.REMOVE:
        return this.applyRemove(targetElement, patch);

      case PatchType.REPLACE:
        return this.applyReplace(targetElement, patch);

      case PatchType.UPDATE_PROPS:
        return this.applyUpdateProps(targetElement, patch);

      case PatchType.UPDATE_STYLE:
        return this.applyUpdateStyle(targetElement, patch);

      case PatchType.UPDATE_TEXT:
        return this.applyUpdateText(targetElement, patch);

      case PatchType.UPDATE_EVENTS:
        return this.applyUpdateEvents(targetElement, patch);

      case PatchType.REORDER:
        return this.applyReorder(targetElement, patch);

      default:
        console.warn(`Unknown patch type: ${patch.type}`);
        return null;
    }
  }

  /**
   * Order patches for optimal application
   * Removes first (bottom-up), then creates, replaces, updates
   * @private
   */
  static orderPatches(patches) {
    const ordered = [];

    // 1. Removes (sorted by depth, deepest first to preserve indices)
    const removes = patches
      .filter(p => p.type === PatchType.REMOVE)
      .sort((a, b) => {
        const depthA = String(a.index).split('.').length;
        const depthB = String(b.index).split('.').length;
        return depthB - depthA;
      });
    ordered.push(...removes);

    // 2. Replaces
    ordered.push(...patches.filter(p => p.type === PatchType.REPLACE));

    // 3. Creates
    ordered.push(...patches.filter(p => p.type === PatchType.CREATE));

    // 4. Updates (props, styles, text, events)
    ordered.push(...patches.filter(p => 
      p.type === PatchType.UPDATE_PROPS ||
      p.type === PatchType.UPDATE_STYLE ||
      p.type === PatchType.UPDATE_TEXT ||
      p.type === PatchType.UPDATE_EVENTS
    ));

    // 5. Reorders
    ordered.push(...patches.filter(p => p.type === PatchType.REORDER));

    return ordered;
  }

  /**
   * Group patches by element index
   * Allows processing multiple changes to same element together
   * @private
   */
  static groupPatchesByElement(patches) {
    const grouped = new Map();

    patches.forEach(patch => {
      if (!grouped.has(patch.index)) {
        grouped.set(patch.index, []);
      }
      grouped.get(patch.index).push(patch);
    });

    return grouped;
  }

  /**
   * Find DOM element by index path
   * Path format: "0.1.2" = root's 0th child's 1st child's 2nd child
   * @private
   */
  static findElementByIndex(root, index) {
    if (!index || index === '0' || index === 0) {
      return root;
    }

    const indices = String(index).split('.').map(Number).slice(1);
    let current = root;

    for (const i of indices) {
      if (!current || i >= current.childNodes.length) {
        return null;
      }
      current = current.childNodes[i];
    }

    return current;
  }

  /**
   * Get parent element from index path
   * @private
   */
  static findParentByIndex(root, index) {
    const indices = String(index).split('.').map(Number);
    indices.pop(); // Remove last index to get parent

    return this.findElementByIndex(root, indices.join('.'));
  }

  /**
   * Apply CREATE patch - add new element to DOM
   * @private
   */
  static applyCreate(rootElement, patch) {
    const parentIndex = String(patch.index).split('.').slice(0, -1).join('.');
    const parentElement = this.findElementByIndex(rootElement, parentIndex);

    if (!parentElement) {
      console.warn(`Parent not found for CREATE at ${patch.index}`);
      return null;
    }

    // Create new DOM from VNode
    const newElement = VNodeRenderer.createDOMNode(patch.newNode);
    if (!newElement) return null;

    // Determine insertion position
    const childIndex = parseInt(String(patch.index).split('.').pop());

    if (childIndex >= parentElement.childNodes.length) {
      parentElement.appendChild(newElement);
    } else {
      parentElement.insertBefore(
        newElement,
        parentElement.childNodes[childIndex]
      );
    }

    return newElement;
  }

  /**
   * Apply REMOVE patch - delete element from DOM
   * @private
   */
  static applyRemove(element, patch) {
    if (!element || !element.parentNode) {
      return null;
    }

    // Cleanup before removal
    VNodeRenderer.cleanupEventListeners(element);

    const parent = element.parentNode;
    parent.removeChild(element);

    return parent;
  }

  /**
   * Apply REPLACE patch - replace element entirely
   * @private
   */
  static applyReplace(element, patch) {
    if (!element || !element.parentNode) {
      return null;
    }

    // Create new element
    const newElement = VNodeRenderer.createDOMNode(patch.newNode);
    if (!newElement) return null;

    // Cleanup old element
    VNodeRenderer.cleanupEventListeners(element);

    // Replace in DOM
    const parent = element.parentNode;
    parent.replaceChild(newElement, element);

    return newElement;
  }

  /**
   * Apply UPDATE_PROPS patch - update HTML attributes
   * @private
   */
  static applyUpdateProps(element, patch) {
    if (!element || !patch.value) {
      return null;
    }

    const { changes } = patch.value;

    if (!changes) {
      return element;
    }

    // Remove properties that were deleted
    if (changes.removed) {
      Object.keys(changes.removed).forEach(key => {
        this.removeProp(element, key);
      });
    }

    // Update changed properties
    if (changes.updated) {
      Object.entries(changes.updated).forEach(([key, value]) => {
        this.setProp(element, key, value);
      });
    }

    // Add new properties
    if (changes.added) {
      Object.entries(changes.added).forEach(([key, value]) => {
        this.setProp(element, key, value);
      });
    }

    return element;
  }

  /**
   * Set a single property on element
   * @private
   */
  static setProp(element, key, value) {
    // Special handling for className
    if (key === 'className' || key === 'class') {
      element.className = value;
      return;
    }

    // Special handling for value (inputs)
    if (key === 'value' && 
        (element.tagName === 'INPUT' || 
         element.tagName === 'TEXTAREA' || 
         element.tagName === 'SELECT')) {
      element.value = value;
      return;
    }

    // Special handling for checked (checkboxes/radios)
    if (key === 'checked' && element.tagName === 'INPUT') {
      element.checked = !!value;
      return;
    }

    // Special handling for selected (options)
    if (key === 'selected' && element.tagName === 'OPTION') {
      element.selected = !!value;
      return;
    }

    // Special handling for disabled
    if (key === 'disabled') {
      element.disabled = !!value;
      return;
    }

    // Data and ARIA attributes
    if (key.startsWith('data-') || key.startsWith('aria-')) {
      element.setAttribute(key, String(value));
      return;
    }

    // Boolean attributes
    if (typeof value === 'boolean') {
      if (value) {
        element.setAttribute(key, '');
      } else {
        element.removeAttribute(key);
      }
      return;
    }

    // Try property first, fallback to attribute
    try {
      if (key in element) {
        element[key] = value;
      } else {
        element.setAttribute(key, String(value));
      }
    } catch (error) {
      console.warn(`Failed to set property ${key}:`, error);
      try {
        element.setAttribute(key, String(value));
      } catch (e) {
        console.error(`Failed to set attribute ${key}:`, e);
      }
    }
  }

  /**
   * Remove a property from element
   * @private
   */
  static removeProp(element, key) {
    // Special handling for className
    if (key === 'className' || key === 'class') {
      element.className = '';
      return;
    }

    // Special handling for value
    if (key === 'value' && 
        (element.tagName === 'INPUT' || 
         element.tagName === 'TEXTAREA')) {
      element.value = '';
      return;
    }

    // Special handling for checked
    if (key === 'checked' && element.tagName === 'INPUT') {
      element.checked = false;
      return;
    }

    // Data and ARIA attributes
    if (key.startsWith('data-') || key.startsWith('aria-')) {
      element.removeAttribute(key);
      return;
    }

    // Boolean attributes
    if (typeof element[key] === 'boolean') {
      element.removeAttribute(key);
      return;
    }

    // Try to remove
    try {
      if (key in element) {
        element[key] = '';
      } else {
        element.removeAttribute(key);
      }
    } catch (error) {
      console.warn(`Failed to remove property ${key}:`, error);
      try {
        element.removeAttribute(key);
      } catch (e) {
        // Silent fail for attributes we can't remove
      }
    }
  }

  /**
   * Apply UPDATE_STYLE patch - update CSS styles
   * @private
   */
  static applyUpdateStyle(element, patch) {
    if (!element || !patch.value) {
      return null;
    }

    const { changes } = patch.value;

    if (!changes) {
      return element;
    }

    // Remove styles that were deleted
    if (changes.removed) {
      Object.keys(changes.removed).forEach(key => {
        element.style[key] = '';
      });
    }

    // Update changed styles
    if (changes.updated) {
      Object.entries(changes.updated).forEach(([key, value]) => {
        try {
          element.style[key] = value;
        } catch (error) {
          console.warn(`Failed to set style ${key}:`, error);
        }
      });
    }

    // Add new styles
    if (changes.added) {
      Object.entries(changes.added).forEach(([key, value]) => {
        try {
          element.style[key] = value;
        } catch (error) {
          console.warn(`Failed to set style ${key}:`, error);
        }
      });
    }

    return element;
  }

  /**
   * Apply UPDATE_TEXT patch - update text content
   * @private
   */
  static applyUpdateText(element, patch) {
    if (!element) {
      return null;
    }

    element.textContent = String(patch.newNode || '');
    return element;
  }

  /**
   * Apply UPDATE_EVENTS patch - attach/detach event listeners
   * @private
   */
  static applyUpdateEvents(element, patch) {
    if (!element || !patch.value) {
      return null;
    }

    const { changes } = patch.value;

    if (!changes) {
      return element;
    }

    // Remove old event listeners
    if (changes.removed) {
      Object.keys(changes.removed).forEach(eventName => {
        this.removeEventListener(element, eventName);
      });
    }

    // Update event listeners
    if (changes.updated) {
      Object.entries(changes.updated).forEach(([eventName, handler]) => {
        this.removeEventListener(element, eventName);
        if (handler) {
          this.addEventListener(element, eventName, handler);
        }
      });
    }

    // Add new event listeners
    if (changes.added) {
      Object.entries(changes.added).forEach(([eventName, handler]) => {
        if (handler) {
          this.addEventListener(element, eventName, handler);
        }
      });
    }

    return element;
  }

  /**
   * Attach event listener to element
   * @private
   */
  static addEventListener(element, eventName, handler) {
    if (typeof handler !== 'function') {
      return;
    }

    try {
      // Normalize event name (onClick -> click)
      const normalizedName = eventName
        .replace(/^on/, '')
        .toLowerCase();

      // Store listener reference
      if (!element._eventListeners) {
        element._eventListeners = {};
      }

      // Add listener
      element.addEventListener(normalizedName, handler);
      element._eventListeners[normalizedName] = handler;
    } catch (error) {
      console.error(`Failed to attach event ${eventName}:`, error);
    }
  }

  /**
   * Remove event listener from element
   * @private
   */
  static removeEventListener(element, eventName) {
    try {
      const normalizedName = eventName
        .replace(/^on/, '')
        .toLowerCase();

      if (element._eventListeners && element._eventListeners[normalizedName]) {
        element.removeEventListener(
          normalizedName,
          element._eventListeners[normalizedName]
        );
        delete element._eventListeners[normalizedName];
      }
    } catch (error) {
      console.warn(`Failed to remove event ${eventName}:`, error);
    }
  }

  /**
   * Apply REORDER patch - reorder children
   * @private
   */
  static applyReorder(element, patch) {
    if (!element || !patch.value) {
      return null;
    }

    const newOrder = patch.value;

    try {
      const fragment = document.createDocumentFragment();

      // Collect children in new order
      newOrder.forEach(index => {
        const child = element.childNodes[index];
        if (child) {
          fragment.appendChild(child);
        }
      });

      // Clear and reappend
      element.innerHTML = '';
      element.appendChild(fragment);

      return element;
    } catch (error) {
      console.error('Failed to reorder children:', error);
      return null;
    }
  }

  /**
   * Apply patches with automatic scheduling
   * Uses requestAnimationFrame for smooth updates
   * 
   * @param {HTMLElement} rootElement - Root DOM element
   * @param {Patch[]} patches - Array of patches
   * @param {Object} options - Options
   * @returns {Promise} Resolves when patches applied
   */
  static applyAsync(rootElement, patches, options = {}) {
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        const result = this.apply(rootElement, patches, options);
        resolve(result);
      });
    });
  }

  /**
   * Batch apply multiple patch sets
   * Useful for applying patches from multiple components
   * 
   * @param {HTMLElement} rootElement - Root DOM element
   * @param {Array<Patch[]>} patchSets - Array of patch arrays
   * @param {Object} options - Options
   * @returns {Object} Combined results
   */
  static applyBatch(rootElement, patchSets, options = {}) {
    const results = [];
    let totalPatches = 0;
    let totalApplied = 0;

    patchSets.forEach(patches => {
      if (!Array.isArray(patches) || patches.length === 0) {
        return;
      }

      totalPatches += patches.length;
      const result = this.apply(rootElement, patches, options);
      results.push(result);
      totalApplied += result.patchesApplied;
    });

    return {
      success: results.every(r => r.success),
      totalPatchSets: patchSets.length,
      totalPatches,
      totalApplied,
      results
    };
  }

  /**
   * Validate that patches are correctly formed
   * Useful for debugging
   * 
   * @param {Patch[]} patches - Patches to validate
   * @returns {Array} Validation errors (empty if valid)
   */
  static validate(patches) {
    const errors = [];

    if (!Array.isArray(patches)) {
      errors.push('Patches must be an array');
      return errors;
    }

    patches.forEach((patch, i) => {
      if (!patch.type) {
        errors.push(`Patch ${i}: Missing type`);
      }

      if (patch.index === undefined || patch.index === null) {
        errors.push(`Patch ${i}: Missing index`);
      }

      const validTypes = Object.values(PatchType);
      if (!validTypes.includes(patch.type)) {
        errors.push(`Patch ${i}: Invalid type "${patch.type}"`);
      }

      if (patch.type === PatchType.CREATE && !patch.newNode) {
        errors.push(`Patch ${i}: CREATE missing newNode`);
      }

      if (patch.type === PatchType.REMOVE && !patch.oldNode) {
        errors.push(`Patch ${i}: REMOVE missing oldNode`);
      }
    });

    return errors;
  }

  /**
   * Get statistics about patches and their application
   * 
   * @param {Patch[]} patches - Patches to analyze
   * @returns {Object} Statistics
   */
  static getStats(patches) {
    const stats = {
      total: patches.length,
      byType: {}
    };

    const typeValues = Object.values(PatchType);
    typeValues.forEach(type => {
      stats.byType[type] = patches.filter(p => p.type === type).length;
    });

    return stats;
  }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
  module.exports = PatchApplier;
}
if (typeof window !== 'undefined') {
  window.PatchApplier = PatchApplier;
}