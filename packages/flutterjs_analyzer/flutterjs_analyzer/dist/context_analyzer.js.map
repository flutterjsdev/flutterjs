{
  "version": 3,
  "sources": ["../src/context_analyzer.js"],
  "sourcesContent": ["/**\r\n * FlutterJS Context Analyzer - Phase 3\r\n * Detects InheritedWidget, Provider, BuildContext usage patterns\r\n * Analyzes context flow and SSR compatibility\r\n * \r\n * Phase 3 focuses on: Context detection, Provider patterns, SSR analysis\r\n * Does NOT implement actual context providers (that's Phase 4+)\r\n */\r\nimport { getLogger } from './flutterjs_logger.js';\r\n\r\nimport {  InheritedWidgetMetadata,\r\n  ChangeNotifierAnalysis,\r\n  ProviderAnalysis,\r\n  ContextUsagePattern, } from  './context_analyzer_data.js';\r\nclass ContextAnalyzer {\r\n  constructor(ast, widgets = [], options = {}) {\r\n    this.ast = ast;\r\n    this.widgets = widgets;\r\n     this.logger = getLogger().createComponentLogger('ContextAnalyzer');\r\n    this.options = {\r\n      strict: false,\r\n      ...options,\r\n    };\r\n\r\n    // Results storage\r\n    this.inheritedWidgets = new Map();     // name -> InheritedWidgetMetadata\r\n    this.changeNotifiers = new Map();      // name -> ChangeNotifierAnalysis\r\n    this.providers = new Map();            // type -> ProviderAnalysis\r\n    this.contextAccessPoints = [];         // All places context is used\r\n    this.inheritedWidgetGraph = {};        // Inheritance relationships\r\n    this.providerGraph = {};               // Provider relationships\r\n    this.errors = [];\r\n  }\r\n\r\n  /**\r\n   * Main entry point - analyze context patterns\r\n   */\r\n  analyze() {\r\n      this.logger.startSession('ContextAnalysis');\r\n    this.logger.trace('[ContextAnalyzer] Starting analysis...\\n');\r\n      this.logger.startSession('WidgetAnalyzer');\r\n     this.logger.trace('[ContextAnalyzer] Starting analysis...\\n');\r\n\r\n    try {\r\n      // Phase 1: Detect InheritedWidget classes\r\n      this.detectInheritedWidgets();\r\n       this.logger.trace(`[ContextAnalyzer] Found ${this.inheritedWidgets.size} InheritedWidgets\\n`);\r\n\r\n      // Phase 2: Detect ChangeNotifier classes\r\n      this.detectChangeNotifiers();\r\n       this.logger.trace(`[ContextAnalyzer] Found ${this.changeNotifiers.size} ChangeNotifiers\\n`);\r\n\r\n      // Phase 3: Detect Provider patterns\r\n      this.detectProviders();\r\n       this.logger.trace(`[ContextAnalyzer] Found ${this.providers.size} Providers\\n`);\r\n\r\n      // Phase 4: Find context access points\r\n      this.findContextAccessPoints();\r\n       this.logger.trace(`[ContextAnalyzer] Found ${this.contextAccessPoints.length} context usage points\\n`);\r\n\r\n      // Phase 5: Build graphs\r\n      this.buildInheritedWidgetGraph();\r\n      this.buildProviderGraph();\r\n       this.logger.trace('[ContextAnalyzer] Built dependency graphs\\n');\r\n\r\n      return this.getResults();\r\n    } catch (error) {\r\n      this.errors.push(error);\r\n      console.error('[ContextAnalyzer] Error:', error.message);\r\n      return this.getResults();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Phase 1: Detect InheritedWidget classes\r\n   * \r\n   * Looks for:\r\n   * - class MyProvider extends InheritedWidget\r\n   * - Properties: data, child\r\n   * - Methods: of(), updateShouldNotify()\r\n   */\r\n  detectInheritedWidgets() {\r\n    if (!this.ast || !this.ast.body) return;\r\n\r\n    this.ast.body.forEach((node) => {\r\n      if (node.type !== 'ClassDeclaration') return;\r\n\r\n      const className = node.id?.name;\r\n      const superClass = node.superClass?.name;\r\n\r\n      // Check if extends InheritedWidget\r\n      if (!superClass || !superClass.includes('InheritedWidget')) return;\r\n\r\n       this.logger.trace(`[ContextAnalyzer.detectInheritedWidgets] Found: ${className}`);\r\n\r\n      const metadata = new InheritedWidgetMetadata(\r\n        className,\r\n        node.location,\r\n        superClass\r\n      );\r\n\r\n      // Extract properties\r\n      if (node.body?.fields) {\r\n        node.body.fields.forEach((field) => {\r\n          const fieldName = field.key?.name;\r\n          metadata.properties.push({\r\n            name: fieldName,\r\n            type: this.inferType(field.initialValue),\r\n            required: !this.hasDefaultValue(field),\r\n          });\r\n        });\r\n      }\r\n\r\n      // Extract static accessors (of() method)\r\n      if (node.body?.methods) {\r\n        node.body.methods.forEach((method) => {\r\n          const methodName = method.key?.name;\r\n\r\n          // Check for static accessor pattern\r\n          if (methodName === 'of' && this.isStaticAccessor(method)) {\r\n            metadata.staticAccessors.push({\r\n              name: methodName,\r\n              signature: `static ${methodName}(BuildContext context)`,\r\n              usesInheritedWidgetLookup: this.checksInheritedWidgetLookup(method),\r\n              location: method.location,\r\n            });\r\n          }\r\n\r\n          // Check for updateShouldNotify\r\n          if (methodName === 'updateShouldNotify') {\r\n            metadata.updateShouldNotifyImplemented = true;\r\n          }\r\n        });\r\n      }\r\n\r\n      this.inheritedWidgets.set(className, metadata);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if method is static (phase 3 simplified - assumes 'of' is usually static)\r\n   */\r\n  isStaticAccessor(method) {\r\n    // In a real implementation, check for @static decorator or static keyword\r\n    return method.key?.name === 'of';\r\n  }\r\n\r\n  /**\r\n   * Check if method body contains dependOnInheritedWidgetOfExactType call\r\n   */\r\n  checksInheritedWidgetLookup(method) {\r\n    if (!method.body) return false;\r\n\r\n    const code = JSON.stringify(method.body);\r\n    return code.includes('dependOnInheritedWidgetOfExactType') ||\r\n           code.includes('inheritedWidgetOfExactType');\r\n  }\r\n\r\n  /**\r\n   * Phase 2: Detect ChangeNotifier classes\r\n   * \r\n   * Looks for:\r\n   * - class MyNotifier extends ChangeNotifier\r\n   * - Methods that call notifyListeners()\r\n   * - Properties that get/set\r\n   */\r\n  detectChangeNotifiers() {\r\n    if (!this.ast || !this.ast.body) return;\r\n\r\n    this.ast.body.forEach((node) => {\r\n      if (node.type !== 'ClassDeclaration') return;\r\n\r\n      const className = node.id?.name;\r\n      const superClass = node.superClass?.name;\r\n\r\n      // Check if extends ChangeNotifier\r\n      if (!superClass || superClass !== 'ChangeNotifier') return;\r\n\r\n       this.logger.trace(`[ContextAnalyzer.detectChangeNotifiers] Found: ${className}`);\r\n\r\n      const analysis = new ChangeNotifierAnalysis(\r\n        className,\r\n        node.location\r\n      );\r\n\r\n      // Extract properties\r\n      if (node.body?.fields) {\r\n        node.body.fields.forEach((field) => {\r\n          const fieldName = field.key?.name;\r\n          analysis.properties.push({\r\n            name: fieldName,\r\n            type: this.inferType(field.initialValue),\r\n            initialValue: this.expressionToString(field.initialValue),\r\n          });\r\n        });\r\n      }\r\n\r\n      // Extract getters, methods, and notifyListeners calls\r\n      if (node.body?.methods) {\r\n        node.body.methods.forEach((method) => {\r\n          const methodName = method.key?.name;\r\n\r\n          // Check for getter pattern (get count => _count)\r\n          if (methodName && !method.params?.length && method.body) {\r\n            const isGetter = JSON.stringify(method).includes('return');\r\n            if (isGetter) {\r\n              analysis.getters.push({\r\n                name: methodName,\r\n                returnType: this.inferReturnType(method.body),\r\n                location: method.location,\r\n              });\r\n            }\r\n          }\r\n\r\n          // Check for notifyListeners call\r\n          const callsNotify = this.callsNotifyListeners(method.body);\r\n          if (callsNotify || methodName === 'increment' || methodName === 'decrement') {\r\n            const mutations = this.extractMutationsInMethod(method.body);\r\n            analysis.methods.push({\r\n              name: methodName,\r\n              callsNotifyListeners: callsNotify,\r\n              location: method.location,\r\n              mutations: mutations,\r\n            });\r\n          }\r\n        });\r\n      }\r\n\r\n      this.changeNotifiers.set(className, analysis);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if method calls notifyListeners()\r\n   */\r\n  callsNotifyListeners(body) {\r\n    if (!body) return false;\r\n    const code = JSON.stringify(body);\r\n    return code.includes('notifyListeners');\r\n  }\r\n\r\n  /**\r\n   * Extract field mutations in method (this._field = x, this._field++, etc.)\r\n   */\r\n  extractMutationsInMethod(body) {\r\n    const mutations = [];\r\n    if (!body) return mutations;\r\n\r\n    const code = JSON.stringify(body);\r\n    \r\n    // Simple pattern matching for mutations\r\n    const patterns = [\r\n      /this\\._(\\w+)\\s*[=+\\-*]/g,  // this._field = or +=, -=, etc.\r\n      /this\\.(\\w+)\\s*[=+\\-*]/g,   // this.field = or +=, -=, etc.\r\n    ];\r\n\r\n    patterns.forEach((pattern) => {\r\n      let match;\r\n      while ((match = pattern.exec(code)) !== null) {\r\n        mutations.push(match[1]);\r\n      }\r\n    });\r\n\r\n    return [...new Set(mutations)]; // Remove duplicates\r\n  }\r\n\r\n  /**\r\n   * Phase 3: Detect Provider<T> patterns\r\n   * \r\n   * Looks for:\r\n   * - Provider<CounterNotifier>(create: ..., child: ...)\r\n   * - Detects consumer patterns: context.watch(), context.read()\r\n   */\r\n  detectProviders() {\r\n    if (!this.ast || !this.ast.body) return;\r\n\r\n    this.ast.body.forEach((node) => {\r\n      if (node.type === 'ClassDeclaration') {\r\n        // Check if class contains Provider creation in build()\r\n        const buildMethod = node.body?.methods?.find((m) => m.key?.name === 'build');\r\n        if (buildMethod) {\r\n          this.findProvidersInMethod(buildMethod, node);\r\n        }\r\n      }\r\n\r\n      // Also check in function bodies\r\n      if (node.type === 'FunctionDeclaration') {\r\n        this.findProvidersInMethod(node, null);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find Provider instantiations in a method\r\n   */\r\n  findProvidersInMethod(method, classNode) {\r\n    if (!method.body) return;\r\n\r\n    const body = method.body.type === 'BlockStatement' ? method.body.body : [method.body];\r\n\r\n    body.forEach((stmt) => {\r\n      this.findProvidersInStatement(stmt);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Recursively find Provider patterns in statements\r\n   */\r\n  findProvidersInStatement(stmt) {\r\n    if (!stmt) return;\r\n\r\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n      this.findProvidersInExpression(stmt.expression);\r\n    }\r\n\r\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\r\n      this.findProvidersInExpression(stmt.argument);\r\n    }\r\n\r\n    if (stmt.type === 'BlockStatement' && stmt.body) {\r\n      stmt.body.forEach((s) => this.findProvidersInStatement(s));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find Provider patterns in expressions\r\n   * Looks for: new Provider<CounterNotifier>(...)\r\n   */\r\n  findProvidersInExpression(expr) {\r\n    if (!expr) return;\r\n\r\n    // Check for NewExpression: new Provider<T>(...)\r\n    if (expr.type === 'NewExpression') {\r\n      const calleeName = expr.callee?.name;\r\n\r\n      if (calleeName === 'Provider' || calleeName?.startsWith('Provider')) {\r\n        // Extract generic type: Provider<CounterNotifier>\r\n        const genericType = this.extractGenericType(expr);\r\n\r\n        if (genericType) {\r\n           this.logger.trace(`[ContextAnalyzer.detectProviders] Found Provider<${genericType}>`);\r\n\r\n          const analysis = new ProviderAnalysis(\r\n            `Provider<${genericType}>`,\r\n            expr.location,\r\n            genericType\r\n          );\r\n\r\n          // Extract create function\r\n          if (expr.args) {\r\n            expr.args.forEach((arg) => {\r\n              if (arg.type === 'ObjectLiteral') {\r\n                arg.properties?.forEach((prop) => {\r\n                  if (prop.key?.name === 'create') {\r\n                    analysis.createFunction = this.expressionToString(prop.value);\r\n                  }\r\n                  if (prop.key?.name === 'child') {\r\n                    // Child widget - may use this provider\r\n                  }\r\n                });\r\n              }\r\n            });\r\n          }\r\n\r\n          // Identify access patterns (watch, read, select)\r\n          this.identifyAccessPatterns(genericType, analysis);\r\n\r\n          this.providers.set(`Provider<${genericType}>`, analysis);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check call expressions\r\n    if (expr.type === 'CallExpression' && expr.args) {\r\n      expr.args.forEach((arg) => {\r\n        this.findProvidersInExpression(arg);\r\n      });\r\n    }\r\n\r\n    // Check object literals\r\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\r\n      expr.properties.forEach((prop) => {\r\n        this.findProvidersInExpression(prop.value);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract generic type from Provider<T>\r\n   * In simplified version, returns T or null\r\n   */\r\n  extractGenericType(expr) {\r\n    // In real implementation, parse the full generic syntax\r\n    // For now, look for the callee name pattern\r\n    const code = JSON.stringify(expr.callee);\r\n\r\n    // Simple heuristic: if it mentions Provider and contains type info\r\n    if (code.includes('Provider')) {\r\n      // Try to find type in expression string representation\r\n      const exprStr = this.expressionToString(expr.callee);\r\n      const match = exprStr.match(/Provider<(\\w+)>/);\r\n      return match ? match[1] : null;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Identify how this provider is consumed\r\n   */\r\n  identifyAccessPatterns(providerType, analysis) {\r\n    if (!this.ast || !this.ast.body) return;\r\n\r\n    // Search for context.watch(), context.read(), context.select()\r\n    this.ast.body.forEach((node) => {\r\n      if (node.type === 'ClassDeclaration') {\r\n        const buildMethod = node.body?.methods?.find((m) => m.key?.name === 'build');\r\n        if (buildMethod) {\r\n          this.scanForAccessPatterns(buildMethod, providerType, analysis);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Scan method for watch/read/select patterns\r\n   */\r\n  scanForAccessPatterns(method, providerType, analysis) {\r\n    if (!method.body) return;\r\n\r\n    const code = JSON.stringify(method.body);\r\n\r\n    // Check for access patterns\r\n    if (code.includes('context.watch')) {\r\n      analysis.accessPatterns.push('watch');\r\n    }\r\n    if (code.includes('context.read')) {\r\n      analysis.accessPatterns.push('read');\r\n    }\r\n    if (code.includes('context.select')) {\r\n      analysis.accessPatterns.push('select');\r\n    }\r\n\r\n    // Find consumer widgets\r\n    if (code.includes('Consumer')) {\r\n      analysis.accessPatterns.push('Consumer');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Phase 4: Find all context access points\r\n   * \r\n   * Maps:\r\n   * - Which widgets use context\r\n   * - How they access it (context.theme(), context.mediaQuery(), etc.)\r\n   * - SSR compatibility\r\n   */\r\n  findContextAccessPoints() {\r\n    if (!this.ast || !this.ast.body) return;\r\n\r\n    this.ast.body.forEach((node) => {\r\n      if (node.type !== 'ClassDeclaration') return;\r\n\r\n      const className = node.id?.name;\r\n      const buildMethod = node.body?.methods?.find((m) => m.key?.name === 'build');\r\n\r\n      if (buildMethod) {\r\n        const usagePoints = this.extractContextUsageInMethod(buildMethod, className);\r\n        this.contextAccessPoints.push(...usagePoints);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Extract all context.X() calls in a method\r\n   */\r\n  extractContextUsageInMethod(method, className) {\r\n    const usages = [];\r\n\r\n    if (!method.body) return usages;\r\n\r\n    const stmts = method.body.type === 'BlockStatement' ? method.body.body : [method.body];\r\n\r\n    stmts.forEach((stmt) => {\r\n      const foundUsages = this.findContextUsageInStatement(stmt, className);\r\n      usages.push(...foundUsages);\r\n    });\r\n\r\n    return usages;\r\n  }\r\n\r\n  /**\r\n   * Recursively find context usage patterns\r\n   */\r\n  findContextUsageInStatement(stmt, className) {\r\n    const usages = [];\r\n\r\n    if (!stmt) return usages;\r\n\r\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n      const stmtUsages = this.findContextUsageInExpression(stmt.expression, className);\r\n      usages.push(...stmtUsages);\r\n    }\r\n\r\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\r\n      const retUsages = this.findContextUsageInExpression(stmt.argument, className);\r\n      usages.push(...retUsages);\r\n    }\r\n\r\n    if (stmt.type === 'BlockStatement' && stmt.body) {\r\n      stmt.body.forEach((s) => {\r\n        const blockUsages = this.findContextUsageInStatement(s, className);\r\n        usages.push(...blockUsages);\r\n      });\r\n    }\r\n\r\n    return usages;\r\n  }\r\n\r\n  /**\r\n   * Find context usage in expressions\r\n   * Looks for: Theme.of(context), context.watch(), context.read(), etc.\r\n   */\r\n  findContextUsageInExpression(expr, className) {\r\n    const usages = [];\r\n\r\n    if (!expr) return usages;\r\n\r\n    const exprStr = JSON.stringify(expr);\r\n\r\n    // Pattern 1: Theme.of(context)\r\n    if (exprStr.includes('Theme.of') && exprStr.includes('context')) {\r\n      usages.push(new ContextUsagePattern(\r\n        'Theme.of(context)',\r\n        'inherited-widget-lookup',\r\n        expr.location,\r\n        'ThemeData',\r\n        true,\r\n        'Pure value access, no subscription required'\r\n      ));\r\n    }\r\n\r\n    // Pattern 2: context.theme()\r\n    if (exprStr.includes('context.theme')) {\r\n      usages.push(new ContextUsagePattern(\r\n        'context.theme()',\r\n        'context-service',\r\n        expr.location,\r\n        'ThemeData',\r\n        true,\r\n        'Service access during build'\r\n      ));\r\n    }\r\n\r\n    // Pattern 3: context.watch<T>()\r\n    if (exprStr.includes('context.watch')) {\r\n      usages.push(new ContextUsagePattern(\r\n        'context.watch<T>()',\r\n        'provider-watch',\r\n        expr.location,\r\n        'T',\r\n        false,\r\n        'Requires reactive subscription - not SSR safe'\r\n      ));\r\n    }\r\n\r\n    // Pattern 4: context.read<T>()\r\n    if (exprStr.includes('context.read')) {\r\n      usages.push(new ContextUsagePattern(\r\n        'context.read<T>()',\r\n        'provider-read',\r\n        expr.location,\r\n        'T',\r\n        true,\r\n        'Single read at render time - SSR safe'\r\n      ));\r\n    }\r\n\r\n    // Pattern 5: context.mediaQuery()\r\n    if (exprStr.includes('context.mediaQuery') || exprStr.includes('MediaQuery.of')) {\r\n      usages.push(new ContextUsagePattern(\r\n        'context.mediaQuery()',\r\n        'context-service',\r\n        expr.location,\r\n        'MediaQueryData',\r\n        true,\r\n        'Read-only responsive info'\r\n      ));\r\n    }\r\n\r\n    // Pattern 6: State mutations in handlers\r\n    if (exprStr.includes('notifyListeners') || exprStr.includes('increment')) {\r\n      usages.push(new ContextUsagePattern(\r\n        'notifyListeners()',\r\n        'global-state-mutation',\r\n        expr.location,\r\n        'void',\r\n        false,\r\n        'Mutations do not trigger re-render in SSR'\r\n      ));\r\n    }\r\n\r\n    // Recursively search nested expressions\r\n    if (expr.type === 'CallExpression' && expr.args) {\r\n      expr.args.forEach((arg) => {\r\n        const argUsages = this.findContextUsageInExpression(arg, className);\r\n        usages.push(...argUsages);\r\n      });\r\n    }\r\n\r\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\r\n      expr.properties.forEach((prop) => {\r\n        const propUsages = this.findContextUsageInExpression(prop.value, className);\r\n        usages.push(...propUsages);\r\n      });\r\n    }\r\n\r\n    if (expr.type === 'MemberExpression') {\r\n      const memberUsages = this.findContextUsageInExpression(expr.object, className);\r\n      usages.push(...memberUsages);\r\n    }\r\n\r\n    return usages;\r\n  }\r\n\r\n  /**\r\n   * Phase 5a: Build InheritedWidget graph\r\n   * Maps provider -> consumer relationships\r\n   */\r\n  buildInheritedWidgetGraph() {\r\n    this.inheritedWidgets.forEach((widget) => {\r\n      this.inheritedWidgetGraph[widget.name] = {\r\n        providedBy: this.findWhoProvides(widget.name),\r\n        consumedBy: this.findWhoConsumes(widget.name),\r\n        providedValue: widget.properties[0]?.type || 'unknown',\r\n        flowPath: this.traceContextFlow(widget.name),\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Phase 5b: Build Provider graph\r\n   * Maps provider -> consumer relationships\r\n   */\r\n  buildProviderGraph() {\r\n    this.providers.forEach((provider) => {\r\n      const key = provider.providerType;\r\n      this.providerGraph[key] = {\r\n        providedBy: this.findWhoCreatesProvider(provider.providerType),\r\n        providedType: provider.valueType,\r\n        consumedBy: this.findWhoConsumesProvider(provider.providerType),\r\n        accessPatterns: provider.accessPatterns,\r\n        flowPath: this.traceProviderFlow(provider.providerType),\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find which widget provides this inherited widget\r\n   */\r\n  findWhoProvides(widgetName) {\r\n    // Simplified: return widget name of class that instantiates it\r\n    // In real implementation, search AST for instantiation\r\n    return 'MyApp';\r\n  }\r\n\r\n  /**\r\n   * Find which widgets consume this inherited widget\r\n   */\r\n  findWhoConsumes(widgetName) {\r\n    const consumers = [];\r\n    // Search for calls to widgetName.of()\r\n    this.contextAccessPoints.forEach((usage) => {\r\n      if (usage.pattern.includes(widgetName)) {\r\n        consumers.push(usage.dependent);\r\n      }\r\n    });\r\n    return consumers;\r\n  }\r\n\r\n  /**\r\n   * Find where this inherited widget's context flows\r\n   */\r\n  traceContextFlow(widgetName) {\r\n    // Simplified path tracing\r\n    return `${this.findWhoProvides(widgetName)} -> ${widgetName} -> ${this.findWhoConsumes(widgetName).join(', ')}`;\r\n  }\r\n\r\n  /**\r\n   * Find who creates this provider\r\n   */\r\n  findWhoCreatesProvider(providerType) {\r\n    // Simplified: return app root\r\n    return 'MyApp';\r\n  }\r\n\r\n  /**\r\n   * Find who consumes this provider\r\n   */\r\n  findWhoConsumesProvider(providerType) {\r\n    const consumers = [];\r\n    this.contextAccessPoints.forEach((usage) => {\r\n      if (usage.pattern.includes('watch') || usage.pattern.includes('read')) {\r\n        consumers.push(usage.dependent);\r\n      }\r\n    });\r\n    return consumers;\r\n  }\r\n\r\n  /**\r\n   * Find provider flow path through widget tree\r\n   */\r\n  traceProviderFlow(providerType) {\r\n    return `MyApp -> Provider -> MaterialApp -> [consumers]`;\r\n  }\r\n\r\n  /**\r\n   * Helper: Infer type from expression\r\n   */\r\n  inferType(expr) {\r\n    if (!expr) return 'any';\r\n    if (expr.type === 'Literal') {\r\n      const val = expr.value;\r\n      if (typeof val === 'string') return 'string';\r\n      if (typeof val === 'number') return 'number';\r\n      if (typeof val === 'boolean') return 'boolean';\r\n    }\r\n    return 'any';\r\n  }\r\n\r\n  /**\r\n   * Helper: Infer return type from method body\r\n   */\r\n  inferReturnType(body) {\r\n    // Simplified\r\n    return 'any';\r\n  }\r\n\r\n  /**\r\n   * Helper: Check if field has default value\r\n   */\r\n  hasDefaultValue(field) {\r\n    return field.initialValue !== null && field.initialValue !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Helper: Convert expression to string\r\n   */\r\n  expressionToString(expr) {\r\n    if (!expr) return 'null';\r\n    if (expr.type === 'Identifier') return expr.name;\r\n    if (expr.type === 'Literal') return String(expr.value);\r\n    return JSON.stringify(expr).substring(0, 50);\r\n  }\r\n\r\n  /**\r\n   * Get analysis results\r\n   */\r\n  getResults() {\r\n    return {\r\n      inheritedWidgets: Array.from(this.inheritedWidgets.values()),\r\n      changeNotifiers: Array.from(this.changeNotifiers.values()),\r\n      providers: Array.from(this.providers.values()),\r\n      contextAccessPoints: this.contextAccessPoints,\r\n      inheritedWidgetGraph: this.inheritedWidgetGraph,\r\n      providerGraph: this.providerGraph,\r\n      errors: this.errors,\r\n    };\r\n  }\r\n}\r\n\r\nexport { ContextAnalyzer };\r\n"],
  "mappings": "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",
  "names": ["getLogger", "InheritedWidgetMetadata", "ChangeNotifierAnalysis", "ProviderAnalysis", "ContextUsagePattern", "ContextAnalyzer", "ast", "widgets", "options", "error", "node", "className", "superClass", "metadata", "field", "fieldName", "method", "methodName", "code", "analysis", "callsNotify", "mutations", "body", "pattern", "match", "buildMethod", "m", "classNode", "stmt", "s", "expr", "calleeName", "genericType", "arg", "prop", "providerType", "usagePoints", "usages", "foundUsages", "stmtUsages", "retUsages", "blockUsages", "exprStr", "argUsages", "propUsages", "memberUsages", "widget", "provider", "key", "widgetName", "consumers", "usage", "val"]
}
