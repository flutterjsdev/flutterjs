import{TokenType as n}from"./lexer.js";import{getLogger as x}from"./flutterjs_logger.js";class l{constructor(e,t){this.type=e,this.location=t}}class T extends l{constructor(e=[],t=null){super("Program",t),this.body=e}}class C extends l{constructor(e=[],t=null,s=null){super("ImportDeclaration",s),this.specifiers=e,this.source=t}}class k extends l{constructor(e=null,t=null,s=null){super("ImportSpecifier",s),this.imported=e,this.local=t}}class N extends l{constructor(e=null,t=null,s=null,i=null){super("ClassDeclaration",i),this.id=e,this.superClass=t,this.body=s}}class O extends l{constructor(e=[],t=[],s=null){super("ClassBody",s),this.fields=e,this.methods=t}}class $ extends l{constructor(e=null,t=null,s=null){super("FieldDeclaration",s),this.key=e,this.initialValue=t}}class A extends l{constructor(e=null,t=[],s=null,i=null){super("MethodDeclaration",i),this.key=e,this.params=t,this.body=s}}class E extends l{constructor(e=null,t=!1,s=null,i=null){super("Parameter",i),this.name=e,this.optional=t,this.defaultValue=s}}class D extends l{constructor(e=null,t=[],s=null,i=!1,r=null){super("FunctionDeclaration",r),this.id=e,this.params=t,this.body=s,this.isAsync=i}}class R extends l{constructor(e=[],t=null){super("BlockStatement",t),this.body=e}}class U extends l{constructor(e=null,t=null){super("ReturnStatement",t),this.argument=e}}class w extends l{constructor(e=null,t=null){super("ExpressionStatement",t),this.expression=e}}class o extends l{constructor(e="",t=null){super("Identifier",t),this.name=e}}class h extends l{constructor(e=null,t="",s="string",i=null){super("Literal",i),this.value=e,this.raw=t,this.literalType=s}}class b extends l{constructor(e=null,t=[],s=null){super("CallExpression",s),this.callee=e,this.args=t}}class P extends l{constructor(e=null,t=[],s=null){super("NewExpression",s),this.callee=e,this.args=t,this.isConst=!1}}class F extends l{constructor(e=[],t=null){super("ObjectLiteral",t),this.properties=e}}class S extends l{constructor(e=null,t=null,s=null){super("Property",s),this.key=e,this.value=t,this.shorthand=!1}}class g extends l{constructor(e=[],t=null,s=null){super("ArrowFunctionExpression",s),this.params=e,this.body=t}}class I extends l{constructor(e=null,t=null,s=!1,i=null){super("MemberExpression",i),this.object=e,this.property=t,this.computed=s}}class L{constructor(e=[],t={}){this.tokens=e,this.current=0,this.errors=[],this.options={strict:!1,...t},this.callStack=[],this.debugMode=!0}parse(){const e=[];for(;!this.isAtEnd();)try{const t=this.parseTopLevel();t&&t.type==="ImportDeclaration"&&console.log("DEBUG - ImportDeclaration:",JSON.stringify(t,null,2)),t&&e.push(t)}catch(t){this.errors.push(t),this.synchronize()}return new T(e)}skipComments(){for(;!this.isAtEnd()&&this.check(n.COMMENT);)this.advance()}isComment(){return this.isAtEnd()?!1:this.peek().type===n.COMMENT}parseTopLevel(){if(this.skipComments(),this.isAtEnd())return null;if(this.isKeyword("import"))return this.advance(),this.parseImportDeclaration();if(this.isKeyword("class"))return this.advance(),this.parseClassDeclaration();if(this.isKeyword("function"))return this.advance(),this.parseFunctionDeclaration();const e=this.parseExpression();return this.consumeStatementEnd(),new w(e,this.getLocation())}isKeyword(e){if(this.isAtEnd())return!1;const t=this.peek();return t.type===n.KEYWORD&&t.value===e}isPunctuation(e){if(this.isAtEnd())return!1;const t=this.peek();return t.type===n.PUNCTUATION&&t.value===e}isOperator(e){if(this.isAtEnd())return!1;const t=this.peek();return t.type===n.OPERATOR&&t.value===e}parseImportDeclaration(){const e=x().createComponentLogger("Parser.parseImportDeclaration");e.startSession("parseImportDeclaration");const t=this.getLocation(),s=[];if(e.trace(`  Starting import parse at token: ${this.peek().value}`),this.isPunctuation("{")){for(e.trace("  Found opening brace, parsing named imports..."),this.advance(),this.skipComments();!this.isPunctuation("}")&&!this.isAtEnd();){if(this.skipComments(),this.isPunctuation("}")){e.trace("  Found closing brace, exiting loop");break}if(!this.check(n.IDENTIFIER)){e.warn(`  Expected identifier but got: ${this.peek().value}`),this.advance();continue}const a=this.consume(n.IDENTIFIER,"Expected identifier").value,u=new o(a);e.trace(`    Imported: ${a}`);let p=u;if(this.skipComments(),this.isKeyword("as")){e.trace("    Found 'as' keyword"),this.advance(),this.skipComments();const m=this.consume(n.IDENTIFIER,"Expected identifier after as").value;p=new o(m),e.trace(`      Local name: ${m}`)}if(s.push(new k(u,p)),this.skipComments(),this.isPunctuation(",")){e.trace("    Found comma, continuing..."),this.advance(),this.skipComments();continue}else{e.trace("    No comma, expected closing brace next");break}}e.trace(`  Parsed ${s.length} named imports`),this.consume(n.PUNCTUATION,"Expected }")}else if(this.check(n.IDENTIFIER)&&this.peekAhead(1).value!=="from"){e.trace("  Found identifier without opening brace, parsing default import...");const a=this.consume(n.IDENTIFIER,"Expected identifier").value,u=new o(a),p=new o(a);if(s.push(new k(u,p)),e.trace(`  Default import: ${a}`),this.skipComments(),this.isPunctuation(",")&&(e.trace("  Found comma after default import, checking for named imports..."),this.advance(),this.skipComments(),this.isPunctuation("{"))){for(e.trace("  Found opening brace, parsing additional named imports..."),this.advance(),this.skipComments();!this.isPunctuation("}")&&!this.isAtEnd()&&(this.skipComments(),!this.isPunctuation("}"));){if(!this.check(n.IDENTIFIER)){this.advance();continue}const m=this.consume(n.IDENTIFIER,"Expected identifier").value,d=new o(m);let v=d;if(this.skipComments(),this.isKeyword("as")){this.advance(),this.skipComments();const y=this.consume(n.IDENTIFIER,"Expected identifier after as").value;v=new o(y)}if(s.push(new k(d,v)),this.skipComments(),this.isPunctuation(",")){this.advance(),this.skipComments();continue}else break}this.consume(n.PUNCTUATION,"Expected }")}}this.skipComments(),this.consume(n.KEYWORD,"Expected from"),this.skipComments();const i=this.consume(n.STRING,"Expected module path string"),r=new h(i.value,i.value,"string");return e.trace(`  Module path: ${r.value}`),e.trace(`  Total specifiers: ${s.length}`),this.consumeStatementEnd(),e.trace(`[parseImportDeclaration] SUCCESS
`),new C(s,r,t)}peekAhead(e=1){const t=this.current+e;return t>=this.tokens.length?this.tokens[this.tokens.length-1]:this.tokens[t]}parseClassDeclaration(){const e=x().createComponentLogger("Parser.parseClassDeclaration");e.startSession("parseClassDeclaration"),e.trace(`  Current token: ${this.peek().value} (${this.peek().type})`);const t=this.getLocation(),s=this.consume(n.IDENTIFIER,"Expected class name"),i=new o(s.value);e.trace(`  Class name: ${i.name}`);let r=null;if(this.isKeyword("extends")){this.advance();const d=this.consume(n.IDENTIFIER,"Expected superclass name").value;r=new o(d),e.trace(`  Extends: ${r.name}`),this.isOperator("<")&&(this.advance(),this.consume(n.IDENTIFIER,"Expected type name"),this.consume(n.OPERATOR,"Expected >"))}e.trace("  Looking for opening brace..."),e.trace(`  Current token: ${this.peek().value} (${this.peek().type})`),this.consume(n.PUNCTUATION,"Expected {");const a=[],u=[];e.trace("  Parsing class body...");let p=0;for(;!this.isPunctuation("}")&&!this.isAtEnd()&&(this.skipComments(),!this.isPunctuation("}"));){if(e.trace(`    [item ${p}] Current token: ${this.peek().value} (${this.peek().type})`),this.isPunctuation(";")){e.trace("    Skipping semicolon"),this.advance();continue}if(this.isKeyword("constructor")){e.trace("    Found constructor"),u.push(this.parseMethodDeclaration()),p++;continue}if(this.check(n.IDENTIFIER)){const d=this.current,y=this.peek().value;if(e.trace(`    Found identifier: ${y}`),this.advance(),this.isOperator("=")){e.trace("      -> This is a FIELD (followed by =)"),this.current=d;try{a.push(this.parseFieldDeclaration()),e.trace("      Field parsed successfully"),p++;continue}catch(f){throw console.error(`      ERROR parsing field: ${f.message}`),f}}if(this.isPunctuation("(")){e.trace("      -> This is a METHOD (followed by '(')"),this.current=d;try{u.push(this.parseMethodDeclaration()),e.trace("      Method parsed successfully"),p++;continue}catch(f){throw console.error(`      ERROR parsing method: ${f.message}`),f}}e.trace("      -> Unknown pattern, skipping"),this.advance();continue}e.trace(`    Skipping unknown token: ${this.peek().value}`),this.advance()}e.trace(`  Class body parsing complete. Found ${a.length} fields, ${u.length} methods`),this.consume(n.PUNCTUATION,"Expected }");const m=new O(a,u);return e.trace(`[parseClassDeclaration] SUCCESS
`),new N(i,r,m,t)}parseMethodDeclaration(){const e=x().createComponentLogger("Parser.parseMethodDeclaration");e.startSession("      [parseMethodDeclaration] STARTING"),e.trace(`        Current: ${this.peek().value}`);const t=this.getLocation();let s;this.isKeyword("constructor")?(s="constructor",this.advance()):s=this.consume(n.IDENTIFIER,"Expected method name").value,e.trace(`        Method name: ${s}`);const i=new o(s);this.consume(n.PUNCTUATION,"Expected (");const r=this.parseParameterList();e.trace(`        Parameters: ${r.length}`),this.consume(n.PUNCTUATION,"Expected )");let a=null;return this.isOperator("=>")?(e.trace("        Arrow function body"),this.advance(),a=this.parseExpression()):this.isPunctuation("{")&&(e.trace("        Block body"),this.advance(),a=this.parseBlock()),e.trace("      [parseMethodDeclaration] SUCCESS"),new A(i,r,a,t)}parseFieldDeclaration(){console.log("      [parseFieldDeclaration] STARTING"),console.log(`        Current: ${this.peek().value}`);const e=this.getLocation(),t=this.consume(n.IDENTIFIER,"Expected field name").value,s=new o(t);console.log(`        Field name: ${t}`);let i=null;if(this.isOperator("=")){console.log("        Found = operator, parsing initializer..."),this.advance();try{i=this.parseExpression(),console.log(`        Initializer parsed: ${i.type}`)}catch(r){throw console.error(`        ERROR parsing initializer: ${r.message}`),r}}return this.consumeStatementEnd(),console.log("      [parseFieldDeclaration] SUCCESS"),new $(s,i,e)}parseFunctionDeclaration(){const e=this.getLocation(),t=this.consume(n.IDENTIFIER,"Expected function name"),s=t.value?new o(t.value):null;this.consume(n.PUNCTUATION,"Expected (");const i=this.parseParameterList();this.consume(n.PUNCTUATION,"Expected )"),this.consume(n.PUNCTUATION,"Expected {");const r=this.parseBlock();return new D(s,i,r,!1,e)}parseParameterList(){const e=[];for(;!this.isPunctuation(")")&&!this.isAtEnd();){const t=this.getLocation();if(this.isPunctuation("{")){for(this.advance();!this.isPunctuation("}")&&!this.isAtEnd();){const s=this.consume(n.IDENTIFIER,"Expected param name").value;let i=null;if(this.isOperator("=")){this.advance();const r=this.peek();this.check(n.IDENTIFIER)?i=new o(this.advance().value):this.check(n.NUMBER)?i=new h(parseFloat(this.advance().value),"","number"):this.check(n.UNDEFINED)?(this.advance(),i=new h(void 0,"undefined","undefined")):this.check(n.NULL)?(this.advance(),i=new h(null,"null","null")):this.isKeyword("undefined")?(this.advance(),i=new h(void 0,"undefined","undefined")):this.isKeyword("null")&&(this.advance(),i=new h(null,"null","null"))}if(e.push(new E(new o(s),i!==null,i,t)),!this.isPunctuation(","))break;this.advance()}if(this.consume(n.PUNCTUATION,"Expected }"),this.isOperator("=")&&(this.advance(),this.isPunctuation("{"))){this.advance();let s=1;for(;s>0&&!this.isAtEnd();)this.isPunctuation("{")?s++:this.isPunctuation("}")&&s--,s>0&&this.advance();this.consume(n.PUNCTUATION,"Expected }")}}else if(this.check(n.IDENTIFIER)){const s=this.consume(n.IDENTIFIER,"Expected param name").value;let i=null;if(this.isOperator("=")){this.advance();const r=this.peek();this.check(n.IDENTIFIER)?i=new o(this.advance().value):this.check(n.NUMBER)?i=new h(parseFloat(this.advance().value),"","number"):this.check(n.UNDEFINED)?(this.advance(),i=new h(void 0,"undefined","undefined")):this.check(n.NULL)?(this.advance(),i=new h(null,"null","null")):this.isKeyword("undefined")?(this.advance(),i=new h(void 0,"undefined","undefined")):this.isKeyword("null")&&(this.advance(),i=new h(null,"null","null"))}e.push(new E(new o(s),i!==null,i,t))}else break;if(!this.isPunctuation(","))break;this.advance()}return e}parseBlock(){console.log(`
[parseBlock] STARTING at token: ${this.peek().value}`);const e=this.getLocation(),t=[];for(;!this.isPunctuation("}")&&!this.isAtEnd()&&(this.skipComments(),!this.isPunctuation("}"));)if(console.log(`  [parseBlock] Current token: ${this.peek().value} (${this.peek().type})`),this.isKeyword("return")){console.log("    Found RETURN statement"),this.advance();let s=null;if(!this.isPunctuation(";")&&!this.isPunctuation("}")){console.log("    Parsing return argument...");try{s=this.parseExpression(),console.log("    Return argument parsed successfully")}catch(i){for(console.error(`    \u274C ERROR parsing return argument: ${i.message}`),console.error(`       Token was: ${this.peek().value}`);!this.isPunctuation(";")&&!this.isPunctuation("}")&&!this.isAtEnd();)this.advance()}}this.consumeStatementEnd(),t.push(new U(s,e))}else{console.log("    Parsing expression statement...");try{const s=this.parseExpression();console.log(`    Expression parsed successfully: ${s.type}`),this.consumeStatementEnd(),t.push(new w(s,e))}catch(s){for(console.error(`    \u274C ERROR parsing expression: ${s.message}`),console.error(`       Token was: ${this.peek().value}`);!this.isPunctuation(";")&&!this.isPunctuation("}")&&!this.isAtEnd();)this.advance();this.isPunctuation(";")&&this.advance()}}return this.isPunctuation("}")&&this.advance(),console.log(`[parseBlock] SUCCESS - ${t.length} statements
`),new R(t,e)}parseExpression(){console.log(`    [parseExpression] Current token: ${this.peek().value}`);try{const e=this.parseAssignment();return console.log(`    [parseExpression] \u2713 Success, type: ${e.type}`),e}catch(e){throw console.error(`    [parseExpression] \u2717 Failed: ${e.message}`),e}}parseAssignment(){let e=this.parseTernary();if(this.isOperator("=")){this.advance();const t=this.parseAssignment();return{type:"AssignmentExpression",left:e,right:t}}return e}parseTernary(){let e=this.parseLogicalOr();if(this.isOperator("?")){this.advance();const t=this.parseExpression();this.consume(n.OPERATOR,"Expected :");const s=this.parseExpression();return{type:"ConditionalExpression",test:e,consequent:t,alternate:s}}return e}parseLogicalOr(){let e=this.parseLogicalAnd();for(;this.isOperator("||");){this.advance();const t=this.parseLogicalAnd();e={type:"LogicalExpression",operator:"||",left:e,right:t}}return e}parseLogicalAnd(){let e=this.parseEquality();for(;this.isOperator("&&");){this.advance();const t=this.parseEquality();e={type:"LogicalExpression",operator:"&&",left:e,right:t}}return e}parseEquality(){let e=this.parseRelational();for(;this.isOperator("===")||this.isOperator("!==")||this.isOperator("==")||this.isOperator("!=");){const t=this.advance().value,s=this.parseRelational();e={type:"BinaryExpression",operator:t,left:e,right:s}}return e}parseRelational(){let e=this.parseAdditive();for(;this.isOperator("<")||this.isOperator(">")||this.isOperator("<=")||this.isOperator(">=");){const t=this.advance().value,s=this.parseAdditive();e={type:"BinaryExpression",operator:t,left:e,right:s}}return e}parseAdditive(){let e=this.parseMultiplicative();for(;this.isOperator("+")||this.isOperator("-");){const t=this.advance().value,s=this.parseMultiplicative();e={type:"BinaryExpression",operator:t,left:e,right:s}}return e}parseMultiplicative(){let e=this.parseUnary();for(;this.isOperator("*")||this.isOperator("/")||this.isOperator("%");){const t=this.advance().value,s=this.parseUnary();e={type:"BinaryExpression",operator:t,left:e,right:s}}return e}parseUnary(){if(console.log(`        [parseUnary] Current: ${this.peek().value}`),this.isOperator("!")||this.isOperator("-")||this.isOperator("+")||this.isOperator("~")){const e=this.advance().value,t=this.parseUnary();return{type:"UnaryExpression",operator:e,argument:t}}return console.log("        [parseUnary] Calling parsePostfix"),this.parsePostfix()}parsePostfix(){console.log("        [parsePostfix] Starting, calling parseCall");let e=this.parseCall();for(console.log(`        [parsePostfix] parseCall returned: ${e.type||e.name}`),console.log(`        [parsePostfix] Next token: ${this.peek().value}`);;)if(this.isOperator("++")||this.isOperator("--"))e={type:"UpdateExpression",operator:this.advance().value,argument:e,prefix:!1};else if(this.isPunctuation(".")){console.log("        [parsePostfix] Found . member access"),this.advance();const t=new o(this.consume(n.IDENTIFIER,"Expected property").value);e=new I(e,t,!1),console.log(`        [parsePostfix] Created MemberExpression: ${e.object.name}.${e.property.name}`)}else if(this.isPunctuation("[")){console.log("        [parsePostfix] Found [ computed access"),this.advance();const t=this.parseExpression();this.consume(n.PUNCTUATION,"Expected ]"),e=new I(e,t,!0)}else{console.log(`        [parsePostfix] No more postfix ops, returning ${e.type}`);break}return e}parseCall(){console.log("        [parseCall] Starting, calling parsePrimary");let e=this.parsePrimary();for(console.log(`        [parseCall] parsePrimary returned: ${e.type||e.name}`),console.log(`        [parseCall] Next token: ${this.peek().value} (${this.peek().type})`);this.isPunctuation("(");){console.log("        [parseCall] Found (, parsing function call"),this.advance();const t=this.parseArguments();console.log(`        [parseCall] Parsed ${t.length} arguments`),this.consume(n.PUNCTUATION,"Expected )"),e=new b(e,t),console.log("        [parseCall] Created CallExpression")}return console.log(`        [parseCall] Returning: ${e.type}`),e}parsePrimary(){if(console.log(`      [parsePrimary] Current: ${this.peek().value} (${this.peek().type})`),this.isKeyword("this"))return this.advance(),console.log("      [parsePrimary] \u2713 this keyword"),new o("this");if(this.check(n.STRING)){const e=this.advance();return console.log(`      [parsePrimary] \u2713 string literal: ${e.value}`),new h(e.value,e.value,"string")}if(this.check(n.NUMBER)){const e=this.advance();return console.log(`      [parsePrimary] \u2713 number literal: ${e.value}`),new h(parseFloat(e.value),e.value,"number")}if(this.check(n.BOOLEAN)){const e=this.advance();return console.log(`      [parsePrimary] \u2713 boolean: ${e.value}`),new h(e.value==="true",e.value,"boolean")}if(this.check(n.NULL))return this.advance(),console.log("      [parsePrimary] \u2713 null"),new h(null,"null","null");if(this.check(n.UNDEFINED))return this.advance(),console.log("      [parsePrimary] \u2713 undefined"),new h(void 0,"undefined","undefined");if(this.isKeyword("null"))return this.advance(),console.log("      [parsePrimary] \u2713 null keyword"),new h(null,"null","null");if(this.isKeyword("undefined"))return this.advance(),console.log("      [parsePrimary] \u2713 undefined keyword"),new h(void 0,"undefined","undefined");if(this.isPunctuation("(")){console.log("      [parsePrimary] Found ( - checking for arrow function or grouped expr");const e=this.current;if(this.advance(),this.isPunctuation(")")){const s=this.current+1;if(s<this.tokens.length&&this.tokens[s].type===n.OPERATOR&&this.tokens[s].value==="=>"){console.log("      [parsePrimary] \u2713 arrow function with no params: () => ..."),this.consume(n.PUNCTUATION,"Expected )"),this.consume(n.OPERATOR,"Expected =>");const i=this.parseExpression();return new g([],i)}}const t=this.parseExpression();if(this.consume(n.PUNCTUATION,"Expected )"),this.isOperator("=>")){console.log("      [parsePrimary] \u2713 arrow function: (x) => ..."),this.advance();const s=this.parseExpression();let i=[];return t.type==="Identifier"&&(i=[new E(t,!1,null)]),new g(i,s)}return console.log("      [parsePrimary] \u2713 grouped expression"),t}if(this.isPunctuation("{"))return console.log("      [parsePrimary] \u2713 object literal"),this.advance(),this.parseObjectLiteral();if(this.isPunctuation("[")){console.log("      [parsePrimary] \u2713 array literal"),this.advance();const e=[];for(;!this.isPunctuation("]")&&!this.isAtEnd()&&(e.push(this.parseExpression()),!!this.isPunctuation(","));)this.advance();return this.consume(n.PUNCTUATION,"Expected ]"),{type:"ArrayLiteral",elements:e}}if(this.isKeyword("new")){console.log("      [parsePrimary] \u2713 new expression"),this.advance();const e=new o(this.consume(n.IDENTIFIER,"Expected class name").value);this.consume(n.PUNCTUATION,"Expected (");const t=this.parseArguments();return this.consume(n.PUNCTUATION,"Expected )"),new P(e,t)}if(this.isKeyword("const")){const e=this.current;if(this.advance(),this.isKeyword("new")){console.log("      [parsePrimary] \u2713 const new expression"),this.advance();const t=new o(this.consume(n.IDENTIFIER,"Expected class name").value);this.consume(n.PUNCTUATION,"Expected (");const s=this.parseArguments();this.consume(n.PUNCTUATION,"Expected )");const i=new P(t,s);return i.isConst=!0,i}this.current=e}if(this.check(n.IDENTIFIER)){const e=this.advance(),t=new o(e.value);if(console.log(`      [parsePrimary] \u2713 identifier: ${e.value}`),this.isOperator("=>")){console.log("      [parsePrimary] \u2713 arrow function: x => ..."),this.advance();const s=this.parseExpression();return new g([new E(t)],s)}return t}throw console.error(`      [parsePrimary] \u274C FAILED - Cannot parse token: ${this.peek().value} (${this.peek().type})`),this.error("Expected expression")}enterMethod(e){this.callStack||(this.callStack=[]),this.callStack.push({method:e,line:this.peek().line,column:this.peek().column,token:this.peek().value})}parseObjectLiteral(){this.enterMethod("parseObjectLiteral");const e=[];try{for(;!this.isPunctuation("}")&&!this.isAtEnd();){if(this.isPunctuation(",")){this.advance();continue}let t=null,s=!1;if(this.isPunctuation("["))this.advance(),t=this.parseExpression(),this.consume(n.PUNCTUATION,"Expected ]");else if(this.check(n.IDENTIFIER)){const a=this.advance();t=new o(a.value),(this.isPunctuation(",")||this.isPunctuation("}"))&&(s=!0)}else if(this.check(n.STRING)){const a=this.advance();t=new h(a.value,a.value,"string")}else{this.advance();continue}let i=t;if(!s&&this.isPunctuation(":")){this.advance();try{i=this.parseTernary()}catch(a){for(a.parserError&&this.reportParserError(a.parserError),i=t;!this.isPunctuation(",")&&!this.isPunctuation("}")&&!this.isAtEnd();)this.advance()}}const r=new S(t,i);r.shorthand=s,e.push(r),this.isPunctuation(",")&&this.advance()}return this.isPunctuation("}")&&this.advance(),this.exitMethod("parseObjectLiteral"),new F(e)}catch(t){throw this.exitMethod("parseObjectLiteral"),t}}parseArguments(){const e=[];for(;!this.isPunctuation(")")&&!this.isAtEnd();){try{e.push(this.parseTernary())}catch{break}if(!this.isPunctuation(","))break;this.advance()}return e}check(e){return this.isAtEnd()?!1:this.peek().type===e}consume(e,t=""){if(this.check(e))return this.advance();throw this.error(t||`Expected ${e}`)}consumeStatementEnd(){this.skipComments(),this.isPunctuation(";")&&this.advance(),this.skipComments()}advance(){return this.isAtEnd()||this.current++,this.previous()}peek(){return this.tokens[this.current]}previous(){return this.tokens[this.current-1]}isAtEnd(){return this.peek().type===n.EOF}getLocation(){const e=this.peek();return{line:e.line,column:e.column}}error(e){const t=this.peek(),s=new Error(`Parse error at line ${t.line}, column ${t.column}: ${e}`);return s.parserError={message:`Parse error at line ${t.line}, column ${t.column}: ${e}`,line:t.line,column:t.column,token:{type:t.type,value:t.value},callStack:this.callStack?[...this.callStack]:[]},s}getContext(){const e=Math.max(0,this.current-5),t=Math.min(this.tokens.length,this.current+6);return{before:this.tokens.slice(e,this.current).map(s=>`${s.value}(${s.type})`).join(" "),current:`\u2192 ${this.peek().value}(${this.peek().type}) \u2190`,after:this.tokens.slice(this.current+1,t).map(s=>`${s.value}(${s.type})`).join(" ")}}exitMethod(e){this.callStack||(this.callStack=[]),this.callStack.length>0&&this.callStack[this.callStack.length-1].method===e&&this.callStack.pop()}getTokenContext(){const e=Math.max(0,this.current-5),t=Math.min(this.tokens.length,this.current+6),s=this.tokens.slice(e,this.current).map(r=>`${r.value}`).join(" "),i=this.tokens.slice(this.current+1,t).map(r=>`${r.value}`).join(" ");return{before:s,current:`\u2192 ${this.peek().value} \u2190`,after:i}}synchronize(){for(this.advance();!this.isAtEnd();){if(this.isPunctuation(";")){this.advance();return}if(this.isKeyword("class")||this.isKeyword("function")||this.isKeyword("import"))return;this.advance()}}getErrors(){return this.errors}reportError(e){this.errors.push(e),this.debugMode&&(console.error(`
\u274C PARSER ERROR DETECTED:
`),console.error(`Message: ${e.message}
`),console.error("\u{1F4CD} Token Context:"),console.error(`  Before:  ${e.context.before}`),console.error(`  Current: ${e.context.current}`),console.error(`  After:   ${e.context.after}
`),console.error("\u{1F4DA} Call Stack (where error came from):"),e.callStack.length===0?console.error(`  (top level)
`):(e.callStack.forEach((t,s)=>{const i=s===e.callStack.length-1?"\u2192":" ";console.error(`  ${i} ${s+1}. ${t.method}()`),console.error(`     at token: "${t.token}" (line ${t.line}, col ${t.column})`)}),console.error("")))}}export{l as ASTNode,g as ArrowFunctionExpression,R as BlockStatement,b as CallExpression,O as ClassBody,N as ClassDeclaration,w as ExpressionStatement,$ as FieldDeclaration,D as FunctionDeclaration,o as Identifier,C as ImportDeclaration,k as ImportSpecifier,h as Literal,I as MemberExpression,A as MethodDeclaration,P as NewExpression,F as ObjectLiteral,E as Parameter,L as Parser,T as Program,S as Property,U as ReturnStatement};
//# sourceMappingURL=flutterjs_parser.js.map
