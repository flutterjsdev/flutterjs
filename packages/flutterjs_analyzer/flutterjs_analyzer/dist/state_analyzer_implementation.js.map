{
  "version": 3,
  "sources": ["../src/state_analyzer_implementation.js"],
  "sourcesContent": ["// Copyright 2025 The FlutterJS Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style license that can be\r\n// found in the LICENSE file.\r\n\r\n/**\r\n * FlutterJS State Analyzer\r\n * Phase 2 Implementation\r\n * \r\n * Extracts state management information from StatefulWidget/State classes\r\n * No external dependencies - pure Node.js\r\n */\r\n\r\n// ============================================================================\r\n// STATE ANALYZER CLASS\r\n// ============================================================================\r\n\r\nclass StateAnalyzer {\r\n  constructor(ast, widgets, options = {}) {\r\n    this.ast = ast;\r\n    this.widgets = widgets; // from Phase 1 WidgetAnalyzer\r\n    this.options = {\r\n      strict: false,\r\n      ...options,\r\n    };\r\n\r\n    // Results storage\r\n    this.stateClasses = new Map();\r\n    this.stateFields = new Map();\r\n    this.setStateCalls = [];\r\n    this.lifecycleMethods = [];\r\n    this.eventHandlers = [];\r\n    this.dependencyGraph = null;\r\n    this.validationResults = [];\r\n    this.errors = [];\r\n  }\r\n\r\n  /**\r\n   * Main entry point - analyze all state-related code\r\n   */\r\n  analyze() {\r\n    if (!this.ast || !this.ast.body) {\r\n      throw new Error('Invalid AST provided');\r\n    }\r\n\r\n    try {\r\n      // Phase 1: Find and link StatefulWidget/State pairs\r\n      this.linkStatefulToState();\r\n\r\n      // Phase 2: Extract state fields from State classes\r\n      this.extractStateFields();\r\n\r\n      // Phase 3: Find setState calls\r\n      this.findSetStateCalls();\r\n\r\n      // Phase 4: Extract lifecycle methods\r\n      this.extractLifecycleMethods();\r\n\r\n      // Phase 5: Extract event handlers\r\n      this.extractEventHandlers();\r\n\r\n      // Phase 6: Build dependency graph\r\n      this.buildDependencyGraph();\r\n\r\n      // Phase 7: Validate everything\r\n      this.validateState();\r\n\r\n      return this.getResults();\r\n    } catch (error) {\r\n      this.errors.push(error);\r\n      return this.getResults();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Phase 1: Link StatefulWidget to State class\r\n   * \r\n   * StatefulWidget.createState() returns State class instance\r\n   * We need to find the return value and match it with State class\r\n   */\r\n  linkStatefulToState() {\r\n    this.widgets.forEach((widget) => {\r\n      if (widget.type !== 'stateful') return;\r\n\r\n      // Find the createState method\r\n      const createStateMethod = widget.methods.find(\r\n        (m) => m.name === 'createState'\r\n      );\r\n\r\n      if (!createStateMethod) {\r\n        this.errors.push({\r\n          type: 'missing-create-state',\r\n          widget: widget.name,\r\n          message: `StatefulWidget \"${widget.name}\" has no createState() method`,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Find the corresponding class declaration in AST\r\n      const widgetNode = this.ast.body.find(\r\n        (n) => n.type === 'ClassDeclaration' && n.id.name === widget.name\r\n      );\r\n\r\n      if (!widgetNode) return;\r\n\r\n      // Find what createState returns\r\n      const createStateNode = widgetNode.body.methods.find(\r\n        (m) => m.key.name === 'createState'\r\n      );\r\n\r\n      if (!createStateNode) return;\r\n\r\n      // Extract the returned State class name\r\n      const stateClassName = this.extractReturnedClassName(createStateNode.body);\r\n\r\n      if (!stateClassName) {\r\n        this.errors.push({\r\n          type: 'cannot-parse-create-state',\r\n          widget: widget.name,\r\n          message: `Cannot determine which State class is returned by ${widget.name}.createState()`,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Find the State class\r\n      const stateClassNode = this.ast.body.find(\r\n        (n) => n.type === 'ClassDeclaration' && n.id.name === stateClassName\r\n      );\r\n\r\n      if (!stateClassNode) {\r\n        this.errors.push({\r\n          type: 'missing-state-class',\r\n          widget: widget.name,\r\n          stateClass: stateClassName,\r\n          message: `State class \"${stateClassName}\" not found`,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Check if it extends State<Widget>\r\n      if (!stateClassNode.superClass || !stateClassNode.superClass.name.startsWith('State')) {\r\n        this.errors.push({\r\n          type: 'invalid-state-class',\r\n          stateClass: stateClassName,\r\n          message: `Class \"${stateClassName}\" does not extend State`,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Create StateClassMetadata\r\n      const stateMetadata = new StateClassMetadata(\r\n        stateClassName,\r\n        stateClassNode.location,\r\n        widget.name\r\n      );\r\n\r\n      this.stateClasses.set(stateClassName, {\r\n        astNode: stateClassNode,\r\n        metadata: stateMetadata,\r\n      });\r\n\r\n      // Link bidirectional\r\n      widget.linkedStateClass = stateClassName;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Extract the class name returned from a method\r\n   * Looks for: return new ClassName(); or return new ClassName();\r\n   */\r\n  extractReturnedClassName(methodBody) {\r\n    if (!methodBody) return null;\r\n\r\n    // Handle BlockStatement: { return new ClassName(); }\r\n    if (methodBody.type === 'BlockStatement' && methodBody.body) {\r\n      for (const stmt of methodBody.body) {\r\n        if (stmt.type === 'ReturnStatement' && stmt.argument) {\r\n          const className = this.getClassNameFromExpression(stmt.argument);\r\n          if (className) return className;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle direct expression: return new ClassName();\r\n    if (methodBody.type === 'NewExpression') {\r\n      return methodBody.callee.name;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract class name from expression (new ClassName or ClassName)\r\n   */\r\n  getClassNameFromExpression(expr) {\r\n    if (!expr) return null;\r\n\r\n    if (expr.type === 'NewExpression' && expr.callee) {\r\n      return expr.callee.name;\r\n    }\r\n\r\n    if (expr.type === 'Identifier') {\r\n      return expr.name;\r\n    }\r\n\r\n    if (expr.type === 'CallExpression' && expr.callee) {\r\n      if (expr.callee.type === 'Identifier') {\r\n        return expr.callee.name;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Phase 2: Extract state fields from State classes\r\n   * \r\n   * State fields are class properties that can be mutated\r\n   * Examples: _count = 0, _isLoading = false\r\n   */\r\n  extractStateFields() {\r\n    this.stateClasses.forEach(({ astNode, metadata }) => {\r\n      if (!astNode.body || !astNode.body.fields) return;\r\n\r\n      astNode.body.fields.forEach((field) => {\r\n        const fieldName = field.key.name;\r\n        const initialValue = field.initialValue;\r\n\r\n        // Infer type from initial value\r\n        const type = this.inferFieldType(initialValue);\r\n\r\n        const stateField = new StateField(\r\n          fieldName,\r\n          type,\r\n          this.expressionToValue(initialValue),\r\n          initialValue ? initialValue.location : field.location\r\n        );\r\n\r\n        // Track in global map and in metadata\r\n        this.stateFields.set(`${metadata.name}.${fieldName}`, stateField);\r\n        metadata.stateFields.push(stateField);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Infer field type from initial value expression\r\n   */\r\n  inferFieldType(expr) {\r\n    if (!expr) return 'any';\r\n\r\n    if (expr.type === 'Literal') {\r\n      if (typeof expr.value === 'number') return 'number';\r\n      if (typeof expr.value === 'string') return 'string';\r\n      if (typeof expr.value === 'boolean') return 'boolean';\r\n      if (expr.value === null) return 'null';\r\n    }\r\n\r\n    if (expr.type === 'Identifier') {\r\n      const name = expr.name;\r\n      if (name === 'true' || name === 'false') return 'boolean';\r\n      if (name === 'null') return 'null';\r\n      if (name === 'undefined') return 'undefined';\r\n    }\r\n\r\n    // Array literal\r\n    if (expr.type === 'ArrayLiteral') return 'array';\r\n\r\n    // Object literal\r\n    if (expr.type === 'ObjectLiteral') return 'object';\r\n\r\n    // Function call - unknown return type\r\n    if (expr.type === 'CallExpression') return 'any';\r\n\r\n    return 'any';\r\n  }\r\n\r\n  /**\r\n   * Convert expression to actual value (for initialization)\r\n   */\r\n  expressionToValue(expr) {\r\n    if (!expr) return undefined;\r\n\r\n    if (expr.type === 'Literal') {\r\n      return expr.value;\r\n    }\r\n\r\n    if (expr.type === 'Identifier') {\r\n      const name = expr.name;\r\n      if (name === 'true') return true;\r\n      if (name === 'false') return false;\r\n      if (name === 'null') return null;\r\n      if (name === 'undefined') return undefined;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Phase 3: Find all setState() calls\r\n   */\r\n  findSetStateCalls() {\r\n    this.stateClasses.forEach(({ astNode, metadata }) => {\r\n      if (!astNode.body || !astNode.body.methods) return;\r\n\r\n      // Search all methods for setState calls\r\n      astNode.body.methods.forEach((method) => {\r\n        const setStateCalls = this.findSetStateInMethod(method, metadata.name);\r\n        this.setStateCalls.push(...setStateCalls);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find setState calls within a method\r\n   */\r\n  findSetStateInMethod(method, stateClassName) {\r\n    const calls = [];\r\n    const methodName = method.key.name;\r\n\r\n    // Search method body for setState calls\r\n    if (method.body) {\r\n      const stmts = method.body.type === 'BlockStatement'\r\n        ? method.body.body\r\n        : [method.body];\r\n\r\n      stmts.forEach((stmt) => {\r\n        this.findSetStateInStatement(stmt, calls, methodName, stateClassName);\r\n      });\r\n    }\r\n\r\n    return calls;\r\n  }\r\n\r\n  /**\r\n   * Recursively find setState in statements\r\n   */\r\n  findSetStateInStatement(stmt, calls, methodName, stateClassName) {\r\n    if (!stmt) return;\r\n\r\n    // Handle expression statements\r\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n      this.findSetStateInExpression(stmt.expression, calls, methodName, stateClassName);\r\n    }\r\n\r\n    // Handle return statements\r\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\r\n      this.findSetStateInExpression(stmt.argument, calls, methodName, stateClassName);\r\n    }\r\n\r\n    // Handle blocks\r\n    if (stmt.type === 'BlockStatement' && stmt.body) {\r\n      stmt.body.forEach((s) => {\r\n        this.findSetStateInStatement(s, calls, methodName, stateClassName);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find setState in expression tree\r\n   */\r\n  findSetStateInExpression(expr, calls, methodName, stateClassName) {\r\n    if (!expr) return;\r\n\r\n    // Check if this is a setState call: this.setState(callback)\r\n    if (expr.type === 'CallExpression') {\r\n      // Check if it's this.setState(...)\r\n      const isSetState = this.isSetStateCall(expr);\r\n\r\n      if (isSetState) {\r\n        const updatedFields = this.extractSetStateUpdates(expr, stateClassName);\r\n        const call = new StateUpdateCall(\r\n          expr.location,\r\n          methodName,\r\n          updatedFields,\r\n          stateClassName\r\n        );\r\n        calls.push(call);\r\n      }\r\n\r\n      // Also check arguments for nested setState calls\r\n      expr.args.forEach((arg) => {\r\n        this.findSetStateInExpression(arg, calls, methodName, stateClassName);\r\n      });\r\n    }\r\n\r\n    // Recursively check nested expressions\r\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\r\n      expr.properties.forEach((prop) => {\r\n        this.findSetStateInExpression(prop.value, calls, methodName, stateClassName);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if expression is this.setState(...)\r\n   */\r\n  isSetStateCall(expr) {\r\n    if (expr.type !== 'CallExpression') return false;\r\n    if (!expr.callee) return false;\r\n\r\n    // Check for member expression: this.setState\r\n    if (expr.callee.type === 'MemberExpression') {\r\n      const obj = expr.callee.object;\r\n      const prop = expr.callee.property;\r\n\r\n      // this.setState\r\n      if (obj.type === 'Identifier' && obj.name === 'this' &&\r\n        prop.type === 'Identifier' && prop.name === 'setState') {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Extract which state fields are updated in setState\r\n   * setState(() => { this._count++; })\r\n   */\r\n  extractSetStateUpdates(setStateCall, stateClassName) {\r\n    const updated = [];\r\n\r\n    if (!setStateCall.args || setStateCall.args.length === 0) return updated;\r\n\r\n    // First argument is the callback: () => { ... }\r\n    const callback = setStateCall.args[0];\r\n\r\n    if (callback.type === 'ArrowFunctionExpression') {\r\n      // Extract body\r\n      const body = callback.body;\r\n\r\n      if (body.type === 'BlockStatement' && body.body) {\r\n        // Search for field mutations: this._field = value, this._field++, etc.\r\n        body.body.forEach((stmt) => {\r\n          const mutated = this.extractMutatedFields(stmt, stateClassName);\r\n          updated.push(...mutated);\r\n        });\r\n      } else if (body.type === 'UpdateExpression' || body.type === 'AssignmentExpression') {\r\n        // Direct mutation in arrow body\r\n        const mutated = this.extractMutatedFields(body, stateClassName);\r\n        updated.push(...mutated);\r\n      }\r\n    }\r\n\r\n    return [...new Set(updated)]; // Remove duplicates\r\n  }\r\n\r\n  /**\r\n   * Extract mutated fields from statement\r\n   * Looks for: this._field = x, this._field++, this._field += x\r\n   */\r\n  extractMutatedFields(stmt, stateClassName) {\r\n    const fields = [];\r\n\r\n    if (!stmt) return fields;\r\n\r\n    // Assignment: this._field = value\r\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n      const expr = stmt.expression;\r\n\r\n      if (expr.type === 'AssignmentExpression') {\r\n        const fieldName = this.getFieldNameFromTarget(expr.left);\r\n        if (fieldName) fields.push(fieldName);\r\n      }\r\n\r\n      // Update expression: this._field++, this._field--\r\n      if (expr.type === 'UpdateExpression') {\r\n        const fieldName = this.getFieldNameFromTarget(expr.argument);\r\n        if (fieldName) fields.push(fieldName);\r\n      }\r\n    }\r\n\r\n    // Direct assignment/update (arrow body)\r\n    if (stmt.type === 'AssignmentExpression') {\r\n      const fieldName = this.getFieldNameFromTarget(stmt.left);\r\n      if (fieldName) fields.push(fieldName);\r\n    }\r\n\r\n    if (stmt.type === 'UpdateExpression') {\r\n      const fieldName = this.getFieldNameFromTarget(stmt.argument);\r\n      if (fieldName) fields.push(fieldName);\r\n    }\r\n\r\n    return fields;\r\n  }\r\n\r\n  /**\r\n   * Get field name from assignment target\r\n   * Handles: this._field, obj.field, etc.\r\n   */\r\n  getFieldNameFromTarget(target) {\r\n    if (!target) return null;\r\n\r\n    // this._field\r\n    if (target.type === 'MemberExpression') {\r\n      const obj = target.object;\r\n      const prop = target.property;\r\n\r\n      // this._field\r\n      if (obj.type === 'Identifier' && obj.name === 'this' &&\r\n        prop.type === 'Identifier') {\r\n        return prop.name;\r\n      }\r\n    }\r\n\r\n    // _field (direct identifier)\r\n    if (target.type === 'Identifier') {\r\n      return target.name;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Phase 4: Extract lifecycle methods\r\n   * \r\n   * Lifecycle methods: initState, dispose, didUpdateWidget, build\r\n   */\r\n  extractLifecycleMethods() {\r\n    const lifecycleNames = ['initState', 'dispose', 'didUpdateWidget', 'build'];\r\n\r\n    this.stateClasses.forEach(({ astNode, metadata }) => {\r\n      if (!astNode.body || !astNode.body.methods) return;\r\n\r\n      astNode.body.methods.forEach((method) => {\r\n        const methodName = method.key.name;\r\n\r\n        if (lifecycleNames.includes(methodName)) {\r\n          const lifecycle = new LifecycleMethod(\r\n            methodName,\r\n            method.location,\r\n            method.params || [],\r\n            this.checkCallsSuper(method),\r\n            this.checkHasSideEffects(method)\r\n          );\r\n\r\n          this.lifecycleMethods.push(lifecycle);\r\n          metadata.lifecycleMethods.push(lifecycle);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if method calls super.methodName()\r\n   */\r\n  checkCallsSuper(method) {\r\n    if (!method.body) return false;\r\n\r\n    const stmts = method.body.type === 'BlockStatement'\r\n      ? method.body.body\r\n      : [method.body];\r\n\r\n    for (const stmt of stmts) {\r\n      if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n        const expr = stmt.expression;\r\n\r\n        // super.initState() pattern\r\n        if (expr.type === 'CallExpression' && expr.callee.type === 'MemberExpression') {\r\n          const obj = expr.callee.object;\r\n          const prop = expr.callee.property;\r\n\r\n          if (obj.type === 'Identifier' && obj.name === 'super' &&\r\n            prop.type === 'Identifier' && prop.name === method.key.name) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if method has side effects (console.log, assignments, etc.)\r\n   */\r\n  checkHasSideEffects(method) {\r\n    if (!method.body) return false;\r\n\r\n    const stmts = method.body.type === 'BlockStatement'\r\n      ? method.body.body\r\n      : [method.body];\r\n\r\n    for (const stmt of stmts) {\r\n      // Assignment has side effect\r\n      if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n        const expr = stmt.expression;\r\n\r\n        if (expr.type === 'AssignmentExpression' || expr.type === 'UpdateExpression') {\r\n          return true;\r\n        }\r\n\r\n        // Function calls might have side effects\r\n        if (expr.type === 'CallExpression') {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Phase 5: Extract event handlers from build method\r\n   * \r\n   * Looks for: onPressed: () => handler(), onChange: handler, etc.\r\n   */\r\n  extractEventHandlers() {\r\n    this.stateClasses.forEach(({ astNode, metadata }) => {\r\n      if (!astNode.body || !astNode.body.methods) return;\r\n\r\n      // Find build method\r\n      const buildMethod = astNode.body.methods.find((m) => m.key.name === 'build');\r\n      if (!buildMethod) return;\r\n\r\n      // Extract event handlers from the build method body\r\n      const handlers = this.findEventHandlersInMethod(buildMethod, metadata.name);\r\n      this.eventHandlers.push(...handlers);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find event handlers in method body\r\n   */\r\n  findEventHandlersInMethod(method, stateClassName) {\r\n    const handlers = [];\r\n\r\n    if (!method.body) return handlers;\r\n\r\n    const stmts = method.body.type === 'BlockStatement'\r\n      ? method.body.body\r\n      : [method.body];\r\n\r\n    stmts.forEach((stmt) => {\r\n      this.findEventHandlersInStatement(stmt, handlers, stateClassName);\r\n    });\r\n\r\n    return handlers;\r\n  }\r\n\r\n  /**\r\n   * Recursively find event handlers in statements\r\n   */\r\n  findEventHandlersInStatement(stmt, handlers, stateClassName) {\r\n    if (!stmt) return;\r\n\r\n    if (stmt.type === 'ExpressionStatement' && stmt.expression) {\r\n      this.findEventHandlersInExpression(stmt.expression, handlers, stateClassName);\r\n    }\r\n\r\n    if (stmt.type === 'ReturnStatement' && stmt.argument) {\r\n      this.findEventHandlersInExpression(stmt.argument, handlers, stateClassName);\r\n    }\r\n\r\n    if (stmt.type === 'BlockStatement' && stmt.body) {\r\n      stmt.body.forEach((s) => {\r\n        this.findEventHandlersInStatement(s, handlers, stateClassName);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find event handlers in expressions\r\n   * Looks for: { onPressed: () => handler(), onChange: handler }\r\n   */\r\n  findEventHandlersInExpression(expr, handlers, stateClassName) {\r\n    if (!expr) return;\r\n\r\n    // Check object literals for event properties\r\n    if (expr.type === 'ObjectLiteral' && expr.properties) {\r\n      expr.properties.forEach((prop) => {\r\n        // Property key is the event name (onPressed, onChange, etc.)\r\n        const eventName = this.getPropertyKey(prop.key);\r\n        const eventPattern = /^on[A-Z]/; // onPressed, onChange, etc.\r\n\r\n        if (eventPattern.test(eventName)) {\r\n          // Extract handler from property value\r\n          const handler = this.extractEventHandler(prop.value, stateClassName);\r\n\r\n          if (handler) {\r\n            handlers.push({\r\n              event: eventName,\r\n              handler: handler,\r\n              location: prop.location,\r\n              component: this.getComponentNameFromContext(expr),\r\n            });\r\n          }\r\n        }\r\n\r\n        // Also search nested values\r\n        this.findEventHandlersInExpression(prop.value, handlers, stateClassName);\r\n      });\r\n    }\r\n\r\n    // Check call expressions (widget calls)\r\n    if (expr.type === 'CallExpression' && expr.args) {\r\n      expr.args.forEach((arg) => {\r\n        this.findEventHandlersInExpression(arg, handlers, stateClassName);\r\n      });\r\n    }\r\n\r\n    // Check new expressions\r\n    if (expr.type === 'NewExpression' && expr.args) {\r\n      expr.args.forEach((arg) => {\r\n        this.findEventHandlersInExpression(arg, handlers, stateClassName);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get property key from object property\r\n   */\r\n  getPropertyKey(keyExpr) {\r\n    if (!keyExpr) return null;\r\n\r\n    if (keyExpr.type === 'Identifier') {\r\n      return keyExpr.name;\r\n    }\r\n\r\n    if (keyExpr.type === 'Literal') {\r\n      return String(keyExpr.value);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract handler reference from property value\r\n   * Can be: () => handler(), handler, () => { ... }\r\n   */\r\n  extractEventHandler(value, stateClassName) {\r\n    if (!value) return null;\r\n\r\n    // Arrow function: () => handler()\r\n    if (value.type === 'ArrowFunctionExpression') {\r\n      if (value.body.type === 'CallExpression') {\r\n        const handlerName = this.getClassNameFromExpression(value.body.callee);\r\n        return handlerName;\r\n      }\r\n\r\n      // Check if body is identifier: () => handler\r\n      if (value.body.type === 'Identifier') {\r\n        return value.body.name;\r\n      }\r\n    }\r\n\r\n    // Direct identifier: handler\r\n    if (value.type === 'Identifier') {\r\n      return value.name;\r\n    }\r\n\r\n    // Member expression: this.handler\r\n    if (value.type === 'MemberExpression') {\r\n      if (value.property.type === 'Identifier') {\r\n        return value.property.name;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get component name (for context, since we don't have full widget info here)\r\n   */\r\n  getComponentNameFromContext(expr) {\r\n    // This is simplified - in a real scenario you'd track which widget\r\n    // contains this object literal\r\n    if (expr.type === 'CallExpression' && expr.callee) {\r\n      return this.getClassNameFromExpression(expr.callee);\r\n    }\r\n\r\n    return 'Unknown';\r\n  }\r\n\r\n  /**\r\n   * Phase 6: Build state dependency graph\r\n   * \r\n   * Maps:\r\n   * - stateToMethods: which methods use which state\r\n   * - methodToState: which state each method uses\r\n   * - eventToState: which state each event updates\r\n   */\r\n  buildDependencyGraph() {\r\n    this.dependencyGraph = new DependencyGraph();\r\n\r\n    // State to methods\r\n    this.stateFields.forEach((field, key) => {\r\n      const methods = this.findMethodsUsingField(field.name);\r\n      if (methods.length > 0) {\r\n        this.dependencyGraph.stateToMethods.set(field.name, methods);\r\n      }\r\n    });\r\n\r\n    // Methods to state\r\n    this.stateClasses.forEach(({ metadata }) => {\r\n      metadata.stateFields.forEach((field) => {\r\n        const methodsUsing = this.findMethodsReadingField(metadata.name, field.name);\r\n        if (methodsUsing.length > 0) {\r\n          this.dependencyGraph.methodToState.set(field.name, methodsUsing);\r\n        }\r\n      });\r\n    });\r\n\r\n    // Event to state\r\n    this.eventHandlers.forEach((event) => {\r\n      const stateChanged = this.findStateChangedByMethod(event.handler);\r\n      if (stateChanged.length > 0) {\r\n        this.dependencyGraph.eventToState.set(event.event, stateChanged);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find methods that use a state field\r\n   */\r\n  findMethodsUsingField(fieldName) {\r\n    const methods = new Set();\r\n\r\n    this.setStateCalls.forEach((call) => {\r\n      if (call.updates.includes(fieldName)) {\r\n        methods.add(call.method);\r\n      }\r\n    });\r\n\r\n    // Also check if field is used in build (for reading)\r\n    this.stateClasses.forEach(({ astNode, metadata }) => {\r\n      if (!astNode.body || !astNode.body.methods) return;\r\n\r\n      const buildMethod = astNode.body.methods.find((m) => m.key.name === 'build');\r\n      if (buildMethod && this.methodUsesField(buildMethod, fieldName)) {\r\n        methods.add('build');\r\n      }\r\n    });\r\n\r\n    return Array.from(methods);\r\n  }\r\n\r\n  /**\r\n   * Check if method uses a field\r\n   */\r\n  methodUsesField(method, fieldName) {\r\n    if (!method.body) return false;\r\n\r\n    const stmts = method.body.type === 'BlockStatement'\r\n      ? method.body.body\r\n      : [method.body];\r\n\r\n    for (const stmt of stmts) {\r\n      if (this.statementUsesField(stmt, fieldName)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if statement contains field reference\r\n   */\r\n  statementUsesField(stmt, fieldName) {\r\n    if (!stmt) return false;\r\n\r\n    // Simple search for this._fieldName pattern\r\n    const code = JSON.stringify(stmt);\r\n    return code.includes(fieldName);\r\n  }\r\n\r\n  /**\r\n   * Find methods that are triggered by reading state\r\n   */\r\n  findMethodsReadingField(stateClassName, fieldName) {\r\n    const methods = [];\r\n\r\n    this.stateClasses.forEach(({ metadata }) => {\r\n      if (metadata.name !== stateClassName) return;\r\n\r\n      metadata.stateFields.forEach((field) => {\r\n        if (field.name === fieldName) {\r\n          methods.push(...field.usedInMethods);\r\n        }\r\n      });\r\n    });\r\n\r\n    return methods;\r\n  }\r\n\r\n  /**\r\n   * Find state changed by a method\r\n   */\r\n  findStateChangedByMethod(methodName) {\r\n    const changed = new Set();\r\n\r\n    this.setStateCalls.forEach((call) => {\r\n      if (call.method === methodName) {\r\n        call.updates.forEach((update) => changed.add(update));\r\n      }\r\n    });\r\n\r\n    return Array.from(changed);\r\n  }\r\n\r\n  /**\r\n   * Phase 7: Validate all state patterns\r\n   */\r\n  validateState() {\r\n    this.validateSetStatePatterns();\r\n    this.validateStateFieldUsage();\r\n    this.validateLifecyclePatterns();\r\n    this.validateEventHandlers();\r\n  }\r\n\r\n  /**\r\n   * Validate setState usage patterns\r\n   */\r\n  validateSetStatePatterns() {\r\n    this.setStateCalls.forEach((call) => {\r\n      const issues = [];\r\n\r\n      // Check if called from valid context (State class method)\r\n      const stateClass = this.stateClasses.get(call.stateClassName);\r\n      if (!stateClass) {\r\n        issues.push({\r\n          type: 'invalid-context',\r\n          message: `setState called outside of ${call.stateClassName}`,\r\n        });\r\n      }\r\n\r\n      // Check if updates valid fields\r\n      if (call.updates.length === 0) {\r\n        issues.push({\r\n          type: 'empty-update',\r\n          message: 'setState called with no state updates',\r\n          severity: 'warning',\r\n        });\r\n      }\r\n\r\n      call.updates.forEach((field) => {\r\n        if (!this.stateFields.has(`${call.stateClassName}.${field}`)) {\r\n          issues.push({\r\n            type: 'unknown-field',\r\n            message: `setState updates unknown field \"${field}\"`,\r\n            field,\r\n          });\r\n        }\r\n      });\r\n\r\n      // Record validation\r\n      call.isValid = issues.length === 0;\r\n      call.issues = issues;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate state field usage\r\n   */\r\n  validateStateFieldUsage() {\r\n    this.stateFields.forEach((field, key) => {\r\n      const parts = key.split('.');\r\n      const stateClassName = parts[0];\r\n      const fieldName = parts[1];\r\n\r\n      // Check if field is used\r\n      if (!this.fieldIsUsed(fieldName, stateClassName)) {\r\n        this.validationResults.push({\r\n          type: 'unused-state-field',\r\n          severity: 'warning',\r\n          field: fieldName,\r\n          location: field.location,\r\n          message: `State field \"${fieldName}\" is defined but never used`,\r\n          suggestion: 'Remove unused field or implement its usage',\r\n        });\r\n      }\r\n\r\n      // Check if field is mutated outside setState\r\n      const mutationsOutsideSetState = this.findMutationsOutsideSetState(\r\n        fieldName,\r\n        stateClassName\r\n      );\r\n      if (mutationsOutsideSetState.length > 0) {\r\n        this.validationResults.push({\r\n          type: 'mutation-outside-setstate',\r\n          severity: 'error',\r\n          field: fieldName,\r\n          locations: mutationsOutsideSetState,\r\n          message: `State field \"${fieldName}\" is mutated outside setState()`,\r\n          suggestion: 'Always use setState() to update state fields',\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if field is used anywhere\r\n   */\r\n  fieldIsUsed(fieldName, stateClassName) {\r\n    // Check if read in build\r\n    const stateClass = this.stateClasses.get(stateClassName);\r\n    if (!stateClass) return false;\r\n\r\n    const buildMethod = stateClass.astNode.body.methods.find(\r\n      (m) => m.key.name === 'build'\r\n    );\r\n\r\n    if (buildMethod && this.methodUsesField(buildMethod, fieldName)) {\r\n      return true;\r\n    }\r\n\r\n    // Check if modified in setState\r\n    return this.setStateCalls.some((call) => call.updates.includes(fieldName));\r\n  }\r\n\r\n  /**\r\n   * Find mutations outside setState\r\n   */\r\n  findMutationsOutsideSetState(fieldName, stateClassName) {\r\n    const locations = [];\r\n    const inSetState = new Set();\r\n\r\n    // Collect all fields modified in setState\r\n    this.setStateCalls.forEach((call) => {\r\n      call.updates.forEach((field) => {\r\n        inSetState.add(field);\r\n      });\r\n    });\r\n\r\n    // If field is only in setState, it's good\r\n    if (!inSetState.has(fieldName)) {\r\n      return locations;\r\n    }\r\n\r\n    // For now, we assume mutations are only through setState\r\n    // In a full implementation, you'd scan all methods for direct assignments\r\n    return locations;\r\n  }\r\n\r\n  /**\r\n   * Validate lifecycle patterns\r\n   */\r\n  validateLifecyclePatterns() {\r\n    this.stateClasses.forEach(({ metadata }) => {\r\n      const methodMap = {};\r\n\r\n      metadata.lifecycleMethods.forEach((method) => {\r\n        methodMap[method.name] = method;\r\n      });\r\n\r\n      // dispose should call super.dispose\r\n      if (methodMap.dispose && !methodMap.dispose.callsSuper) {\r\n        this.validationResults.push({\r\n          type: 'lifecycle-issue',\r\n          severity: 'error',\r\n          method: 'dispose',\r\n          location: methodMap.dispose.location,\r\n          message: 'dispose() should call super.dispose()',\r\n          suggestion: 'Add super.dispose() call at the end of dispose()',\r\n        });\r\n      }\r\n\r\n      // initState should call super.initState\r\n      if (methodMap.initState && !methodMap.initState.callsSuper) {\r\n        this.validationResults.push({\r\n          type: 'lifecycle-issue',\r\n          severity: 'warning',\r\n          method: 'initState',\r\n          location: methodMap.initState.location,\r\n          message: 'initState() should call super.initState()',\r\n          suggestion: 'Add super.initState() call',\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate event handlers\r\n   */\r\n  validateEventHandlers() {\r\n    this.eventHandlers.forEach((handler) => {\r\n      // Check if handler method exists\r\n      const handlerExists = this.stateClasses.values().some((sc) => {\r\n        return sc.metadata.stateFields.some((f) => f.name === handler.handler) ||\r\n          sc.astNode.body.methods.some((m) => m.key.name === handler.handler);\r\n      });\r\n\r\n      if (!handlerExists && handler.handler) {\r\n        this.validationResults.push({\r\n          type: 'missing-handler',\r\n          severity: 'error',\r\n          handler: handler.handler,\r\n          event: handler.event,\r\n          location: handler.location,\r\n          message: `Event handler \"${handler.handler}\" not found`,\r\n          suggestion: `Create a method called ${handler.handler} in the State class`,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get final results\r\n   */\r\n  getResults() {\r\n    return {\r\n      stateClasses: Array.from(this.stateClasses.entries()).map(([name, data]) => ({\r\n        name,\r\n        metadata: data.metadata,\r\n      })),\r\n      stateFields: Array.from(this.stateFields.values()),\r\n      setStateCalls: this.setStateCalls,\r\n      lifecycleMethods: this.lifecycleMethods,\r\n      eventHandlers: this.eventHandlers,\r\n      dependencyGraph: this.dependencyGraph,\r\n      validationResults: this.validationResults,\r\n      errors: this.errors,\r\n    };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// DATA CLASSES\r\n// ============================================================================\r\n\r\nclass StateClassMetadata {\r\n  constructor(name, location, linkedStatefulWidget) {\r\n    this.name = name;\r\n    this.location = location;\r\n    this.linkedStatefulWidget = linkedStatefulWidget;\r\n    this.stateFields = [];\r\n    this.lifecycleMethods = [];\r\n    this.methods = [];\r\n  }\r\n}\r\n\r\nclass StateField {\r\n  constructor(name, type, initialValue, location) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.initialValue = initialValue;\r\n    this.location = location;\r\n    this.isMutable = true;\r\n    this.mutations = [];\r\n    this.usedInMethods = [];\r\n    this.usedInBuild = false;\r\n  }\r\n}\r\n\r\nclass LifecycleMethod {\r\n  constructor(name, location, params, callsSuper, hasSideEffects) {\r\n    this.name = name;\r\n    this.location = location;\r\n    this.params = params;\r\n    this.callsSuper = callsSuper;\r\n    this.hasSideEffects = hasSideEffects;\r\n  }\r\n}\r\n\r\nclass StateUpdateCall {\r\n  constructor(location, method, updates, stateClassName) {\r\n    this.location = location;\r\n    this.method = method;\r\n    this.updates = updates || [];\r\n    this.stateClassName = stateClassName;\r\n    this.isValid = true;\r\n    this.issues = [];\r\n  }\r\n}\r\n\r\nclass DependencyGraph {\r\n  constructor() {\r\n    this.stateToMethods = new Map();\r\n    this.methodToState = new Map();\r\n    this.eventToState = new Map();\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EXPORTS\r\n// ============================================================================\r\n\r\nexport {\r\n  StateAnalyzer,\r\n  StateClassMetadata,\r\n  StateField,\r\n  LifecycleMethod,\r\n  StateUpdateCall,\r\n  DependencyGraph,\r\n};"],
  "mappings": "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",
  "names": ["StateAnalyzer", "ast", "widgets", "options", "error", "widget", "m", "widgetNode", "n", "createStateNode", "stateClassName", "stateClassNode", "stateMetadata", "StateClassMetadata", "methodBody", "stmt", "className", "expr", "astNode", "metadata", "field", "fieldName", "initialValue", "type", "stateField", "StateField", "name", "method", "setStateCalls", "calls", "methodName", "s", "updatedFields", "call", "StateUpdateCall", "arg", "prop", "obj", "setStateCall", "updated", "callback", "body", "mutated", "fields", "target", "lifecycleNames", "lifecycle", "LifecycleMethod", "stmts", "buildMethod", "handlers", "eventName", "handler", "keyExpr", "value", "DependencyGraph", "key", "methods", "methodsUsing", "event", "stateChanged", "changed", "update", "issues", "parts", "mutationsOutsideSetState", "stateClass", "locations", "inSetState", "methodMap", "sc", "f", "data", "location", "linkedStatefulWidget", "params", "callsSuper", "hasSideEffects", "updates"]
}
