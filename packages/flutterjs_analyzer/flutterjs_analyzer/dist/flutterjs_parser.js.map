{
  "version": 3,
  "sources": ["../src/flutterjs_parser.js"],
  "sourcesContent": ["// Copyright 2025 The FlutterJS Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style license that can be\r\n// found in the LICENSE file.\r\n\r\n/**\r\n * FlutterJS Parser - Converts tokens to AST (FIXED VERSION)\r\n * Phase 1.2 MVP Implementation - Complete Fixes\r\n * \r\n * Final fix: parseParameterList handles UNDEFINED and NULL token types\r\n */\r\n\r\n\r\nimport { TokenType } from './lexer.js';\r\nimport { getLogger } from './flutterjs_logger.js';\r\n\r\n// ============================================================================\r\n// AST NODE CLASSES\r\n// ============================================================================\r\n\r\nclass ASTNode {\r\n  constructor(type, location) {\r\n    this.type = type;\r\n    this.location = location;\r\n  }\r\n}\r\n\r\nclass Program extends ASTNode {\r\n  constructor(body = [], location = null) {\r\n    super('Program', location);\r\n    this.body = body;\r\n  }\r\n}\r\n\r\nclass ImportDeclaration extends ASTNode {\r\n  constructor(specifiers = [], source = null, location = null) {\r\n    super('ImportDeclaration', location);\r\n    this.specifiers = specifiers;\r\n    this.source = source;\r\n  }\r\n}\r\n\r\nclass ImportSpecifier extends ASTNode {\r\n  constructor(imported = null, local = null, location = null) {\r\n    super('ImportSpecifier', location);\r\n    this.imported = imported;\r\n    this.local = local;\r\n  }\r\n}\r\n\r\nclass ClassDeclaration extends ASTNode {\r\n  constructor(id = null, superClass = null, body = null, location = null) {\r\n    super('ClassDeclaration', location);\r\n    this.id = id;\r\n    this.superClass = superClass;\r\n    this.body = body;\r\n  }\r\n}\r\n\r\nclass ClassBody extends ASTNode {\r\n  constructor(fields = [], methods = [], location = null) {\r\n    super('ClassBody', location);\r\n    this.fields = fields;\r\n    this.methods = methods;\r\n  }\r\n}\r\n\r\nclass FieldDeclaration extends ASTNode {\r\n  constructor(key = null, initialValue = null, location = null) {\r\n    super('FieldDeclaration', location);\r\n    this.key = key;\r\n    this.initialValue = initialValue;\r\n  }\r\n}\r\n\r\nclass MethodDeclaration extends ASTNode {\r\n  constructor(key = null, params = [], body = null, location = null) {\r\n    super('MethodDeclaration', location);\r\n    this.key = key;\r\n    this.params = params;\r\n    this.body = body;\r\n  }\r\n}\r\n\r\nclass Parameter extends ASTNode {\r\n  constructor(name = null, optional = false, defaultValue = null, location = null) {\r\n    super('Parameter', location);\r\n    this.name = name;\r\n    this.optional = optional;\r\n    this.defaultValue = defaultValue;\r\n  }\r\n}\r\n\r\nclass FunctionDeclaration extends ASTNode {\r\n  constructor(id = null, params = [], body = null, isAsync = false, location = null) {\r\n    super('FunctionDeclaration', location);\r\n    this.id = id;\r\n    this.params = params;\r\n    this.body = body;\r\n    this.isAsync = isAsync;\r\n  }\r\n}\r\n\r\nclass BlockStatement extends ASTNode {\r\n  constructor(body = [], location = null) {\r\n    super('BlockStatement', location);\r\n    this.body = body;\r\n  }\r\n}\r\n\r\nclass ReturnStatement extends ASTNode {\r\n  constructor(argument = null, location = null) {\r\n    super('ReturnStatement', location);\r\n    this.argument = argument;\r\n  }\r\n}\r\n\r\nclass ExpressionStatement extends ASTNode {\r\n  constructor(expression = null, location = null) {\r\n    super('ExpressionStatement', location);\r\n    this.expression = expression;\r\n  }\r\n}\r\n\r\nclass Identifier extends ASTNode {\r\n  constructor(name = '', location = null) {\r\n    super('Identifier', location);\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nclass Literal extends ASTNode {\r\n  constructor(value = null, raw = '', type = 'string', location = null) {\r\n    super('Literal', location);\r\n    this.value = value;\r\n    this.raw = raw;\r\n    this.literalType = type;\r\n  }\r\n}\r\n\r\nclass CallExpression extends ASTNode {\r\n  constructor(callee = null, args = [], location = null) {\r\n    super('CallExpression', location);\r\n    this.callee = callee;\r\n    this.args = args;\r\n  }\r\n}\r\n\r\nclass NewExpression extends ASTNode {\r\n  constructor(callee = null, args = [], location = null) {\r\n    super('NewExpression', location);\r\n    this.callee = callee;\r\n    this.args = args;\r\n    this.isConst = false;\r\n  }\r\n}\r\n\r\nclass ObjectLiteral extends ASTNode {\r\n  constructor(properties = [], location = null) {\r\n    super('ObjectLiteral', location);\r\n    this.properties = properties;\r\n  }\r\n}\r\n\r\nclass Property extends ASTNode {\r\n  constructor(key = null, value = null, location = null) {\r\n    super('Property', location);\r\n    this.key = key;\r\n    this.value = value;\r\n    this.shorthand = false;\r\n  }\r\n}\r\n\r\nclass ArrowFunctionExpression extends ASTNode {\r\n  constructor(params = [], body = null, location = null) {\r\n    super('ArrowFunctionExpression', location);\r\n    this.params = params;\r\n    this.body = body;\r\n  }\r\n}\r\n\r\nclass MemberExpression extends ASTNode {\r\n  constructor(object = null, property = null, computed = false, location = null) {\r\n    super('MemberExpression', location);\r\n    this.object = object;\r\n    this.property = property;\r\n    this.computed = computed;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// PARSER CLASS\r\n// ============================================================================\r\n\r\nclass Parser {\r\n  constructor(tokens = [], options = {}) {\r\n    this.tokens = tokens;\r\n    this.current = 0;\r\n    this.errors = [];\r\n    this.options = { strict: false, ...options };\r\n    // NEW: Call stack tracking\r\n    this.callStack = [];\r\n\r\n    this.debugMode = true;\r\n  }\r\n\r\n  parse() {\r\n    const body = [];\r\n\r\n    while (!this.isAtEnd()) {\r\n      try {\r\n        const stmt = this.parseTopLevel();\r\n        if (stmt && stmt.type === 'ImportDeclaration') {\r\n          console.log('DEBUG - ImportDeclaration:', JSON.stringify(stmt, null, 2));\r\n        }\r\n        if (stmt) {\r\n          body.push(stmt);\r\n        }\r\n      } catch (error) {\r\n        this.errors.push(error);\r\n        this.synchronize();\r\n      }\r\n    }\r\n\r\n    return new Program(body);\r\n  }\r\n\r\n  /**\r\n * Skip any comment tokens\r\n * Comments should be transparent to the parser\r\n */\r\n  skipComments() {\r\n    while (!this.isAtEnd() && this.check(TokenType.COMMENT)) {\r\n      this.advance();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if token is a comment\r\n   */\r\n  isComment() {\r\n    if (this.isAtEnd()) return false;\r\n    return this.peek().type === TokenType.COMMENT;\r\n  }\r\n\r\n\r\n  parseTopLevel() {\r\n    this.skipComments();  // \u2190 ADD THIS LINE\r\n\r\n    if (this.isAtEnd()) return null;\r\n\r\n    if (this.isKeyword('import')) {\r\n      this.advance();\r\n      return this.parseImportDeclaration();\r\n    }\r\n\r\n    if (this.isKeyword('class')) {\r\n      this.advance();\r\n      return this.parseClassDeclaration();\r\n    }\r\n\r\n    if (this.isKeyword('function')) {\r\n      this.advance();\r\n      return this.parseFunctionDeclaration();\r\n    }\r\n\r\n    const expr = this.parseExpression();\r\n    this.consumeStatementEnd();\r\n    return new ExpressionStatement(expr, this.getLocation());\r\n  }\r\n  isKeyword(value) {\r\n    if (this.isAtEnd()) return false;\r\n    const token = this.peek();\r\n    return token.type === TokenType.KEYWORD && token.value === value;\r\n  }\r\n\r\n  isPunctuation(value) {\r\n    if (this.isAtEnd()) return false;\r\n    const token = this.peek();\r\n    return token.type === TokenType.PUNCTUATION && token.value === value;\r\n  }\r\n\r\n  isOperator(value) {\r\n    if (this.isAtEnd()) return false;\r\n    const token = this.peek();\r\n    return token.type === TokenType.OPERATOR && token.value === value;\r\n  }\r\n\r\n  /**\r\n * FIXED: parseImportDeclaration() in flutterjs_parser.js\r\n * Handles multi-line imports with comments and proper spacing\r\n * \r\n * Replace the entire parseImportDeclaration() method with this version\r\n */\r\n\r\n  parseImportDeclaration() {\r\n    const logger = getLogger().createComponentLogger('Parser.parseImportDeclaration');\r\n    logger.startSession('parseImportDeclaration');\r\n\r\n    const startLocation = this.getLocation();\r\n    const specifiers = [];\r\n\r\n    logger.trace(`  Starting import parse at token: ${this.peek().value}`);\r\n\r\n    // Case 1: Named imports { x, y, z }\r\n    if (this.isPunctuation('{')) {\r\n      logger.trace(`  Found opening brace, parsing named imports...`);\r\n      this.advance();\r\n\r\n      // \u2705 FIX #1: Skip comments right after opening brace\r\n      this.skipComments();\r\n\r\n      while (!this.isPunctuation('}') && !this.isAtEnd()) {\r\n        // \u2705 FIX #2: Skip comments before checking for closing brace\r\n        this.skipComments();\r\n\r\n        // Check if we hit the closing brace (after skipping comments)\r\n        if (this.isPunctuation('}')) {\r\n          logger.trace(`  Found closing brace, exiting loop`);\r\n          break;\r\n        }\r\n\r\n        // Expect an identifier\r\n        if (!this.check(TokenType.IDENTIFIER)) {\r\n          logger.warn(`  Expected identifier but got: ${this.peek().value}`);\r\n          this.advance();\r\n          continue;\r\n        }\r\n\r\n        // Get the imported name\r\n        const importedName = this.consume(TokenType.IDENTIFIER, 'Expected identifier').value;\r\n        const imported = new Identifier(importedName);\r\n        logger.trace(`    Imported: ${importedName}`);\r\n\r\n        let local = imported; // Default: local name = imported name\r\n\r\n        // \u2705 FIX #3: Skip comments before checking for 'as'\r\n        this.skipComments();\r\n\r\n        // Check for 'as' alias\r\n        if (this.isKeyword('as')) {\r\n          logger.trace(`    Found 'as' keyword`);\r\n          this.advance();\r\n\r\n          // \u2705 FIX #4: Skip comments after 'as'\r\n          this.skipComments();\r\n\r\n          const localName = this.consume(TokenType.IDENTIFIER, 'Expected identifier after as').value;\r\n          local = new Identifier(localName);\r\n          logger.trace(`      Local name: ${localName}`);\r\n        }\r\n\r\n        // Add specifier to list\r\n        specifiers.push(new ImportSpecifier(imported, local));\r\n\r\n        // \u2705 FIX #5: Skip comments before checking for comma\r\n        this.skipComments();\r\n\r\n        // Check for comma separator\r\n        if (this.isPunctuation(',')) {\r\n          logger.trace(`    Found comma, continuing...`);\r\n          this.advance();\r\n\r\n          // \u2705 FIX #6: Skip comments after comma\r\n          this.skipComments();\r\n\r\n          // Continue to next item\r\n          continue;\r\n        } else {\r\n          logger.trace(`    No comma, expected closing brace next`);\r\n          // No more items, should see closing brace\r\n          break;\r\n        }\r\n      }\r\n\r\n      logger.trace(`  Parsed ${specifiers.length} named imports`);\r\n\r\n      // Consume closing brace\r\n      this.consume(TokenType.PUNCTUATION, 'Expected }');\r\n    }\r\n\r\n    // Case 2: Default import or default + named\r\n    // import MyDefault from 'module'\r\n    // import MyDefault, { x, y } from 'module'\r\n    else if (this.check(TokenType.IDENTIFIER) && this.peekAhead(1).value !== 'from') {\r\n      logger.trace(`  Found identifier without opening brace, parsing default import...`);\r\n\r\n      const defaultName = this.consume(TokenType.IDENTIFIER, 'Expected identifier').value;\r\n      const imported = new Identifier(defaultName);\r\n      const local = new Identifier(defaultName);\r\n      specifiers.push(new ImportSpecifier(imported, local));\r\n\r\n      logger.trace(`  Default import: ${defaultName}`);\r\n\r\n      // Check for comma and additional named imports\r\n      this.skipComments();\r\n      if (this.isPunctuation(',')) {\r\n        logger.trace(`  Found comma after default import, checking for named imports...`);\r\n        this.advance();\r\n\r\n        this.skipComments();\r\n        if (this.isPunctuation('{')) {\r\n          logger.trace(`  Found opening brace, parsing additional named imports...`);\r\n          this.advance();\r\n\r\n          this.skipComments();\r\n          while (!this.isPunctuation('}') && !this.isAtEnd()) {\r\n            this.skipComments();\r\n\r\n            if (this.isPunctuation('}')) break;\r\n\r\n            if (!this.check(TokenType.IDENTIFIER)) {\r\n              this.advance();\r\n              continue;\r\n            }\r\n\r\n            const name = this.consume(TokenType.IDENTIFIER, 'Expected identifier').value;\r\n            const imported2 = new Identifier(name);\r\n            let local2 = imported2;\r\n\r\n            this.skipComments();\r\n\r\n            if (this.isKeyword('as')) {\r\n              this.advance();\r\n              this.skipComments();\r\n              const localName = this.consume(TokenType.IDENTIFIER, 'Expected identifier after as').value;\r\n              local2 = new Identifier(localName);\r\n            }\r\n\r\n            specifiers.push(new ImportSpecifier(imported2, local2));\r\n\r\n            this.skipComments();\r\n\r\n            if (this.isPunctuation(',')) {\r\n              this.advance();\r\n              this.skipComments();\r\n              continue;\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n\r\n          this.consume(TokenType.PUNCTUATION, 'Expected }');\r\n        }\r\n      }\r\n    }\r\n\r\n    // \u2705 FIX #7: Skip comments before 'from'\r\n    this.skipComments();\r\n\r\n    // Consume 'from' keyword\r\n    this.consume(TokenType.KEYWORD, 'Expected from');\r\n\r\n    // \u2705 FIX #8: Skip comments before module path string\r\n    this.skipComments();\r\n\r\n    // Get the module/source path\r\n    const modulePathToken = this.consume(TokenType.STRING, 'Expected module path string');\r\n    const source = new Literal(\r\n      modulePathToken.value,\r\n      modulePathToken.value,\r\n      'string'\r\n    );\r\n\r\n    logger.trace(`  Module path: ${source.value}`);\r\n    logger.trace(`  Total specifiers: ${specifiers.length}`);\r\n\r\n    // \u2705 FIX #9: Consume statement end (handles semicolon and trailing comments)\r\n    this.consumeStatementEnd();\r\n\r\n    logger.trace(`[parseImportDeclaration] SUCCESS\\n`);\r\n    return new ImportDeclaration(specifiers, source, startLocation);\r\n  }\r\n\r\n  /**\r\n   * Helper method: Check if lookahead token matches (needed for peekAhead)\r\n   * Add this if not already present\r\n   */\r\n  peekAhead(n = 1) {\r\n    const pos = this.current + n;\r\n    if (pos >= this.tokens.length) {\r\n      return this.tokens[this.tokens.length - 1];\r\n    }\r\n    return this.tokens[pos];\r\n  }\r\n\r\n  parseClassDeclaration() {\r\n    const logger = getLogger().createComponentLogger('Parser.parseClassDeclaration');\r\n    logger.startSession('parseClassDeclaration');\r\n    logger.trace(`  Current token: ${this.peek().value} (${this.peek().type})`);\r\n\r\n    const startLocation = this.getLocation();\r\n    const nameToken = this.consume(TokenType.IDENTIFIER, 'Expected class name');\r\n    const name = new Identifier(nameToken.value);\r\n    logger.trace(`  Class name: ${name.name}`);\r\n\r\n    let superClass = null;\r\n    if (this.isKeyword('extends')) {\r\n      this.advance();\r\n      const superName = this.consume(TokenType.IDENTIFIER, 'Expected superclass name').value;\r\n      superClass = new Identifier(superName);\r\n      logger.trace(`  Extends: ${superClass.name}`);\r\n\r\n      // Skip generic type parameters like <MyCounter>\r\n      if (this.isOperator('<')) {\r\n        this.advance();\r\n        this.consume(TokenType.IDENTIFIER, 'Expected type name');\r\n        this.consume(TokenType.OPERATOR, 'Expected >');\r\n      }\r\n    }\r\n\r\n    logger.trace(`  Looking for opening brace...`);\r\n    logger.trace(`  Current token: ${this.peek().value} (${this.peek().type})`);\r\n    this.consume(TokenType.PUNCTUATION, 'Expected {');\r\n\r\n    const fields = [];\r\n    const methods = [];\r\n\r\n    logger.trace(`  Parsing class body...`);\r\n    let itemCount = 0;\r\n\r\n    while (!this.isPunctuation('}') && !this.isAtEnd()) {\r\n      this.skipComments();  // \u2190 ADD THIS LINE - skip comments in class body\r\n\r\n      if (this.isPunctuation('}')) break;  // Check again after skipping comments\r\n\r\n      logger.trace(`    [item ${itemCount}] Current token: ${this.peek().value} (${this.peek().type})`);\r\n\r\n      // Skip semicolons\r\n      if (this.isPunctuation(';')) {\r\n        logger.trace(`    Skipping semicolon`);\r\n        this.advance();\r\n        continue;\r\n      }\r\n\r\n      // Check for constructor (always a method)\r\n      if (this.isKeyword('constructor')) {\r\n        logger.trace(`    Found constructor`);\r\n        methods.push(this.parseMethodDeclaration());\r\n        itemCount++;\r\n        continue;\r\n      }\r\n\r\n      // Check for field or method\r\n      if (this.check(TokenType.IDENTIFIER)) {\r\n        const currentPos = this.current;\r\n        const idToken = this.peek();\r\n        const fieldName = idToken.value;\r\n        logger.trace(`    Found identifier: ${fieldName}`);\r\n        this.advance();\r\n\r\n        // CASE 1: Field initializer - IDENTIFIER = value\r\n        if (this.isOperator('=')) {\r\n          logger.trace(`      -> This is a FIELD (followed by =)`);\r\n          this.current = currentPos; // Rewind\r\n          try {\r\n            fields.push(this.parseFieldDeclaration());\r\n            logger.trace(`      Field parsed successfully`);\r\n            itemCount++;\r\n            continue;\r\n          } catch (e) {\r\n            console.error(`      ERROR parsing field: ${e.message}`);\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        // CASE 2: Method - IDENTIFIER ( params )\r\n        if (this.isPunctuation('(')) {\r\n          logger.trace(`      -> This is a METHOD (followed by '(')`);\r\n          this.current = currentPos; // Rewind\r\n          try {\r\n            methods.push(this.parseMethodDeclaration());\r\n            logger.trace(`      Method parsed successfully`);\r\n            itemCount++;\r\n            continue;\r\n          } catch (e) {\r\n            console.error(`      ERROR parsing method: ${e.message}`);\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        logger.trace(`      -> Unknown pattern, skipping`);\r\n        this.advance();\r\n        continue;\r\n      }\r\n\r\n      // Skip unknown tokens\r\n      logger.trace(`    Skipping unknown token: ${this.peek().value}`);\r\n      this.advance();\r\n    }\r\n\r\n    logger.trace(`  Class body parsing complete. Found ${fields.length} fields, ${methods.length} methods`);\r\n\r\n    this.consume(TokenType.PUNCTUATION, 'Expected }');\r\n    const body = new ClassBody(fields, methods);\r\n    logger.trace(`[parseClassDeclaration] SUCCESS\\n`);\r\n    return new ClassDeclaration(name, superClass, body, startLocation);\r\n  }\r\n\r\n\r\n  parseMethodDeclaration() {\r\n    const logger = getLogger().createComponentLogger('Parser.parseMethodDeclaration');\r\n    logger.startSession(`      [parseMethodDeclaration] STARTING`);\r\n    logger.trace(`        Current: ${this.peek().value}`);\r\n\r\n    const startLocation = this.getLocation();\r\n\r\n    let methodName;\r\n    if (this.isKeyword('constructor')) {\r\n      methodName = 'constructor';\r\n      this.advance();\r\n    } else {\r\n      methodName = this.consume(TokenType.IDENTIFIER, 'Expected method name').value;\r\n    }\r\n\r\n    logger.trace(`        Method name: ${methodName}`);\r\n    const key = new Identifier(methodName);\r\n\r\n    this.consume(TokenType.PUNCTUATION, 'Expected (');\r\n    const params = this.parseParameterList();\r\n    logger.trace(`        Parameters: ${params.length}`);\r\n    this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n\r\n    let body = null;\r\n    if (this.isOperator('=>')) {\r\n      logger.trace(`        Arrow function body`);\r\n      this.advance();\r\n      body = this.parseExpression();\r\n    } else if (this.isPunctuation('{')) {\r\n      logger.trace(`        Block body`);\r\n      this.advance();\r\n      body = this.parseBlock();\r\n    }\r\n\r\n    logger.trace(`      [parseMethodDeclaration] SUCCESS`);\r\n    return new MethodDeclaration(key, params, body, startLocation);\r\n  }\r\n  parseFieldDeclaration() {\r\n    console.log(`      [parseFieldDeclaration] STARTING`);\r\n    console.log(`        Current: ${this.peek().value}`);\r\n\r\n    const startLocation = this.getLocation();\r\n    const fieldName = this.consume(TokenType.IDENTIFIER, 'Expected field name').value;\r\n    const key = new Identifier(fieldName);\r\n    console.log(`        Field name: ${fieldName}`);\r\n\r\n    let initialValue = null;\r\n    if (this.isOperator('=')) {\r\n      console.log(`        Found = operator, parsing initializer...`);\r\n      this.advance();\r\n      try {\r\n        initialValue = this.parseExpression();\r\n        console.log(`        Initializer parsed: ${initialValue.type}`);\r\n      } catch (e) {\r\n        console.error(`        ERROR parsing initializer: ${e.message}`);\r\n        throw e;\r\n      }\r\n    }\r\n\r\n    this.consumeStatementEnd();\r\n    console.log(`      [parseFieldDeclaration] SUCCESS`);\r\n    return new FieldDeclaration(key, initialValue, startLocation);\r\n  }\r\n\r\n  parseFunctionDeclaration() {\r\n    const startLocation = this.getLocation();\r\n    const nameToken = this.consume(TokenType.IDENTIFIER, 'Expected function name');\r\n    const name = nameToken.value ? new Identifier(nameToken.value) : null;\r\n\r\n    this.consume(TokenType.PUNCTUATION, 'Expected (');\r\n    const params = this.parseParameterList();\r\n    this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n\r\n    this.consume(TokenType.PUNCTUATION, 'Expected {');\r\n    const body = this.parseBlock();\r\n\r\n    return new FunctionDeclaration(name, params, body, false, startLocation);\r\n  }\r\n\r\n  /**\r\n   * Parse parameter list - FIXED to handle UNDEFINED and NULL token types\r\n   */\r\n  parseParameterList() {\r\n    const params = [];\r\n\r\n    while (!this.isPunctuation(')') && !this.isAtEnd()) {\r\n      const paramLocation = this.getLocation();\r\n\r\n      // Handle destructuring: { key = value }\r\n      if (this.isPunctuation('{')) {\r\n        this.advance();\r\n        while (!this.isPunctuation('}') && !this.isAtEnd()) {\r\n          const paramName = this.consume(TokenType.IDENTIFIER, 'Expected param name').value;\r\n          let defaultValue = null;\r\n\r\n          if (this.isOperator('=')) {\r\n            this.advance();\r\n            // FIXED: Check token type, not just keywords\r\n            const token = this.peek();\r\n\r\n            if (this.check(TokenType.IDENTIFIER)) {\r\n              defaultValue = new Identifier(this.advance().value);\r\n            } else if (this.check(TokenType.NUMBER)) {\r\n              defaultValue = new Literal(parseFloat(this.advance().value), '', 'number');\r\n            } else if (this.check(TokenType.UNDEFINED)) {\r\n              // FIXED: Handle UNDEFINED token type\r\n              this.advance();\r\n              defaultValue = new Literal(undefined, 'undefined', 'undefined');\r\n            } else if (this.check(TokenType.NULL)) {\r\n              // FIXED: Handle NULL token type\r\n              this.advance();\r\n              defaultValue = new Literal(null, 'null', 'null');\r\n            } else if (this.isKeyword('undefined')) {\r\n              this.advance();\r\n              defaultValue = new Literal(undefined, 'undefined', 'undefined');\r\n            } else if (this.isKeyword('null')) {\r\n              this.advance();\r\n              defaultValue = new Literal(null, 'null', 'null');\r\n            }\r\n          }\r\n\r\n          params.push(new Parameter(new Identifier(paramName), defaultValue !== null, defaultValue, paramLocation));\r\n\r\n          if (!this.isPunctuation(',')) break;\r\n          this.advance();\r\n        }\r\n        this.consume(TokenType.PUNCTUATION, 'Expected }');\r\n\r\n        // Handle = {} after destructuring\r\n        if (this.isOperator('=')) {\r\n          this.advance();\r\n          if (this.isPunctuation('{')) {\r\n            this.advance();\r\n            let braceDepth = 1;\r\n            while (braceDepth > 0 && !this.isAtEnd()) {\r\n              if (this.isPunctuation('{')) braceDepth++;\r\n              else if (this.isPunctuation('}')) braceDepth--;\r\n              if (braceDepth > 0) this.advance();\r\n            }\r\n            this.consume(TokenType.PUNCTUATION, 'Expected }');\r\n          }\r\n        }\r\n      } else if (this.check(TokenType.IDENTIFIER)) {\r\n        // Regular parameter\r\n        const paramName = this.consume(TokenType.IDENTIFIER, 'Expected param name').value;\r\n        let defaultValue = null;\r\n\r\n        if (this.isOperator('=')) {\r\n          this.advance();\r\n          const token = this.peek();\r\n\r\n          if (this.check(TokenType.IDENTIFIER)) {\r\n            defaultValue = new Identifier(this.advance().value);\r\n          } else if (this.check(TokenType.NUMBER)) {\r\n            defaultValue = new Literal(parseFloat(this.advance().value), '', 'number');\r\n          } else if (this.check(TokenType.UNDEFINED)) {\r\n            this.advance();\r\n            defaultValue = new Literal(undefined, 'undefined', 'undefined');\r\n          } else if (this.check(TokenType.NULL)) {\r\n            this.advance();\r\n            defaultValue = new Literal(null, 'null', 'null');\r\n          } else if (this.isKeyword('undefined')) {\r\n            this.advance();\r\n            defaultValue = new Literal(undefined, 'undefined', 'undefined');\r\n          } else if (this.isKeyword('null')) {\r\n            this.advance();\r\n            defaultValue = new Literal(null, 'null', 'null');\r\n          }\r\n        }\r\n\r\n        params.push(new Parameter(new Identifier(paramName), defaultValue !== null, defaultValue, paramLocation));\r\n      } else {\r\n        break;\r\n      }\r\n\r\n      if (!this.isPunctuation(',')) break;\r\n      this.advance();\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  parseBlock() {\r\n    console.log(`\\n[parseBlock] STARTING at token: ${this.peek().value}`);\r\n\r\n    const startLocation = this.getLocation();\r\n    const statements = [];\r\n\r\n    while (!this.isPunctuation('}') && !this.isAtEnd()) {\r\n      this.skipComments();  // \u2190 ADD THIS LINE - skip comments in block\r\n\r\n      if (this.isPunctuation('}')) break;  // Check again after skipping\r\n\r\n      console.log(`  [parseBlock] Current token: ${this.peek().value} (${this.peek().type})`);\r\n\r\n      if (this.isKeyword('return')) {\r\n        console.log(`    Found RETURN statement`);\r\n        this.advance();\r\n        let argument = null;\r\n\r\n        if (!this.isPunctuation(';') && !this.isPunctuation('}')) {\r\n          console.log(`    Parsing return argument...`);\r\n          try {\r\n            argument = this.parseExpression();\r\n            console.log(`    Return argument parsed successfully`);\r\n          } catch (error) {\r\n            console.error(`    \u274C ERROR parsing return argument: ${error.message}`);\r\n            console.error(`       Token was: ${this.peek().value}`);\r\n\r\n            // Skip to semicolon\r\n            while (!this.isPunctuation(';') && !this.isPunctuation('}') && !this.isAtEnd()) {\r\n              this.advance();\r\n            }\r\n          }\r\n        }\r\n\r\n        this.consumeStatementEnd();\r\n        statements.push(new ReturnStatement(argument, startLocation));\r\n\r\n      } else {\r\n        console.log(`    Parsing expression statement...`);\r\n        try {\r\n          const expr = this.parseExpression();\r\n          console.log(`    Expression parsed successfully: ${expr.type}`);\r\n          this.consumeStatementEnd();\r\n          statements.push(new ExpressionStatement(expr, startLocation));\r\n        } catch (error) {\r\n          console.error(`    \u274C ERROR parsing expression: ${error.message}`);\r\n          console.error(`       Token was: ${this.peek().value}`);\r\n\r\n          // Skip to next statement\r\n          while (!this.isPunctuation(';') && !this.isPunctuation('}') && !this.isAtEnd()) {\r\n            this.advance();\r\n          }\r\n          if (this.isPunctuation(';')) {\r\n            this.advance();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.isPunctuation('}')) {\r\n      this.advance();\r\n    }\r\n\r\n    console.log(`[parseBlock] SUCCESS - ${statements.length} statements\\n`);\r\n    return new BlockStatement(statements, startLocation);\r\n  }\r\n\r\n  parseExpression() {\r\n    console.log(`    [parseExpression] Current token: ${this.peek().value}`);\r\n    try {\r\n      const result = this.parseAssignment();\r\n      console.log(`    [parseExpression] \u2713 Success, type: ${result.type}`);\r\n      return result;\r\n    } catch (e) {\r\n      console.error(`    [parseExpression] \u2717 Failed: ${e.message}`);\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  parseAssignment() {\r\n    let expr = this.parseTernary();\r\n\r\n    if (this.isOperator('=')) {\r\n      this.advance();\r\n      const value = this.parseAssignment();\r\n      return { type: 'AssignmentExpression', left: expr, right: value };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseTernary() {\r\n    let expr = this.parseLogicalOr();\r\n\r\n    if (this.isOperator('?')) {\r\n      this.advance();\r\n      const consequent = this.parseExpression();\r\n      this.consume(TokenType.OPERATOR, 'Expected :');\r\n      const alternate = this.parseExpression();\r\n      return { type: 'ConditionalExpression', test: expr, consequent, alternate };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseLogicalOr() {\r\n    let expr = this.parseLogicalAnd();\r\n\r\n    while (this.isOperator('||')) {\r\n      this.advance();\r\n      const right = this.parseLogicalAnd();\r\n      expr = { type: 'LogicalExpression', operator: '||', left: expr, right };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseLogicalAnd() {\r\n    let expr = this.parseEquality();\r\n\r\n    while (this.isOperator('&&')) {\r\n      this.advance();\r\n      const right = this.parseEquality();\r\n      expr = { type: 'LogicalExpression', operator: '&&', left: expr, right };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseEquality() {\r\n    let expr = this.parseRelational();\r\n\r\n    while (this.isOperator('===') || this.isOperator('!==') || this.isOperator('==') || this.isOperator('!=')) {\r\n      const operator = this.advance().value;\r\n      const right = this.parseRelational();\r\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseRelational() {\r\n    let expr = this.parseAdditive();\r\n\r\n    while (this.isOperator('<') || this.isOperator('>') || this.isOperator('<=') || this.isOperator('>=')) {\r\n      const operator = this.advance().value;\r\n      const right = this.parseAdditive();\r\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseAdditive() {\r\n    let expr = this.parseMultiplicative();\r\n\r\n    while (this.isOperator('+') || this.isOperator('-')) {\r\n      const operator = this.advance().value;\r\n      const right = this.parseMultiplicative();\r\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseMultiplicative() {\r\n    let expr = this.parseUnary();\r\n\r\n    while (this.isOperator('*') || this.isOperator('/') || this.isOperator('%')) {\r\n      const operator = this.advance().value;\r\n      const right = this.parseUnary();\r\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseUnary() {\r\n    console.log(`        [parseUnary] Current: ${this.peek().value}`);\r\n\r\n    if (this.isOperator('!') || this.isOperator('-') || this.isOperator('+') || this.isOperator('~')) {\r\n      const operator = this.advance().value;\r\n      const expr = this.parseUnary();\r\n      return { type: 'UnaryExpression', operator, argument: expr };\r\n    }\r\n\r\n\r\n    console.log(`        [parseUnary] Calling parsePostfix`);\r\n    return this.parsePostfix();\r\n  }\r\n\r\n  parsePostfix() {\r\n    console.log(`        [parsePostfix] Starting, calling parseCall`);\r\n    let expr = this.parseCall();\r\n    console.log(`        [parsePostfix] parseCall returned: ${expr.type || expr.name}`);\r\n    console.log(`        [parsePostfix] Next token: ${this.peek().value}`);\r\n\r\n    while (true) {\r\n      if (this.isOperator('++') || this.isOperator('--')) {\r\n        const operator = this.advance().value;\r\n        expr = { type: 'UpdateExpression', operator, argument: expr, prefix: false };\r\n      } else if (this.isPunctuation('.')) {\r\n        console.log(`        [parsePostfix] Found . member access`);\r\n        this.advance();\r\n        const property = new Identifier(this.consume(TokenType.IDENTIFIER, 'Expected property').value);\r\n        expr = new MemberExpression(expr, property, false);\r\n        console.log(`        [parsePostfix] Created MemberExpression: ${expr.object.name}.${expr.property.name}`);\r\n      } else if (this.isPunctuation('[')) {\r\n        console.log(`        [parsePostfix] Found [ computed access`);\r\n        this.advance();\r\n        const property = this.parseExpression();\r\n        this.consume(TokenType.PUNCTUATION, 'Expected ]');\r\n        expr = new MemberExpression(expr, property, true);\r\n      } else {\r\n        console.log(`        [parsePostfix] No more postfix ops, returning ${expr.type}`);\r\n        break;\r\n      }\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n\r\n  parseCall() {\r\n    console.log(`        [parseCall] Starting, calling parsePrimary`);\r\n    let expr = this.parsePrimary();\r\n    console.log(`        [parseCall] parsePrimary returned: ${expr.type || expr.name}`);\r\n    console.log(`        [parseCall] Next token: ${this.peek().value} (${this.peek().type})`);\r\n\r\n    while (this.isPunctuation('(')) {\r\n      console.log(`        [parseCall] Found (, parsing function call`);\r\n      this.advance();\r\n      const args = this.parseArguments();\r\n      console.log(`        [parseCall] Parsed ${args.length} arguments`);\r\n      this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n      expr = new CallExpression(expr, args);\r\n      console.log(`        [parseCall] Created CallExpression`);\r\n    }\r\n\r\n    console.log(`        [parseCall] Returning: ${expr.type}`);\r\n    return expr;\r\n  }\r\n\r\n  parsePrimary() {\r\n    console.log(`      [parsePrimary] Current: ${this.peek().value} (${this.peek().type})`);\r\n\r\n    // Handle 'this' keyword FIRST\r\n    if (this.isKeyword('this')) {\r\n      this.advance();\r\n      console.log(`      [parsePrimary] \u2713 this keyword`);\r\n      return new Identifier('this');\r\n    }\r\n\r\n    if (this.check(TokenType.STRING)) {\r\n      const token = this.advance();\r\n      console.log(`      [parsePrimary] \u2713 string literal: ${token.value}`);\r\n      return new Literal(token.value, token.value, 'string');\r\n    }\r\n\r\n    if (this.check(TokenType.NUMBER)) {\r\n      const token = this.advance();\r\n      console.log(`      [parsePrimary] \u2713 number literal: ${token.value}`);\r\n      return new Literal(parseFloat(token.value), token.value, 'number');\r\n    }\r\n\r\n    if (this.check(TokenType.BOOLEAN)) {\r\n      const token = this.advance();\r\n      console.log(`      [parsePrimary] \u2713 boolean: ${token.value}`);\r\n      return new Literal(token.value === 'true', token.value, 'boolean');\r\n    }\r\n\r\n    if (this.check(TokenType.NULL)) {\r\n      this.advance();\r\n      console.log(`      [parsePrimary] \u2713 null`);\r\n      return new Literal(null, 'null', 'null');\r\n    }\r\n\r\n    if (this.check(TokenType.UNDEFINED)) {\r\n      this.advance();\r\n      console.log(`      [parsePrimary] \u2713 undefined`);\r\n      return new Literal(undefined, 'undefined', 'undefined');\r\n    }\r\n\r\n    if (this.isKeyword('null')) {\r\n      this.advance();\r\n      console.log(`      [parsePrimary] \u2713 null keyword`);\r\n      return new Literal(null, 'null', 'null');\r\n    }\r\n\r\n    if (this.isKeyword('undefined')) {\r\n      this.advance();\r\n      console.log(`      [parsePrimary] \u2713 undefined keyword`);\r\n      return new Literal(undefined, 'undefined', 'undefined');\r\n    }\r\n\r\n    if (this.isPunctuation('(')) {\r\n      console.log(`      [parsePrimary] Found ( - checking for arrow function or grouped expr`);\r\n      const savedPos = this.current;\r\n      this.advance();\r\n\r\n      if (this.isPunctuation(')')) {\r\n        const nextPos = this.current + 1;\r\n        if (nextPos < this.tokens.length &&\r\n          this.tokens[nextPos].type === TokenType.OPERATOR &&\r\n          this.tokens[nextPos].value === '=>') {\r\n          console.log(`      [parsePrimary] \u2713 arrow function with no params: () => ...`);\r\n          this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n          this.consume(TokenType.OPERATOR, 'Expected =>');\r\n          const body = this.parseExpression();\r\n          return new ArrowFunctionExpression([], body);\r\n        }\r\n      }\r\n\r\n      const expr = this.parseExpression();\r\n      this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n\r\n      if (this.isOperator('=>')) {\r\n        console.log(`      [parsePrimary] \u2713 arrow function: (x) => ...`);\r\n        this.advance();\r\n        const body = this.parseExpression();\r\n        let params = [];\r\n        if (expr.type === 'Identifier') {\r\n          params = [new Parameter(expr, false, null)];\r\n        }\r\n        return new ArrowFunctionExpression(params, body);\r\n      }\r\n\r\n      console.log(`      [parsePrimary] \u2713 grouped expression`);\r\n      return expr;\r\n    }\r\n\r\n    if (this.isPunctuation('{')) {\r\n      console.log(`      [parsePrimary] \u2713 object literal`);\r\n      this.advance();\r\n      return this.parseObjectLiteral();\r\n    }\r\n\r\n    if (this.isPunctuation('[')) {\r\n      console.log(`      [parsePrimary] \u2713 array literal`);\r\n      this.advance();\r\n      const elements = [];\r\n      while (!this.isPunctuation(']') && !this.isAtEnd()) {\r\n        elements.push(this.parseExpression());\r\n        if (!this.isPunctuation(',')) break;\r\n        this.advance();\r\n      }\r\n      this.consume(TokenType.PUNCTUATION, 'Expected ]');\r\n      return { type: 'ArrayLiteral', elements };\r\n    }\r\n\r\n    if (this.isKeyword('new')) {\r\n      console.log(`      [parsePrimary] \u2713 new expression`);\r\n      this.advance();\r\n      const callee = new Identifier(this.consume(TokenType.IDENTIFIER, 'Expected class name').value);\r\n      this.consume(TokenType.PUNCTUATION, 'Expected (');\r\n      const args = this.parseArguments();\r\n      this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n      return new NewExpression(callee, args);\r\n    }\r\n\r\n    if (this.isKeyword('const')) {\r\n      const savedPos = this.current;\r\n      this.advance();\r\n\r\n      // Case 1: const new ClassName(...)\r\n      if (this.isKeyword('new')) {\r\n        console.log(`      [parsePrimary] \u2713 const new expression`);\r\n        this.advance();\r\n        const callee = new Identifier(this.consume(TokenType.IDENTIFIER, 'Expected class name').value);\r\n        this.consume(TokenType.PUNCTUATION, 'Expected (');\r\n        const args = this.parseArguments();\r\n        this.consume(TokenType.PUNCTUATION, 'Expected )');\r\n        const expr = new NewExpression(callee, args);\r\n        expr.isConst = true;\r\n        return expr;\r\n      }\r\n\r\n      // Case 2: const ClassName(...) - implicit new\r\n      if (this.check(TokenType.IDENTIFIER)) {\r\n        console.log(`      [parsePrimary] \u2713 const implicit new expression (ignoring const)`);\r\n        // Just treat it as a normal identifier start, we consumed 'const'\r\n        // Recursively call parsePrimary to handle the Identifier\r\n        return this.parsePrimary();\r\n      }\r\n\r\n      // Case 3: const [] - constant array\r\n      if (this.isPunctuation('[')) {\r\n        console.log(`      [parsePrimary] \u2713 const array literal`);\r\n        // recurse to handle [\r\n        return this.parsePrimary();\r\n      }\r\n\r\n      // Case 4: const {} - constant object/map\r\n      if (this.isPunctuation('{')) {\r\n        console.log(`      [parsePrimary] \u2713 const object literal`);\r\n        return this.parsePrimary();\r\n      }\r\n\r\n      // Fallback\r\n      this.current = savedPos;\r\n    }\r\n\r\n    if (this.check(TokenType.IDENTIFIER)) {\r\n      const token = this.advance();\r\n      const ident = new Identifier(token.value);\r\n      console.log(`      [parsePrimary] \u2713 identifier: ${token.value}`);\r\n\r\n      if (this.isOperator('=>')) {\r\n        console.log(`      [parsePrimary] \u2713 arrow function: x => ...`);\r\n        this.advance();\r\n        const body = this.parseExpression();\r\n        return new ArrowFunctionExpression([new Parameter(ident)], body);\r\n      }\r\n\r\n      return ident;\r\n    }\r\n\r\n    // If we get here, we couldn't parse anything\r\n    console.error(`      [parsePrimary] \u274C FAILED - Cannot parse token: ${this.peek().value} (${this.peek().type})`);\r\n    throw this.error('Expected expression');\r\n  }\r\n\r\n\r\n  enterMethod(methodName) {\r\n    if (!this.callStack) this.callStack = [];\r\n    this.callStack.push({\r\n      method: methodName,\r\n      line: this.peek().line,\r\n      column: this.peek().column,\r\n      token: this.peek().value,\r\n    });\r\n  }\r\n\r\n  parseObjectLiteral() {\r\n    this.enterMethod('parseObjectLiteral');\r\n    const properties = [];\r\n\r\n    try {\r\n      while (!this.isPunctuation('}') && !this.isAtEnd()) {\r\n        if (this.isPunctuation(',')) {\r\n          this.advance();\r\n          continue;\r\n        }\r\n\r\n        let key = null;\r\n        let shorthand = false;\r\n\r\n        if (this.isPunctuation('[')) {\r\n          this.advance();\r\n          key = this.parseExpression();\r\n          this.consume(TokenType.PUNCTUATION, 'Expected ]');\r\n        } else if (this.check(TokenType.IDENTIFIER)) {\r\n          const token = this.advance();\r\n          key = new Identifier(token.value);\r\n\r\n          if (this.isPunctuation(',') || this.isPunctuation('}')) {\r\n            shorthand = true;\r\n          }\r\n        } else if (this.check(TokenType.STRING)) {\r\n          const token = this.advance();\r\n          key = new Literal(token.value, token.value, 'string');\r\n        } else {\r\n          this.advance();\r\n          continue;\r\n        }\r\n\r\n        let value = key;\r\n        if (!shorthand && this.isPunctuation(':')) {\r\n          this.advance();\r\n\r\n          try {\r\n            value = this.parseTernary();\r\n          } catch (error) {\r\n            if (error.parserError) {\r\n              this.reportParserError(error.parserError);\r\n            }\r\n            value = key;\r\n\r\n            while (!this.isPunctuation(',') && !this.isPunctuation('}') && !this.isAtEnd()) {\r\n              this.advance();\r\n            }\r\n          }\r\n        }\r\n\r\n        const prop = new Property(key, value);\r\n        prop.shorthand = shorthand;\r\n        properties.push(prop);\r\n\r\n        if (this.isPunctuation(',')) {\r\n          this.advance();\r\n        }\r\n      }\r\n\r\n      if (this.isPunctuation('}')) {\r\n        this.advance();\r\n      }\r\n\r\n      this.exitMethod('parseObjectLiteral');\r\n      return new ObjectLiteral(properties);\r\n    } catch (e) {\r\n      this.exitMethod('parseObjectLiteral');\r\n      throw e;\r\n    }\r\n  }\r\n  parseArguments() {\r\n    const args = [];\r\n\r\n    while (!this.isPunctuation(')') && !this.isAtEnd()) {\r\n      try {\r\n        // \u2B50 KEY FIX: Use parseTernary() instead of parseLogicalOr()\r\n        // This allows all operators except assignment\r\n        args.push(this.parseTernary());\r\n      } catch (error) {\r\n        break;\r\n      }\r\n\r\n      if (!this.isPunctuation(',')) break;\r\n      this.advance();\r\n    }\r\n\r\n    return args;\r\n  }\r\n\r\n  check(type) {\r\n    if (this.isAtEnd()) return false;\r\n    return this.peek().type === type;\r\n  }\r\n\r\n  consume(type, message = '') {\r\n    if (this.check(type)) {\r\n      return this.advance();\r\n    }\r\n    throw this.error(message || `Expected ${type}`);\r\n  }\r\n\r\n  consumeStatementEnd() {\r\n    this.skipComments();  // \u2190 ADD THIS LINE\r\n\r\n    if (this.isPunctuation(';')) {\r\n      this.advance();\r\n    }\r\n\r\n    this.skipComments();  // \u2190 ADD THIS LINE - skip trailing comments too\r\n  }\r\n\r\n  advance() {\r\n    if (!this.isAtEnd()) {\r\n      this.current++;\r\n    }\r\n    return this.previous();\r\n  }\r\n\r\n  peek() {\r\n    return this.tokens[this.current];\r\n  }\r\n\r\n\r\n  previous() {\r\n    return this.tokens[this.current - 1];\r\n  }\r\n\r\n  isAtEnd() {\r\n    return this.peek().type === TokenType.EOF;\r\n  }\r\n\r\n  getLocation() {\r\n    const token = this.peek();\r\n    return { line: token.line, column: token.column };\r\n  }\r\n  /**\r\n  * Enhanced error reporting with full call stack\r\n  */\r\n  error(message) {\r\n    const token = this.peek();\r\n    const errorObj = new Error(\r\n      `Parse error at line ${token.line}, column ${token.column}: ${message}`\r\n    );\r\n    errorObj.parserError = {\r\n      message: `Parse error at line ${token.line}, column ${token.column}: ${message}`,\r\n      line: token.line,\r\n      column: token.column,\r\n      token: { type: token.type, value: token.value },\r\n      callStack: this.callStack ? [...this.callStack] : [],\r\n    };\r\n    return errorObj;\r\n  }\r\n  /**\r\n   * Get context around current token (5 tokens before and after)\r\n   */\r\n  getContext() {\r\n    const start = Math.max(0, this.current - 5);\r\n    const end = Math.min(this.tokens.length, this.current + 6);\r\n\r\n    return {\r\n      before: this.tokens.slice(start, this.current).map(t => `${t.value}(${t.type})`).join(' '),\r\n      current: `\u2192 ${this.peek().value}(${this.peek().type}) \u2190`,\r\n      after: this.tokens.slice(this.current + 1, end).map(t => `${t.value}(${t.type})`).join(' '),\r\n    };\r\n  }\r\n  /**\r\n   * Track when exiting a parser method\r\n   */\r\n  exitMethod(methodName) {\r\n    if (!this.callStack) this.callStack = [];\r\n    if (this.callStack.length > 0) {\r\n      const last = this.callStack[this.callStack.length - 1];\r\n      if (last.method === methodName) {\r\n        this.callStack.pop();\r\n      }\r\n    }\r\n  }\r\n\r\n  getTokenContext() {\r\n    const start = Math.max(0, this.current - 5);\r\n    const end = Math.min(this.tokens.length, this.current + 6);\r\n\r\n    const before = this.tokens\r\n      .slice(start, this.current)\r\n      .map(t => `${t.value}`)\r\n      .join(' ');\r\n\r\n    const after = this.tokens\r\n      .slice(this.current + 1, end)\r\n      .map(t => `${t.value}`)\r\n      .join(' ');\r\n\r\n    return {\r\n      before: before,\r\n      current: `\u2192 ${this.peek().value} \u2190`,\r\n      after: after,\r\n    };\r\n  }\r\n\r\n  synchronize() {\r\n    this.advance();\r\n    while (!this.isAtEnd()) {\r\n      if (this.isPunctuation(';')) {\r\n        this.advance();\r\n        return;\r\n      }\r\n      if (this.isKeyword('class') || this.isKeyword('function') || this.isKeyword('import')) {\r\n        return;\r\n      }\r\n      this.advance();\r\n    }\r\n  }\r\n\r\n  getErrors() {\r\n    return this.errors;\r\n  }\r\n\r\n  /**\r\n   * Report error with full context\r\n   */\r\n  reportError(error) {\r\n    this.errors.push(error);\r\n\r\n    if (this.debugMode) {\r\n      console.error('\\n\u274C PARSER ERROR DETECTED:\\n');\r\n      console.error(`Message: ${error.message}\\n`);\r\n\r\n      console.error('\uD83D\uDCCD Token Context:');\r\n      console.error(`  Before:  ${error.context.before}`);\r\n      console.error(`  Current: ${error.context.current}`);\r\n      console.error(`  After:   ${error.context.after}\\n`);\r\n\r\n      console.error('\uD83D\uDCDA Call Stack (where error came from):');\r\n      if (error.callStack.length === 0) {\r\n        console.error('  (top level)\\n');\r\n      } else {\r\n        error.callStack.forEach((frame, idx) => {\r\n          const arrow = idx === error.callStack.length - 1 ? '\u2192' : ' ';\r\n          console.error(`  ${arrow} ${idx + 1}. ${frame.method}()`);\r\n          console.error(`     at token: \"${frame.token}\" (line ${frame.line}, col ${frame.column})`);\r\n        });\r\n        console.error('');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EXPORTS\r\n// ============================================================================\r\n\r\nexport {\r\n  Parser,\r\n  Program,\r\n  ImportDeclaration,\r\n  ImportSpecifier,\r\n  ClassDeclaration,\r\n  ClassBody,\r\n  FieldDeclaration,\r\n  MethodDeclaration,\r\n  Parameter,\r\n  FunctionDeclaration,\r\n  BlockStatement,\r\n  ReturnStatement,\r\n  ExpressionStatement,\r\n  Identifier,\r\n  Literal,\r\n  CallExpression,\r\n  NewExpression,\r\n  ObjectLiteral,\r\n  Property,\r\n  ArrowFunctionExpression,\r\n  MemberExpression,\r\n  ASTNode,\r\n};"],
  "mappings": "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",
  "names": ["TokenType", "getLogger", "ASTNode", "type", "location", "Program", "body", "ImportDeclaration", "specifiers", "source", "ImportSpecifier", "imported", "local", "ClassDeclaration", "id", "superClass", "ClassBody", "fields", "methods", "FieldDeclaration", "key", "initialValue", "MethodDeclaration", "params", "Parameter", "name", "optional", "defaultValue", "FunctionDeclaration", "isAsync", "BlockStatement", "ReturnStatement", "argument", "ExpressionStatement", "expression", "Identifier", "Literal", "value", "raw", "CallExpression", "callee", "args", "NewExpression", "ObjectLiteral", "properties", "Property", "ArrowFunctionExpression", "MemberExpression", "object", "property", "computed", "Parser", "tokens", "options", "stmt", "error", "expr", "token", "logger", "startLocation", "importedName", "localName", "defaultName", "imported2", "local2", "modulePathToken", "n", "pos", "nameToken", "superName", "itemCount", "currentPos", "fieldName", "e", "methodName", "paramLocation", "paramName", "braceDepth", "statements", "result", "consequent", "alternate", "right", "operator", "savedPos", "nextPos", "elements", "ident", "shorthand", "prop", "message", "errorObj", "start", "end", "t", "before", "after", "frame", "idx", "arrow"]
}
