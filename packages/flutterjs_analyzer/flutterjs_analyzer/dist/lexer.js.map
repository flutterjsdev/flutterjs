{
  "version": 3,
  "sources": ["../src/lexer.js"],
  "sourcesContent": ["// Copyright 2025 The FlutterJS Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style license that can be\r\n// found in the LICENSE file.\r\n\r\n/**\r\n * FlutterJS Lexer - Converts source code to tokens\r\n * Phase 1.1 MVP Implementation\r\n * \r\n * No external dependencies - pure Node.js\r\n */\r\n\r\n// ============================================================================\r\n// TOKEN CLASS\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a single token in the source code\r\n */\r\nclass Token {\r\n  constructor(type, value, line, column) {\r\n    this.type = type;           // Token type (KEYWORD, IDENTIFIER, etc.)\r\n    this.value = value;         // Token value (the actual string)\r\n    this.line = line;           // Line number (1-indexed)\r\n    this.column = column;       // Column number (0-indexed)\r\n  }\r\n\r\n  /**\r\n   * Get human-readable token representation\r\n   */\r\n  toString() {\r\n    return `Token(${this.type}, \"${this.value}\", ${this.line}:${this.column})`;\r\n  }\r\n\r\n  /**\r\n   * Check if this token matches a type or list of types\r\n   */\r\n  isType(types) {\r\n    if (Array.isArray(types)) {\r\n      return types.includes(this.type);\r\n    }\r\n    return this.type === types;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// TOKEN TYPE CONSTANTS\r\n// ============================================================================\r\n\r\nconst TokenType = {\r\n  // Literals\r\n  STRING: 'STRING',\r\n  NUMBER: 'NUMBER',\r\n  BOOLEAN: 'BOOLEAN',\r\n  NULL: 'NULL',\r\n  UNDEFINED: 'UNDEFINED',\r\n\r\n  // Keywords\r\n  KEYWORD: 'KEYWORD',\r\n\r\n  // Identifiers\r\n  IDENTIFIER: 'IDENTIFIER',\r\n\r\n  // Operators & Punctuation\r\n  OPERATOR: 'OPERATOR',\r\n  PUNCTUATION: 'PUNCTUATION',\r\n\r\n  // Comments & Whitespace\r\n  COMMENT: 'COMMENT',\r\n  WHITESPACE: 'WHITESPACE',\r\n  NEWLINE: 'NEWLINE',\r\n\r\n  // Special\r\n  EOF: 'EOF',\r\n};\r\n\r\n// ============================================================================\r\n// LEXER CLASS\r\n// ============================================================================\r\n\r\n/**\r\n * Lexer - Converts source code string into a stream of tokens\r\n */\r\nclass Lexer {\r\n  constructor(source, options = {}) {\r\n    this.source = source;\r\n    this.position = 0;           // Current position in source\r\n    this.line = 1;               // Current line number\r\n    this.column = 0;             // Current column number\r\n    this.tokens = [];            // Collected tokens\r\n    this.errors = [];            // Lexing errors\r\n\r\n    // Configuration\r\n    this.options = {\r\n      includeWhitespace: false,   // Include whitespace tokens in output\r\n      includeComments: true,      // Include comment tokens\r\n      ...options,\r\n    };\r\n\r\n    // Keywords that we care about for FlutterJS\r\n    this.keywords = new Set([\r\n      'class', 'extends', 'constructor', 'new', 'const',\r\n      'function', 'return', 'if', 'else', 'for', 'while',\r\n      'this', 'static', 'async', 'await', 'import', 'export',\r\n      'from', 'as', 'default', 'true', 'false', 'null',\r\n      'undefined', 'typeof', 'instanceof', 'void', 'delete',\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Main entry point - tokenize entire source\r\n   */\r\n  tokenize() {\r\n    while (this.position < this.source.length) {\r\n      this.scanToken();\r\n    }\r\n\r\n    this.tokens.push(new Token(TokenType.EOF, '', this.line, this.column));\r\n    return this.tokens;\r\n  }\r\n\r\n  /**\r\n   * Scan a single token\r\n   */\r\n  scanToken() {\r\n    const ch = this.peek();\r\n\r\n    // Handle whitespace\r\n    if (this.isWhitespace(ch)) {\r\n      return this.scanWhitespace();\r\n    }\r\n\r\n    // Handle comments\r\n    if (ch === '/' && (this.peekNext() === '/' || this.peekNext() === '*')) {\r\n      return this.scanComment();\r\n    }\r\n\r\n    // Handle strings\r\n    if (ch === '\"' || ch === \"'\" || ch === '`') {\r\n      return this.scanString();\r\n    }\r\n\r\n    // Handle numbers\r\n    if (this.isDigit(ch)) {\r\n      return this.scanNumber();\r\n    }\r\n\r\n    // Handle identifiers and keywords\r\n    if (this.isIdentifierStart(ch)) {\r\n      return this.scanIdentifier();\r\n    }\r\n\r\n    // Handle operators and punctuation\r\n    return this.scanOperatorOrPunctuation();\r\n  }\r\n\r\n  /**\r\n   * Scan whitespace and newlines\r\n   */\r\n  scanWhitespace() {\r\n    const startColumn = this.column;\r\n    let whitespaceStr = '';\r\n\r\n    while (this.position < this.source.length && this.isWhitespace(this.peek())) {\r\n      const ch = this.advance();\r\n      whitespaceStr += ch;\r\n\r\n      if (ch === '\\n') {\r\n        if (this.options.includeWhitespace) {\r\n          this.tokens.push(new Token(TokenType.NEWLINE, '\\n', this.line - 1, startColumn));\r\n        }\r\n        this.line++;\r\n        this.column = 0;\r\n        whitespaceStr = '';\r\n      }\r\n    }\r\n\r\n    // Add remaining whitespace if configured\r\n    if (this.options.includeWhitespace && whitespaceStr.length > 0) {\r\n      this.tokens.push(new Token(TokenType.WHITESPACE, whitespaceStr, this.line, startColumn));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scan comments (single-line // and multi-line )\r\n   */\r\n  scanComment() {\r\n    const startLine = this.line;\r\n    const startColumn = this.column;\r\n    let content = '';\r\n\r\n    if (this.peekNext() === '/') {\r\n      // Single-line comment\r\n      this.advance(); // /\r\n      this.advance(); // /\r\n\r\n      while (this.position < this.source.length && this.peek() !== '\\n') {\r\n        content += this.advance();\r\n      }\r\n\r\n      if (this.options.includeComments) {\r\n        this.tokens.push(new Token(TokenType.COMMENT, content, startLine, startColumn));\r\n      }\r\n    } else if (this.peekNext() === '*') {\r\n      // Multi-line comment\r\n      this.advance(); // /\r\n      this.advance(); // *\r\n\r\n      while (this.position < this.source.length) {\r\n        if (this.peek() === '*' && this.peekNext() === '/') {\r\n          this.advance(); // *\r\n          this.advance(); // /\r\n          break;\r\n        }\r\n\r\n        const ch = this.advance();\r\n        content += ch;\r\n\r\n        if (ch === '\\n') {\r\n          this.line++;\r\n          this.column = 0;\r\n        }\r\n      }\r\n\r\n      if (this.options.includeComments) {\r\n        this.tokens.push(new Token(TokenType.COMMENT, content, startLine, startColumn));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scan string literals (\", ', `)\r\n   */\r\n  scanString() {\r\n    const startLine = this.line;\r\n    const startColumn = this.column;\r\n    const quoteChar = this.advance();\r\n    let value = '';\r\n\r\n    while (this.position < this.source.length) {\r\n      const ch = this.peek();\r\n\r\n      if (ch === quoteChar) {\r\n        this.advance();\r\n        break;\r\n      }\r\n\r\n      if (ch === '\\\\') {\r\n        // Handle escape sequences\r\n        this.advance();\r\n        const escaped = this.advance();\r\n        value += this.getEscapeSequence(escaped);\r\n      } else {\r\n        if (ch === '\\n') {\r\n          this.line++;\r\n          this.column = 0;\r\n        }\r\n        value += this.advance();\r\n      }\r\n    }\r\n\r\n    this.tokens.push(new Token(TokenType.STRING, value, startLine, startColumn));\r\n  }\r\n\r\n  /**\r\n   * Scan number literals (integers and floats)\r\n   */\r\n  scanNumber() {\r\n    const startLine = this.line;\r\n    const startColumn = this.column;\r\n    let value = '';\r\n\r\n    // Scan integer part\r\n    while (this.position < this.source.length && this.isDigit(this.peek())) {\r\n      value += this.advance();\r\n    }\r\n\r\n    // Scan decimal part\r\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\r\n      value += this.advance(); // .\r\n      while (this.position < this.source.length && this.isDigit(this.peek())) {\r\n        value += this.advance();\r\n      }\r\n    }\r\n\r\n    // Scan exponent part (e.g., 1e10, 1E-5)\r\n    if ((this.peek() === 'e' || this.peek() === 'E') && this.isDigit(this.peekNext())) {\r\n      value += this.advance(); // e/E\r\n      if (this.peek() === '+' || this.peek() === '-') {\r\n        value += this.advance();\r\n      }\r\n      while (this.position < this.source.length && this.isDigit(this.peek())) {\r\n        value += this.advance();\r\n      }\r\n    }\r\n\r\n    this.tokens.push(new Token(TokenType.NUMBER, value, startLine, startColumn));\r\n  }\r\n\r\n  /**\r\n   * Scan identifiers and keywords\r\n   */\r\n  scanIdentifier() {\r\n    const startLine = this.line;\r\n    const startColumn = this.column;\r\n    let value = '';\r\n\r\n    while (\r\n      this.position < this.source.length &&\r\n      this.isIdentifierPart(this.peek())\r\n    ) {\r\n      value += this.advance();\r\n    }\r\n\r\n    // Check if it's a keyword or special literal\r\n    let tokenType = TokenType.IDENTIFIER;\r\n    if (this.keywords.has(value)) {\r\n      if (value === 'true' || value === 'false') {\r\n        tokenType = TokenType.BOOLEAN;\r\n      } else if (value === 'null') {\r\n        tokenType = TokenType.NULL;\r\n      } else if (value === 'undefined') {\r\n        tokenType = TokenType.UNDEFINED;\r\n      } else {\r\n        tokenType = TokenType.KEYWORD;\r\n      }\r\n    }\r\n\r\n    this.tokens.push(new Token(tokenType, value, startLine, startColumn));\r\n  }\r\n\r\n  /**\r\n   * Scan operators and punctuation\r\n   */\r\n  scanOperatorOrPunctuation() {\r\n    const startLine = this.line;\r\n    const startColumn = this.column;\r\n    const ch = this.advance();\r\n\r\n    // Two-character operators\r\n    const twoChar = ch + (this.peek() || '');\r\n    const twoCharOps = [\r\n      '=>', '==', '!=', '===', '!==', '<=', '>=',\r\n      '++', '--', '&&', '||', '+=', '-=', '*=', '/=', '%=',\r\n      '??', '?.', '..', '**',\r\n    ];\r\n\r\n    if (twoCharOps.includes(twoChar)) {\r\n      this.advance();\r\n      this.tokens.push(new Token(TokenType.OPERATOR, twoChar, startLine, startColumn));\r\n      return;\r\n    }\r\n\r\n    // Three-character operators\r\n    const threeChar = twoChar + (this.peek() || '');\r\n    const threeCharOps = ['===', '!==', '...'];\r\n    if (threeCharOps.includes(threeChar)) {\r\n      this.advance();\r\n      this.tokens.push(new Token(TokenType.OPERATOR, threeChar, startLine, startColumn));\r\n      return;\r\n    }\r\n\r\n    // Single-character operators\r\n    const singleCharOps = [\r\n      '+', '-', '*', '/', '%', '=', '<', '>', '!', '&', '|', '^', '~', '?', ':',\r\n    ];\r\n    if (singleCharOps.includes(ch)) {\r\n      this.tokens.push(new Token(TokenType.OPERATOR, ch, startLine, startColumn));\r\n      return;\r\n    }\r\n\r\n    // Punctuation\r\n    const punctuation = [\r\n      '{', '}', '(', ')', '[', ']', ';', ',', '.', '@', '#',\r\n    ];\r\n    if (punctuation.includes(ch)) {\r\n      this.tokens.push(new Token(TokenType.PUNCTUATION, ch, startLine, startColumn));\r\n      return;\r\n    }\r\n\r\n    // Unknown character - log error but continue\r\n    this.errors.push({\r\n      message: `Unexpected character: '${ch}'`,\r\n      line: startLine,\r\n      column: startColumn,\r\n    });\r\n  }\r\n\r\n  // =========================================================================\r\n  // HELPER METHODS\r\n  // =========================================================================\r\n\r\n  /**\r\n   * Peek at current character without consuming it\r\n   */\r\n  peek(offset = 0) {\r\n    const pos = this.position + offset;\r\n    if (pos >= this.source.length) return null;\r\n    return this.source[pos];\r\n  }\r\n\r\n  /**\r\n   * Peek at next character\r\n   */\r\n  peekNext() {\r\n    return this.peek(1);\r\n  }\r\n\r\n  /**\r\n   * Consume and return current character\r\n   */\r\n  advance() {\r\n    const ch = this.source[this.position];\r\n    this.position++;\r\n    this.column++;\r\n    return ch;\r\n  }\r\n\r\n  /**\r\n   * Check if character is whitespace (excluding newlines)\r\n   */\r\n  isWhitespace(ch) {\r\n    return ch === ' ' || ch === '\\t' || ch === '\\r' || ch === '\\n';\r\n  }\r\n\r\n  /**\r\n   * Check if character is a digit\r\n   */\r\n  isDigit(ch) {\r\n    return ch >= '0' && ch <= '9';\r\n  }\r\n\r\n  /**\r\n   * Check if character can start an identifier\r\n   */\r\n  isIdentifierStart(ch) {\r\n    if (!ch) return false;\r\n    return (ch >= 'a' && ch <= 'z') ||\r\n           (ch >= 'A' && ch <= 'Z') ||\r\n           ch === '_' ||\r\n           ch === '$';\r\n  }\r\n\r\n  /**\r\n   * Check if character can be part of an identifier\r\n   */\r\n  isIdentifierPart(ch) {\r\n    if (!ch) return false;\r\n    return this.isIdentifierStart(ch) || this.isDigit(ch);\r\n  }\r\n\r\n  /**\r\n   * Get escape sequence value\r\n   */\r\n  getEscapeSequence(ch) {\r\n    const escapes = {\r\n      'n': '\\n',\r\n      't': '\\t',\r\n      'r': '\\r',\r\n      '\\\\': '\\\\',\r\n      '\"': '\"',\r\n      \"'\": \"'\",\r\n      '`': '`',\r\n      '0': '\\0',\r\n    };\r\n    return escapes[ch] || ch;\r\n  }\r\n\r\n  /**\r\n   * Get all tokens (convenience method)\r\n   */\r\n  getTokens() {\r\n    return this.tokens;\r\n  }\r\n\r\n  /**\r\n   * Get all errors\r\n   */\r\n  getErrors() {\r\n    return this.errors;\r\n  }\r\n\r\n  /**\r\n   * Pretty-print tokens for debugging\r\n   */\r\n  printTokens() {\r\n    console.log('\\n=== TOKENS ===\\n');\r\n    this.tokens.forEach((token, index) => {\r\n      console.log(`[${index}] ${token.toString()}`);\r\n    });\r\n    console.log(`\\nTotal: ${this.tokens.length} tokens\\n`);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EXPORTS\r\n// ============================================================================\r\n\r\nexport {\r\n  Token,\r\n  Lexer,\r\n  TokenType,\r\n};"],
  "mappings": "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",
  "names": ["Token", "type", "value", "line", "column", "types", "TokenType", "Lexer", "source", "options", "ch", "startColumn", "whitespaceStr", "startLine", "content", "quoteChar", "escaped", "tokenType", "twoChar", "threeChar", "offset", "pos", "token", "index"]
}
