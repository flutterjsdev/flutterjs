{
  "version": 3,
  "sources": ["../src/flutterjs_widget_analyzer.js"],
  "sourcesContent": ["/**\r\n * WidgetAnalyzer Enhancement - Track field references\r\n * \r\n * Understand that:\r\n *   _count = 0;        <- field declaration\r\n *   this._count        <- field reference\r\n * \r\n * These are the same thing!\r\n */\r\n\r\nimport { getLogger } from './flutterjs_logger.js';\r\n\r\nclass WidgetAnalyzer {\r\n  constructor(ast, options = {}) {\r\n    this.ast = ast;\r\n    this.options = {\r\n      strict: false,\r\n      ...options,\r\n    };\r\n    this.logger = getLogger().createComponentLogger('WidgetAnalyzer');\r\n    this.widgets = new Map();        // key: className, value: Widget object\r\n    this.functions = new Map();      // key: functionName, value: Function object\r\n    this.imports = [];\r\n    this.externalDependencies = new Set();\r\n    this.entryPoint = null;\r\n    this.rootWidget = null;\r\n    this.widgetTree = null;\r\n    this.errors = [];\r\n  }\r\n\r\n  /**\r\n   * Main entry point - analyze entire AST\r\n   */\r\n  analyze() {\r\n    this.logger.startSession('WidgetAnalyzer');\r\n    if (!this.ast || !this.ast.body) {\r\n      throw new Error('Invalid AST provided');\r\n    }\r\n\r\n    this.logger.trace('[WidgetAnalyzer] Starting analysis...');\r\n\r\n    try {\r\n      // Phase 1: Extract all classes and functions\r\n      this.logger.trace('[WidgetAnalyzer] Phase 1: Extracting classes and functions...');\r\n      this.extractClassesAndFunctions();\r\n      this.logger.trace(`[WidgetAnalyzer]   Found ${this.widgets.size} classes in total`);\r\n\r\n      // Phase 2: Detect which classes are widgets\r\n      this.logger.trace('[WidgetAnalyzer] Phase 2: Detecting widgets...');\r\n      this.detectWidgets();\r\n      this.logger.trace(`[WidgetAnalyzer]   Detected widgets: ${Array.from(this.widgets.values()).filter(w => w.type !== 'class').length}`);\r\n\r\n      // Phase 3: Extract imports and dependencies\r\n      this.logger.trace('[WidgetAnalyzer] Phase 3: Extracting imports...');\r\n      this.extractImports();\r\n      this.logger.trace(`[WidgetAnalyzer]   Found ${this.imports.length} imports`);\r\n\r\n      // Phase 4: Find entry point\r\n      this.logger.trace('[WidgetAnalyzer] Phase 4: Finding entry point...');\r\n      this.findEntryPoint();\r\n      this.logger.trace(`[WidgetAnalyzer]   Entry point: ${this.entryPoint || 'NOT FOUND'}`);\r\n\r\n      // Phase 5: Build widget tree\r\n      this.logger.trace('[WidgetAnalyzer] Phase 5: Building widget tree...');\r\n      this.buildWidgetTree();\r\n      this.logger.trace(`[WidgetAnalyzer]   Tree root: ${this.rootWidget || 'NOT FOUND'}`);\r\n\r\n      this.logger.trace('[WidgetAnalyzer] Analysis complete\\n');\r\n\r\n      return this.getResults();\r\n    } catch (error) {\r\n      this.errors.push({\r\n        type: 'analysis-error',\r\n        message: error.message,\r\n        stack: error.stack,\r\n      });\r\n      return this.getResults();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Phase 1: Extract all classes and functions from AST\r\n   */\r\n  extractClassesAndFunctions() {\r\n    if (!this.ast.body) return;\r\n\r\n    for (const node of this.ast.body) {\r\n      if (node.type === 'ClassDeclaration') {\r\n        this.extractClassDeclaration(node);\r\n      } else if (node.type === 'FunctionDeclaration') {\r\n        this.extractFunctionDeclaration(node);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract a single class declaration\r\n   * Handles both field declarations and method declarations\r\n   */\r\n  extractClassDeclaration(classNode) {\r\n    const name = classNode.id?.name;\r\n    if (!name) return;\r\n\r\n    const superClass = classNode.superClass?.name || null;\r\n    const location = classNode.location;\r\n\r\n    const widget = {\r\n      name,\r\n      type: 'class',\r\n      location,\r\n      superClass,\r\n      constructor: null,\r\n      properties: [],      // Fields with their initial values\r\n      methods: [],\r\n      fieldReferences: {}, // Map of which methods use which fields\r\n      imports: [],\r\n      children: [],\r\n      linkedStateClass: null,\r\n    };\r\n\r\n    // Extract fields (declared with _count = 0; syntax)\r\n    if (classNode.body?.fields) {\r\n      classNode.body.fields.forEach((field) => {\r\n        const fieldName = field.key?.name;\r\n        const initialValue = field.initialValue ? this.expressionToString(field.initialValue) : null;\r\n\r\n        widget.properties.push({\r\n          name: fieldName,\r\n          initialValue: initialValue,\r\n          type: this.inferFieldType(field.initialValue),\r\n        });\r\n\r\n        // Track that this field exists\r\n        if (!widget.fieldReferences[fieldName]) {\r\n          widget.fieldReferences[fieldName] = [];\r\n        }\r\n      });\r\n    }\r\n\r\n    // Extract constructor\r\n    if (classNode.body?.methods) {\r\n      const constructorMethod = classNode.body.methods.find(\r\n        (m) => m.key?.name === 'constructor'\r\n      );\r\n      if (constructorMethod) {\r\n        widget.constructor = {\r\n          name: 'constructor',\r\n          params: constructorMethod.params || [],\r\n          location: constructorMethod.location,\r\n        };\r\n      }\r\n\r\n      // Extract other methods and track field usage\r\n      classNode.body.methods.forEach((method) => {\r\n        if (method.key?.name !== 'constructor') {\r\n          const methodName = method.key?.name;\r\n          const methodData = {\r\n            name: methodName,\r\n            params: method.params || [],\r\n            location: method.location,\r\n            hasBody: method.body !== null,\r\n            usesFields: [], // Which fields this method references\r\n          };\r\n\r\n          // Track field references in this method\r\n          if (method.body) {\r\n            const fieldRefs = this.findFieldReferencesInBody(method.body);\r\n            methodData.usesFields = fieldRefs;\r\n\r\n            // Update the field reference map\r\n            fieldRefs.forEach((fieldName) => {\r\n              if (widget.fieldReferences[fieldName]) {\r\n                widget.fieldReferences[fieldName].push(methodName);\r\n              }\r\n            });\r\n          }\r\n\r\n          widget.methods.push(methodData);\r\n        }\r\n      });\r\n    }\r\n\r\n    this.widgets.set(name, widget);\r\n    this.logger.trace(`[WidgetAnalyzer]     Extracted class: ${name} extends ${superClass}`);\r\n    if (widget.properties.length > 0) {\r\n      this.logger.trace(`[WidgetAnalyzer]       Fields: ${widget.properties.map(p => `${p.name}=${p.initialValue}`).join(', ')}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find all field references (this._fieldName) in a method body\r\n   */\r\n  findFieldReferencesInBody(body) {\r\n    const fields = [];\r\n\r\n    // Simple traversal to find this.fieldName patterns\r\n    // This is a basic implementation - enhance as needed\r\n    const traverse = (node) => {\r\n      if (!node) return;\r\n\r\n      // Look for MemberExpression: this._fieldName\r\n      if (node.type === 'MemberExpression') {\r\n        if (node.object?.name === 'this' && node.property?.name) {\r\n          fields.push(node.property.name);\r\n        }\r\n      }\r\n\r\n      // Recursively traverse all node properties\r\n      for (const key in node) {\r\n        if (key !== 'location' && typeof node[key] === 'object') {\r\n          if (Array.isArray(node[key])) {\r\n            node[key].forEach(traverse);\r\n          } else {\r\n            traverse(node[key]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    traverse(body);\r\n    return [...new Set(fields)]; // Remove duplicates\r\n  }\r\n\r\n  /**\r\n   * Infer the type of a field from its initializer\r\n   */\r\n  inferFieldType(initialValue) {\r\n    if (!initialValue) return 'any';\r\n\r\n    if (initialValue.type === 'Literal') {\r\n      const val = initialValue.value;\r\n      if (typeof val === 'number') return 'int' | 'double';\r\n      if (typeof val === 'boolean') return 'bool';\r\n      if (typeof val === 'string') return 'String';\r\n      if (val === null) return 'null';\r\n    }\r\n\r\n    if (initialValue.type === 'Identifier') {\r\n      return initialValue.name;\r\n    }\r\n\r\n    if (initialValue.type === 'ArrayExpression') {\r\n      return 'List';\r\n    }\r\n\r\n    if (initialValue.type === 'ObjectExpression') {\r\n      return 'Map';\r\n    }\r\n\r\n    return 'dynamic';\r\n  }\r\n\r\n  /**\r\n   * Extract a function declaration\r\n   */\r\n  extractFunctionDeclaration(funcNode) {\r\n    const name = funcNode.id?.name || 'anonymous';\r\n    const location = funcNode.location;\r\n\r\n    const func = {\r\n      name,\r\n      type: 'function',\r\n      location,\r\n      params: funcNode.params?.map((p) => ({\r\n        name: p.name?.name || 'param',\r\n        optional: p.optional || false,\r\n      })) || [],\r\n      isAsync: funcNode.isAsync || false,\r\n      isEntryPoint: false,\r\n    };\r\n\r\n    this.functions.set(name, func);\r\n  }\r\n\r\n  /**\r\n   * Phase 2: Detect which classes are widgets\r\n   */\r\n  detectWidgets() {\r\n    this.widgets.forEach((widget) => {\r\n      if (!widget.superClass) {\r\n        widget.type = 'class';\r\n        return;\r\n      }\r\n\r\n      const superClass = widget.superClass;\r\n\r\n      if (superClass === 'StatelessWidget') {\r\n        widget.type = 'stateless';\r\n        this.logger.trace(`[WidgetAnalyzer]     ${widget.name} is StatelessWidget`);\r\n      } else if (superClass === 'StatefulWidget') {\r\n        widget.type = 'stateful';\r\n        this.logger.trace(`[WidgetAnalyzer]     ${widget.name} is StatefulWidget`);\r\n      } else if (superClass?.startsWith('State')) {\r\n        widget.type = 'state';\r\n        this.logger.trace(`[WidgetAnalyzer]     ${widget.name} is State class`);\r\n      } else {\r\n        widget.type = 'component';\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Phase 3: Extract imports\r\n   */\r\n  // In flutterjs_widget_analyzer.js\r\n  extractImports() {\r\n    if (!this.ast.body) return;\r\n\r\n    this.ast.body.forEach((node) => {\r\n      if (node.type === 'ImportDeclaration') {\r\n        const source = node.source?.value;\r\n\r\n        // \u2705 Get all imported items (handles multi-line properly)\r\n        const items = node.specifiers?.map((spec) => {\r\n          // Use the local name (after 'as')\r\n          return spec.local?.name || spec.imported?.name;\r\n        }) || [];\r\n\r\n        this.imports.push({\r\n          source,\r\n          items,\r\n          specifiers: node.specifiers, // Keep raw specifiers for later\r\n        });\r\n\r\n        this.externalDependencies.add(source);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Phase 4: Find entry point\r\n   */\r\n  findEntryPoint() {\r\n    if (this.functions.has('main')) {\r\n      this.entryPoint = 'main';\r\n      const mainFunc = this.functions.get('main');\r\n      mainFunc.isEntryPoint = true;\r\n\r\n      const mainAstNode = this.ast.body.find(\r\n        (n) => n.type === 'FunctionDeclaration' && n.id?.name === 'main'\r\n      );\r\n\r\n      if (mainAstNode?.body?.body) {\r\n        this.rootWidget = this.findRunAppWidget(mainAstNode.body.body);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find which widget is passed to runApp()\r\n   */\r\n  findRunAppWidget(statements) {\r\n    for (const stmt of statements) {\r\n      if (stmt.type === 'ExpressionStatement' && stmt.expression?.type === 'CallExpression') {\r\n        const call = stmt.expression;\r\n        if (call.callee?.name === 'runApp' && call.args?.length > 0) {\r\n          return this.getWidgetNameFromExpression(call.args[0]);\r\n        }\r\n      }\r\n      if (stmt.type === 'ReturnStatement' && stmt.argument?.type === 'CallExpression') {\r\n        const call = stmt.argument;\r\n        if (call.callee?.name === 'runApp' && call.args?.length > 0) {\r\n          return this.getWidgetNameFromExpression(call.args[0]);\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract widget name from expression\r\n   */\r\n  getWidgetNameFromExpression(expr) {\r\n    if (!expr) return null;\r\n\r\n    if (expr.type === 'NewExpression') {\r\n      return expr.callee?.name;\r\n    }\r\n\r\n    if (expr.type === 'CallExpression') {\r\n      return expr.callee?.name;\r\n    }\r\n\r\n    if (expr.type === 'Identifier') {\r\n      return expr.name;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Phase 5: Build widget tree\r\n   */\r\n  buildWidgetTree() {\r\n    if (!this.rootWidget || !this.widgets.has(this.rootWidget)) {\r\n      return;\r\n    }\r\n\r\n    const rootWidget = this.widgets.get(this.rootWidget);\r\n    this.widgetTree = {\r\n      widget: rootWidget,\r\n      depth: 0,\r\n      children: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Convert expression to string representation\r\n   */\r\n  expressionToString(expr) {\r\n    if (!expr) return null;\r\n\r\n    if (expr.type === 'Literal') {\r\n      return expr.value;\r\n    }\r\n\r\n    if (expr.type === 'Identifier') {\r\n      const name = expr.name;\r\n      if (name === 'true' || name === 'false') return name === 'true';\r\n      if (name === 'null') return null;\r\n      if (name === 'undefined') return undefined;\r\n      return name;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Get results\r\n   */\r\n  getResults() {\r\n    const widgetArray = Array.from(this.widgets.values()).filter(\r\n      (w) => w.type === 'stateless' || w.type === 'stateful' || w.type === 'state' || w.type === 'component'\r\n    );\r\n\r\n    this.logger.trace(`[WidgetAnalyzer] getResults() returning ${widgetArray.length} widgets`);\r\n\r\n    return {\r\n      widgets: widgetArray,\r\n      functions: Array.from(this.functions.values()),\r\n      imports: this.imports,\r\n      externalDependencies: Array.from(this.externalDependencies),\r\n      entryPoint: this.entryPoint,\r\n      rootWidget: this.rootWidget,\r\n      widgetTree: this.widgetTree,\r\n      errors: this.errors,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get summary statistics\r\n   */\r\n  getSummary() {\r\n    const widgets = Array.from(this.widgets.values());\r\n    const statelessCount = widgets.filter((w) => w.type === 'stateless').length;\r\n    const statefulCount = widgets.filter((w) => w.type === 'stateful').length;\r\n    const stateCount = widgets.filter((w) => w.type === 'state').length;\r\n\r\n    return {\r\n      totalWidgets: widgets.length,\r\n      statelessWidgets: statelessCount,\r\n      statefulWidgets: statefulCount,\r\n      stateClasses: stateCount,\r\n      totalFunctions: this.functions.size,\r\n      totalImports: this.imports.length,\r\n      externalPackages: this.externalDependencies.size,\r\n      entryPoint: this.entryPoint,\r\n      rootWidget: this.rootWidget,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all errors\r\n   */\r\n  getErrors() {\r\n    return this.errors;\r\n  }\r\n}\r\n\r\nexport { WidgetAnalyzer };"],
  "mappings": "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",
  "names": ["getLogger", "WidgetAnalyzer", "ast", "options", "w", "error", "node", "classNode", "name", "superClass", "location", "widget", "field", "fieldName", "initialValue", "constructorMethod", "m", "method", "methodName", "methodData", "fieldRefs", "p", "body", "fields", "traverse", "key", "val", "funcNode", "func", "source", "items", "spec", "mainFunc", "mainAstNode", "n", "statements", "stmt", "call", "expr", "rootWidget", "widgetArray", "widgets", "statelessCount", "statefulCount", "stateCount"]
}
